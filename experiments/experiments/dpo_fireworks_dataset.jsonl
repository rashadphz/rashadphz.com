{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"regex-automata/src/util/captures.rs\":\n```diff\n@@ -772,7 +772,7 @@\n         replacement: &str,\n         dst: &mut String,\n     ) {\n-        self.interpolae\n+        self.interpola\n         interpolate::string(\n             replacement,\n             |index, dst| {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```regex-automata/src/util/captures.rs\n    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n    ///\n    /// let re = PikeVM::new_many(&[\n    ///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n<|editable_region_start|>\n    ///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n    /// ])?;\n    /// let mut cache = re.create_cache();\n    /// let mut caps = re.create_captures();\n    ///\n    /// let replacement = \"year=$year, month=$month, day=$day\";\n    ///\n    /// // This matches the first pattern.\n    /// let hay = \"On 14-03-2010, I became a Tenneessee lamb.\";\n    /// re.captures(&mut cache, hay, &mut caps);\n    /// let mut dst = String::new();\n    /// caps.interpolate_string_into(hay, replacement, &mut dst);\n    /// assert_eq!(\"year=2010, month=03, day=14\", dst);\n    ///\n    /// // And this matches the second pattern.\n    /// let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";\n    /// re.captures(&mut cache, hay, &mut caps);\n    /// let mut dst = String::new();\n    /// caps.interpolate_string_into(hay, replacement, &mut dst);\n    /// assert_eq!(\"year=2010, month=03, day=14\", dst);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn interpolate_string_into(\n        &self,\n        haystack: &str,\n        replacement: &str,\n        dst: &mut String,\n    ) {\n        self.interpola<|user_cursor_is_here|>\n        interpolate::string(\n            replacement,\n            |index, dst| {\n                let span = match self.get_group(index) {\n                    None => return,\n                    Some(span) => span,\n                };\n                dst.push_str(&haystack[span]);\n            },\n<|editable_region_end|>\n            |name| self.group_info().to_index(self.pattern()?, name),\n            dst,\n        );\n    }\n\n    /// Interpolates the capture references in `replacement` with the\n    /// corresponding substrings in `haystack` matched by each reference. The\n    /// interpolated byte string is returned.\n    ///\n    /// See the [`interpolate` module](interpolate) for documentation on the\n    /// format of the replacement string.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to use interpolation, and also shows how it\n    /// can work with multi-pattern regexes.\n    ///\n    /// ```\n    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n    ///\n    /// let re = PikeVM::new_many(&[\n    ///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n    ///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n    /// ])?;\n```"}, {"role": "assistant", "content": "Suggestion:\n```regex-automata/src/util/captures.rs\n    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n    ///\n    /// let re = PikeVM::new_many(&[\n    ///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n<|editable_region_start|>\n    ///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n    /// ])?;\n    /// let mut cache = re.create_cache();\n    /// let mut caps = re.create_captures();\n    ///\n    /// let replacement = \"year=$year, month=$month, day=$day\";\n    ///\n    /// // This matches the first pattern.\n    /// let hay = \"On 14-03-2010, I became a Tenneessee lamb.\";\n    /// re.captures(&mut cache, hay, &mut caps);\n    /// let mut dst = String::new();\n    /// caps.interpolate_string_into(hay, replacement, &mut dst);\n    /// assert_eq!(\"year=2010, month=03, day=14\", dst);\n    ///\n    /// // And this matches the second pattern.\n    /// let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";\n    /// re.captures(&mut cache, hay, &mut caps);\n    /// let mut dst = String::new();\n    /// caps.interpolate_string_into(hay, replacement, &mut dst);\n    /// assert_eq!(\"year=2010, month=03, day=14\", dst);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn interpolate_string_into(\n        &self,\n        haystack: &str,\n        replacement: &str,\n        dst: &mut String,\n    ) {\n        interpolate::string(\n            replacement,\n            |index, dst| {\n                let span = match self.get_group(index) {\n                    None => return,\n                    Some(span) => span,\n                };\n                dst.push_str(&haystack[span]);\n            },\n<|editable_region_end|>\n            |name| self.group_info().to_index(self.pattern()?, name),\n            dst,\n        );\n    }\n\n    /// Interpolates the capture references in `replacement` with the\n    /// corresponding substrings in `haystack` matched by each reference. The\n    /// interpolated byte string is returned.\n    ///\n    /// See the [`interpolate` module](interpolate) for documentation on the\n    /// format of the replacement string.\n    ///\n    /// # Example\n    ///\n    /// This example shows how to use interpolation, and also shows how it\n    /// can work with multi-pattern regexes.\n    ///\n    /// ```\n    /// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n    ///\n    /// let re = PikeVM::new_many(&[\n    ///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n    ///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n    /// ])?;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/color_swatches.rs\":\n```diff\n@@ -67,7 +67,7 @@\n             .update(&mut cx, |editor, cx| {\n                 let snapshot = editor.buffer.read(cx).snapshot(cx);\n                 \n-                for (i, )\n+                for (i, color_swatches) = col\n \n                 for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {\n                     let old_inlay_ids = editor\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/color_swatches.rs\n    let mut buffers = editor\n        .buffer\n        .read(cx)\n        .all_buffers()\n        .iter()\n        .map(|b| b.downgrade());\n\n    editor.color_swatches_task = Some(cx.spawn(|editor, mut cx| async move {\n        cx.background_executor().timer(UPDATE_DEBOUNCE).await;\n\n<|editable_region_start|>\n        let excerpts = editor\n            .update(&mut cx, |editor, cx| editor.excerpts_for_color_swatches(cx))\n            .ok()?;\n\n        let color_swatch_tasks = project\n            .update(&mut cx, |project, cx| {\n                excerpts\n                    .iter()\n                    .map(|(_, buffer)| project.color_swatches(&buffer, cx))\n                    .collect::<Vec<_>>()\n            })\n            .ok()?;\n\n        let color_swatches = futures::future::join_all(color_swatch_tasks)\n            .await\n            .into_iter()\n            .flatten()\n            .collect::<Vec<_>>();\n\n        editor\n            .update(&mut cx, |editor, cx| {\n                let snapshot = editor.buffer.read(cx).snapshot(cx);\n                \n                for (i, color_swatches) = col<|user_cursor_is_here|>\n\n                for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {\n                    let old_inlay_ids = editor\n                        .color_swatches\n                        .0\n                        .get_mut(&excerpt_id)\n                        .map(|old_swatches| std::mem::take(&mut old_swatches.inlays))\n                        .unwrap_or_default();\n\n                    let mut inlays = Vec::new();\n                    for color_swatch in color_swatches[i].iter() {\n                        if let Some(position) =\n                            snapshot.anchor_in_excerpt(*excerpt_id, color_swatch.range.start)\n                        {\n                            inlays.push(Inlay::color_swatch(\n                                post_inc(&mut editor.next_inlay_id),\n                                position,\n                                color_swatch.color.into(),\n                            ));\n                        }\n                    }\n\n<|editable_region_end|>\n                    //TODO: Do not reinsert inlays that are already present\n                    editor.color_swatches.0.insert(\n                        *excerpt_id,\n                        BufferColorSwatches {\n                            swatches: color_swatches[i],\n                            inlays: inlays.iter().map(|inlay| inlay.id).collect(),\n                        },\n                    );\n                    editor.splice_inlays(old_inlay_ids, inlays, cx);\n                }\n                cx.notify();\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/color_swatches.rs\n    let mut buffers = editor\n        .buffer\n        .read(cx)\n        .all_buffers()\n        .iter()\n        .map(|b| b.downgrade());\n\n    editor.color_swatches_task = Some(cx.spawn(|editor, mut cx| async move {\n        cx.background_executor().timer(UPDATE_DEBOUNCE).await;\n\n<|editable_region_start|>\n        let excerpts = editor\n            .update(&mut cx, |editor, cx| editor.excerpts_for_color_swatches(cx))\n            .ok()?;\n\n        let color_swatch_tasks = project\n            .update(&mut cx, |project, cx| {\n                excerpts\n                    .iter()\n                    .map(|(_, buffer)| project.color_swatches(&buffer, cx))\n                    .collect::<Vec<_>>()\n            })\n            .ok()?;\n\n        let color_swatches = futures::future::join_all(color_swatch_tasks)\n            .await\n            .into_iter()\n            .flatten()\n            .collect::<Vec<_>>();\n\n        editor\n            .update(&mut cx, |editor, cx| {\n                let snapshot = editor.buffer.read(cx).snapshot(cx);\n                \n                for (i, color_swatches) in color_swatches {\n                    \n                }\n\n                for (i, (excerpt_id, _)) in excerpts.into_().enumerate() {\n                    let old_inlay_ids = editor\n                        .color_swatches\n                        .0\n                        .get_mut(&excerpt_id)\n                        .map(|old_swatches| std::mem::take(&mut old_swatches.inlays))\n                        .unwrap_or_default();\n\n                    let mut inlays = Vec::new();\n                    for color_swatch in color_swatches[i].iter() {\n                        if let Some(position) =\n                            snapshot.anchor_in_excerpt(*excerpt_id, color_swatch.range.start)\n                        {\n                            inlays.push(Inlay::color_swatch(\n                                post_inc(&mut editor.next_inlay_id),\n                                position,\n                                color_swatch.color.into(),\n                            ));\n                        }\n                    }\n\n<|editable_region_end|>\n                    //TODO: Do not reinsert inlays that are already present\n                    editor.color_swatches.0.insert(\n                        *excerpt_id,\n                        BufferColorSwatches {\n                            swatches: color_swatches[i],\n                            inlays: inlays.iter().map(|inlay| inlay.id).collect(),\n                        },\n                    );\n                    editor.splice_inlays(old_inlay_ids, inlays, cx);\n                }\n                cx.notify();\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"untitled\":\n```diff\n@@ -1737,4 +1737,4 @@\n 4. Allow direct use of WebAssembly-specific functions without conditional compilation.\n \n This approach is cleaner and more straightforward for a WebAssembly-only project. It removes any ambiguity about the target platform and simplifies the codebase.\n-can I \n\\ No newline at end of file\n+can I cargo check for wasm32? all my diagnostics are gone even when I inte\n\\ No newline at end of file\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```untitled\n        }\n    \"#;\n\n    let mut state = State::new(canvas, wgsl_source).await.unwrap();\n\n    // For simplicity, we'll just render once here.\n    // In a real application, you'd set up a render loop.\n    state.render().unwrap();\n}\n```\n\n2. Update your `Cargo.toml`:\n\n```toml\n[package]\nname = \"wgpu-previewer\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\nwasm-bindgen-futures = \"0.4\"\nweb-sys = { version = \"0.3\", features = [\n    \"Document\",\n    \"Window\",\n    \"HtmlCanvasElement\",\n    \"DomRect\",\n]}\nwgpu = { version = \"0.19\", features = [\"webgl\"] }\nconsole_error_panic_hook = \"0.1\"\nconsole_log = \"1.0\"\nlog = \"0.4\"\n```\n\n3. In your `State::new` function, you can now use `create_surface_from_canvas` directly without conditional compilation:\n\n```rust\nimpl State {\n    async fn new(\n        canvas: HtmlCanvasElement,\n        shader_source: &str,\n    ) -> Result<Self, Box<dyn std::error::Error>> {\n        let instance = Instance::new(wgpu::InstanceDescriptor {\n            backends: wgpu::Backends::all(),\n<|editable_region_start|>\n            ..Default::default()\n        });\n\n        let surface = instance.create_surface_from_canvas(&canvas)\n            .map_err(|e| format!(\"Failed to create surface: {:?}\", e))?;\n\n        // ... rest of the function\n    }\n}\n```\n\nThese changes will:\n1. Ensure the code only compiles for the wasm32 target.\n2. Remove the need for a separate `main` function.\n3. Simplify the `Cargo.toml` by setting `crate-type = [\"cdylib\"]`.\n4. Allow direct use of WebAssembly-specific functions without conditional compilation.\n\nThis approach is cleaner and more straightforward for a WebAssembly-only project. It removes any ambiguity about the target platform and simplifies the codebase.\ncan I cargo check for wasm32? all my diagnostics are gone even when I inte<|user_cursor_is_here|>\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```untitled\n        }\n    \"#;\n\n    let mut state = State::new(canvas, wgsl_source).await.unwrap();\n\n    // For simplicity, we'll just render once here.\n    // In a real application, you'd set up a render loop.\n    state.render().unwrap();\n}\n```\n\n2. Update your `Cargo.toml`:\n\n```toml\n[package]\nname = \"wgpu-previewer\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\nwasm-bindgen-futures = \"0.4\"\nweb-sys = { version = \"0.3\", features = [\n    \"Document\",\n    \"Window\",\n    \"HtmlCanvasElement\",\n    \"DomRect\",\n]}\nwgpu = { version = \"0.19\", features = [\"webgl\"] }\nconsole_error_panic_hook = \"0.1\"\nconsole_log = \"1.0\"\nlog = \"0.4\"\n```\n\n3. In your `State::new` function, you can now use `create_surface_from_canvas` directly without conditional compilation:\n\n```rust\nimpl State {\n    async fn new(\n        canvas: HtmlCanvasElement,\n        shader_source: &str,\n    ) -> Result<Self, Box<dyn std::error::Error>> {\n        let instance = Instance::new(wgpu::InstanceDescriptor {\n            backends: wgpu::Backends::all(),\n<|editable_region_start|>\n            ..Default::default()\n        });\n\n        let surface = instance.create_surface_from_canvas(&canvas)\n            .map_err(|e| format!(\"Failed to create surface: {:?}\", e))?;\n\n        // ... rest of the function\n    }\n}\n```\n\nThese changes will:\n1. Ensure the code only compiles for the wasm32 target.\n2. Remove the need for a separate `main` function.\n3. Simplify the `Cargo.toml` by setting `crate-type = [\"cdylib\"]`.\n4. Allow direct use of WebAssembly-specific functions without conditional compilation.\n\nThis approach is cleaner and more straightforward for a WebAssembly-only project. It removes any ambiguity about the target platform and simplifies the codebase.\ncan I cargo check for wasm32? all my diagnostics are gone even when I integrate\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -647,7 +647,7 @@\n                     format!(\n                     \"{}:{}\",\n                         expected_placeholder.line, expected_placeholder.character\n-                    )\n+            )\n                 );\n             });\n \n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -645,9 +645,7 @@\n                 assert_eq!(\n                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n                     format!(\n-                    \"{}:{}\",\n-                        expected_placeholder.line, expected_placeholder.character\n-            )\n+                    \"{}:{}\",expected_placeholder.line, expected_placeholder.character)\n                 );\n             });\n \n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -645,7 +645,7 @@\n                 assert_eq!(\n                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n                     format!(\n-                    \"{}:{}\",expected_placeholder.line, expected_placeholder.character)\n+                    \"{}:{}\", expected_placeholder.line, expected_placeholder.character)\n                 );\n             });\n \n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -644,8 +644,7 @@\n             go_to_line_view.update(cx, |go_to_line_view| {\n                 assert_eq!(\n                     go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n-                    format!(\n-                    \"{}:{}\", expected_placeholder.line, expected_placeholder.character)\n+                    format!(\"{}:{}\", expected_placeholder.line, expected_placeholder.character)\n                 );\n             });\n \n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -641,14 +641,16 @@\n     ) {\n         let go_to_line_view = open_go_to_line_view(workspace, cx);\n \n-            go_to_line_view.update(cx, |go_to_line_view| {\n-                assert_eq!(\n-                    go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n-                    format!(\"{}:{}\", expected_placeholder.line, expected_placeholder.character)\n-                );\n-            });\n+        go_to_line_view.update(cx, |go_to_line_view| {\n+            assert_eq!(\n+                go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n+                format!(\n+                    \"{}:{}\",\n+                    expected_placeholder.line, expected_placeholder.character\n+                )\n+            );\n+        });\n \n-        );\n         cx.simulate_input(&format!(\"{}:{}\", new_point.line, new_point.character));\n         cx.dispatch_action(menu::Confirm);\n     }\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -640,7 +640,6 @@\n         cx: &mut VisualTestContext,\n     ) {\n         let go_to_line_view = open_go_to_line_view(workspace, cx);\n-\n         go_to_line_view.update(cx, |go_to_line_view| {\n             assert_eq!(\n                 go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -649,7 +649,6 @@\n                 )\n             );\n         });\n-\n         cx.simulate_input(&format!(\"{}:{}\", new_point.line, new_point.character));\n         cx.dispatch_action(menu::Confirm);\n     }\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -640,7 +640,7 @@\n         cx: &mut VisualTestContext,\n     ) {\n         let go_to_line_view = open_go_to_line_view(workspace, cx);\n-        go_to_line_view.update(cx, |go_to_line_view| {\n+        go_to_line_view.update(cx, |go_to_line_view, cx| {\n             assert_eq!(\n                 go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n                 format!(\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -642,7 +642,11 @@\n         let go_to_line_view = open_go_to_line_view(workspace, cx);\n         go_to_line_view.update(cx, |go_to_line_view, cx| {\n             assert_eq!(\n-                go_to_line_view.line_editor.read(cx).placeholder_text(cx),\n+                go_to_line_view\n+                    .line_editor\n+                    .read(cx)\n+                    .placeholder_text(cx)\n+                    .unwrap(),\n                 format!(\n                     \"{}:{}\",\n                     expected_placeholder.line, expected_placeholder.character\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -646,7 +646,7 @@\n                     .line_editor\n                     .read(cx)\n                     .placeholder_text(cx)\n-                    .unwrap(),\n+                    .expect(\"No placeholder text\"),\n                 format!(\n                     \"{}:{}\",\n                     expected_placeholder.line, expected_placeholder.character\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -67,6 +67,11 @@\n         cx: &mut ViewContext<Self>,\n     ) -> Self {\n         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n+            let last_position = s.head();\n+            let line_start = Point::new(last_position.row, 0);\n+            let chars_to_last_position = multi_buffer_snapshot\n+                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n+                .chars as u32;\n             let cursor = editor.selections.last::<Point>(cx).head();\n             let snapshot = active_buffer.read(cx).snapshot();\n \n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -67,7 +67,7 @@\n         cx: &mut ViewContext<Self>,\n     ) -> Self {\n         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n-            let last_position = s.head();\n+            let last_position = editor.selections.last::<Point>(cx).head();\n             let line_start = Point::new(last_position.row, 0);\n             let chars_to_last_position = multi_buffer_snapshot\n                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -72,7 +72,6 @@\n             let chars_to_last_position = multi_buffer_snapshot\n                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n                 .chars as u32;\n-            let cursor = editor.selections.last::<Point>(cx).head();\n             let snapshot = active_buffer.read(cx).snapshot();\n \n             let last_line = editor\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -67,12 +67,13 @@\n         cx: &mut ViewContext<Self>,\n     ) -> Self {\n         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n+            let snapshot = active_buffer.read(cx).snapshot();\n+\n             let last_position = editor.selections.last::<Point>(cx).head();\n             let line_start = Point::new(last_position.row, 0);\n-            let chars_to_last_position = multi_buffer_snapshot\n+            let chars_to_last_position = snapshot\n                 .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n                 .chars as u32;\n-            let snapshot = active_buffer.read(cx).snapshot();\n \n             let last_line = editor\n                 .buffer()\n\n```\n\nUser edited \"crates/go_to_line/src/go_to_line.rs\":\n```diff\n@@ -68,7 +68,7 @@\n     ) -> Self {\n         let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n             let snapshot = active_buffer.read(cx).snapshot();\n-\n+            // TODO kb extra\n             let last_position = editor.selections.last::<Point>(cx).head();\n             let line_start = Point::new(last_position.row, 0);\n             let chars_to_last_position = snapshot\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/go_to_line/src/go_to_line.rs\nimpl EventEmitter<DismissEvent> for GoToLine {}\n\nenum GoToLineRowHighlights {}\n\nimpl GoToLine {\n    fn register(editor: &mut Editor, cx: &mut ViewContext<Editor>) {\n        let handle = cx.view().downgrade();\n        editor\n            .register_action(move |_: &editor::actions::ToggleGoToLine, cx| {\n                let Some(editor_handle) = handle.upgrade() else {\n<|editable_region_start|>\n                    return;\n                };\n                let Some(workspace) = editor_handle.read(cx).workspace() else {\n                    return;\n                };\n                let editor = editor_handle.read(cx);\n                let Some((_, buffer, _)) = editor.active_excerpt(cx) else {\n                    return;\n                };\n                workspace.update(cx, |workspace, cx| {\n                    workspace.toggle_modal(cx, move |cx| GoToLine::new(editor_handle, buffer, cx));\n                })\n            })\n            .detach();\n    }\n\n    pub fn new(\n        active_editor: View<Editor>,\n        active_buffer: Model<Buffer>,\n        cx: &mut ViewContext<Self>,\n    ) -> Self {\n        let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n            let snapshot = active_buffer.read(cx).snapshot();\n            // TODO kb extra<|user_cursor_is_here|>\n            let last_position = editor.selections.last::<Point>(cx).head();\n            let line_start = Point::new(last_position.row, 0);\n            let chars_to_last_position = snapshot\n                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n                .chars as u32;\n\n            let last_line = editor\n                .buffer()\n                .read(cx)\n                .excerpts_for_buffer(&active_buffer, cx)\n                .into_iter()\n                .map(move |(_, range)| text::ToPoint::to_point(&range.context.end, &snapshot).row)\n                .max()\n                .unwrap_or(0);\n\n            (cursor, last_line, editor.scroll_position(cx))\n        });\n\n<|editable_region_end|>\n        let line = cursor.row + 1;\n        let column = cursor.column + 1;\n\n        let line_editor = cx.new_view(|cx| {\n            let mut editor = Editor::single_line(cx);\n            // TODO kb wrong column number here\n            editor.set_placeholder_text(format!(\"{line}{FILE_ROW_COLUMN_DELIMITER}{column}\"), cx);\n            editor\n        });\n        let line_editor_change = cx.subscribe(&line_editor, Self::on_line_editor_event);\n\n        let current_text = format!(\n            \"Current Line: {} of {} (column {})\",\n            line,\n            last_line + 1,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/go_to_line/src/go_to_line.rs\nimpl EventEmitter<DismissEvent> for GoToLine {}\n\nenum GoToLineRowHighlights {}\n\nimpl GoToLine {\n    fn register(editor: &mut Editor, cx: &mut ViewContext<Editor>) {\n        let handle = cx.view().downgrade();\n        editor\n            .register_action(move |_: &editor::actions::ToggleGoToLine, cx| {\n                let Some(editor_handle) = handle.upgrade() else {\n<|editable_region_start|>\n                    return;\n                };\n                let Some(workspace) = editor_handle.read(cx).workspace() else {\n                    return;\n                };\n                let editor = editor_handle.read(cx);\n                let Some((_, buffer, _)) = editor.active_excerpt(cx) else {\n                    return;\n                };\n                workspace.update(cx, |workspace, cx| {\n                    workspace.toggle_modal(cx, move |cx| GoToLine::new(editor_handle, buffer, cx));\n                })\n            })\n            .detach();\n    }\n\n    pub fn new(\n        active_editor: View<Editor>,\n        active_buffer: Model<Buffer>,\n        cx: &mut ViewContext<Self>,\n    ) -> Self {\n        let (cursor, last_line, scroll_position) = active_editor.update(cx, |editor, cx| {\n            let snapshot = active_buffer.read(cx).snapshot();\n            // TODO kb extract\n            let last_position = editor.selections.last::<Point>(cx).head();\n            let line_start = Point::new(last_position.row, 0);\n            let chars_to_last_position = snapshot\n                .text_summary_for_range::<text::TextSummary, _>(line_start..last_position)\n                .chars as u32;\n\n            let last_line = editor\n                .buffer()\n                .read(cx)\n                .excerpts_for_buffer(&active_buffer, cx)\n                .into_iter()\n                .map(move |(_, range)| text::ToPoint::to_point(&range.context.end, &snapshot).row)\n                .max()\n                .unwrap_or(0);\n\n            (cursor, last_line, editor.scroll_position(cx))\n        });\n\n<|editable_region_end|>\n        let line = cursor.row + 1;\n        let column = cursor.column + 1;\n\n        let line_editor = cx.new_view(|cx| {\n            let mut editor = Editor::single_line(cx);\n            // TODO kb wrong column number here\n            editor.set_placeholder_text(format!(\"{line}{FILE_ROW_COLUMN_DELIMITER}{column}\"), cx);\n            editor\n        });\n        let line_editor_change = cx.subscribe(&line_editor, Self::on_line_editor_event);\n\n        let current_text = format!(\n            \"Current Line: {} of {} (column {})\",\n            line,\n            last_line + 1,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/go_to_line/src/cursor_position.rs\":\n```diff\n@@ -31,7 +31,7 @@\n /// A position in the editor, where user's caret is located at.\n /// Lines are never zero as there is always at least one line in the editor.\n /// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,\n-/// \n+/// where \"1\" will mean \"before the firt c\"\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct UserCaretPosition {\n     pub line: NonZeroU32,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/go_to_line/src/cursor_position.rs\nuse editor::Editor;\nuse gpui::{AppContext, FocusHandle, FocusableView, Subscription, Task, View, WeakView};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse settings::{Settings, SettingsSources};\nuse std::{fmt::Write, num::NonZeroU32, time::Duration};\nuse text::{Point, Selection};\nuse ui::{\n    div, Button, ButtonCommon, Clickable, FluentBuilder, IntoElement, LabelSize, ParentElement,\n<|editable_region_start|>\n    Render, Tooltip, ViewContext,\n};\nuse util::paths::FILE_ROW_COLUMN_DELIMITER;\nuse workspace::{item::ItemHandle, StatusItemView, Workspace};\n\n#[derive(Copy, Clone, Debug, Default, PartialOrd, PartialEq)]\npub(crate) struct SelectionStats {\n    pub lines: usize,\n    pub characters: usize,\n    pub selections: usize,\n}\n\npub struct CursorPosition {\n    position: Option<UserCaretPosition>,\n    selected_count: SelectionStats,\n    context: Option<FocusHandle>,\n    workspace: WeakView<Workspace>,\n    update_position: Task<()>,\n    _observe_active_editor: Option<Subscription>,\n}\n\n/// A position in the editor, where user's caret is located at.\n/// Lines are never zero as there is always at least one line in the editor.\n/// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,\n/// where \"1\" will mean \"before the firt c<|user_cursor_is_here|>\"\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct UserCaretPosition {\n    pub line: NonZeroU32,\n    pub character: u32,\n}\n\nimpl CursorPosition {\n    pub fn new(workspace: &Workspace) -> Self {\n        Self {\n            position: None,\n            context: None,\n            selected_count: Default::default(),\n<|editable_region_end|>\n            workspace: workspace.weak_handle(),\n            update_position: Task::ready(()),\n            _observe_active_editor: None,\n        }\n    }\n\n    fn update_position(\n        &mut self,\n        editor: View<Editor>,\n        debounce: Option<Duration>,\n        cx: &mut ViewContext<Self>,\n    ) {\n        let editor = editor.downgrade();\n        self.update_position = cx.spawn(|cursor_position, mut cx| async move {\n            let is_singleton = editor\n                .update(&mut cx, |editor, cx| {\n                    editor.buffer().read(cx).is_singleton()\n                })\n                .ok()\n                .unwrap_or(true);\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/go_to_line/src/cursor_position.rs\nuse editor::Editor;\nuse gpui::{AppContext, FocusHandle, FocusableView, Subscription, Task, View, WeakView};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse settings::{Settings, SettingsSources};\nuse std::{fmt::Write, num::NonZeroU32, time::Duration};\nuse text::{Point, Selection};\nuse ui::{\n    div, Button, ButtonCommon, Clickable, FluentBuilder, IntoElement, LabelSize, ParentElement,\n<|editable_region_start|>\n    Render, Tooltip, ViewContext,\n};\nuse util::paths::FILE_ROW_COLUMN_DELIMITER;\nuse workspace::{item::ItemHandle, StatusItemView, Workspace};\n\n#[derive(Copy, Clone, Debug, Default, PartialOrd, PartialEq)]\npub(crate) struct SelectionStats {\n    pub lines: usize,\n    pub characters: usize,\n    pub selections: usize,\n}\n\npub struct CursorPosition {\n    position: Option<UserCaretPosition>,\n    selected_count: SelectionStats,\n    context: Option<FocusHandle>,\n    workspace: WeakView<Workspace>,\n    update_position: Task<()>,\n    _observe_active_editor: Option<Subscription>,\n}\n\n/// A position in the editor, where user's caret is located at.\n/// Lines are never zero as there is always at least one line in the editor.\n/// Characters may start with zero as the caret may be at the beginning of a line, but all editors start counting characters from 1,\n/// where \"1\" will mean \"before the first character\"\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct UserCaretPosition {\n    pub line: NonZeroU32,\n    pub character: u32,\n}\n\nimpl CursorPosition {\n    pub fn new(workspace: &Workspace) -> Self {\n        Self {\n            position: None,\n            context: None,\n            selected_count: Default::default(),\n<|editable_region_end|>\n            workspace: workspace.weak_handle(),\n            update_position: Task::ready(()),\n            _observe_active_editor: None,\n        }\n    }\n\n    fn update_position(\n        &mut self,\n        editor: View<Editor>,\n        debounce: Option<Duration>,\n        cx: &mut ViewContext<Self>,\n    ) {\n        let editor = editor.downgrade();\n        self.update_position = cx.spawn(|cursor_position, mut cx| async move {\n            let is_singleton = editor\n                .update(&mut cx, |editor, cx| {\n                    editor.buffer().read(cx).is_singleton()\n                })\n                .ok()\n                .unwrap_or(true);\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -12003,7 +12003,7 @@\n         cx: &mut ViewContext<Self>,\n     ) {\n         let Some(buffer) = self.buffer.read(cx).as_singleton() else {\n-            return;\n+            return N;\n         };\n \n         let Some(workspace) = self.workspace() else {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/editor.rs\n    pub fn insert_uuid_v4(&mut self, _: &InsertUuidV4, cx: &mut ViewContext<Self>) {\n        self.insert_uuid(UuidVersion::V4, cx);\n    }\n\n    pub fn insert_uuid_v7(&mut self, _: &InsertUuidV7, cx: &mut ViewContext<Self>) {\n        self.insert_uuid(UuidVersion::V7, cx);\n    }\n\n    fn insert_uuid(&mut self, version: UuidVersion, cx: &mut ViewContext<Self>) {\n        self.transact(cx, |this, cx| {\n            let edits = this\n                .selections\n                .all::<Point>(cx)\n                .into_iter()\n                .map(|selection| {\n                    let uuid = match version {\n                        UuidVersion::V4 => uuid::Uuid::new_v4(),\n                        UuidVersion::V7 => uuid::Uuid::now_v7(),\n<|editable_region_start|>\n                    };\n\n                    (selection.range(), uuid.to_string())\n                });\n            this.edit(edits, cx);\n            this.refresh_inline_completion(true, false, cx);\n        });\n    }\n\n    pub fn open_selections_in_multibuffer(\n        &mut self,\n        _: &OpenSelectionsInMultibuffer,\n        cx: &mut ViewContext<Self>,\n    ) {\n        let Some(buffer) = self.buffer.read(cx).as_singleton() else {\n            return N<|user_cursor_is_here|>;\n        };\n\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let locations = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|range| Location {\n                buffer: buffer.clone(),\n                range: range.start.text_anchor..range.end.text_anchor,\n            })\n            .collect::<Vec<_>>();\n\n        cx.spawn(|_, mut cx| async move {\n            workspace.update(&mut cx, |workspace, cx| {\n<|editable_region_end|>\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    \"Selections\".into(),\n                    false,\n                    MultibufferSelectionMode::All,\n                    cx,\n                );\n            })\n        })\n        .detach();\n    }\n\n    /// Adds a row highlight for the given range. If a row has multiple highlights, the\n    /// last highlight added will be used.\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/editor.rs\n    pub fn insert_uuid_v4(&mut self, _: &InsertUuidV4, cx: &mut ViewContext<Self>) {\n        self.insert_uuid(UuidVersion::V4, cx);\n    }\n\n    pub fn insert_uuid_v7(&mut self, _: &InsertUuidV7, cx: &mut ViewContext<Self>) {\n        self.insert_uuid(UuidVersion::V7, cx);\n    }\n\n    fn insert_uuid(&mut self, version: UuidVersion, cx: &mut ViewContext<Self>) {\n        self.transact(cx, |this, cx| {\n            let edits = this\n                .selections\n                .all::<Point>(cx)\n                .into_iter()\n                .map(|selection| {\n                    let uuid = match version {\n                        UuidVersion::V4 => uuid::Uuid::new_v4(),\n                        UuidVersion::V7 => uuid::Uuid::now_v7(),\n<|editable_region_start|>\n                    };\n\n                    (selection.range(), uuid.to_string())\n                });\n            this.edit(edits, cx);\n            this.refresh_inline_completion(true, false, cx);\n        });\n    }\n\n    pub fn open_selections_in_multibuffer(\n        &mut self,\n        _: &OpenSelectionsInMultibuffer,\n        cx: &mut ViewContext<Self>,\n    ) {\n        let Some(buffer) = self.buffer.read(cx).as_singleton() else {\n            return None;\n        };\n\n        let Some(workspace) = self.workspace() else {\n            return None;\n        };\n\n        let locations = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|range| Location {\n                buffer: buffer.clone(),\n                range: range.start.text_anchor..range.end.text_anchor,\n            })\n            .collect::<Vec<_>>();\n\n        cx.spawn(|_, mut cx| async move {\n            workspace.update(&mut cx, |workspace, cx| {\n<|editable_region_end|>\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    \"Selections\".into(),\n                    false,\n                    MultibufferSelectionMode::All,\n                    cx,\n                );\n            })\n        })\n        .detach();\n    }\n\n    /// Adds a row highlight for the given range. If a row has multiple highlights, the\n    /// last highlight added will be used.\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/git_ui/src/git_panel.rs\":\n```diff\n@@ -208,7 +208,7 @@\n                 workspace,\n             };\n             git_panel.schedule_update(window, cx);\n-            git_panel.show_scrollbar = git_panel.should_show_scrollbar(window, cx);\n+            git_panel.show_scrollbar = git_panel.should_show_scrollbar(cx);\n             git_panel\n         });\n \n\n```\n\nUser edited \"crates/git_ui/src/repository_selector.rs\":\n```diff\n@@ -34,7 +34,7 @@\n         };\n \n         let picker =\n-            cx.new_model(|cx| Picker::uniform_list(delegate, cx).max_height(Some(rems(20.).into())));\n+            cx.new_model(|cx| Picker::uniform_list(delegate, window, cx).max_height(Some(rems(20.).into())));\n \n         let _subscriptions = if let Some(git_state) = git_state {\n             vec![cx.subscribe(&git_state, Self::handle_project_git_event)]\n\n```\n\nUser edited \"crates/assistant2/src/context_picker/thread_context_picker.rs\":\n```diff\n@@ -104,7 +104,7 @@\n         \"Search threads\u2026\".into()\n     }\n \n-    fn update_matches(&mut self, query: String, cx: &mut ViewContext<Picker<Self>>) -> Task<()> {\n+    fn update_matches(&mut self, query: String, cx: &mut ModelContext<Picker<Self>>) -> Task<()> {\n         let Ok(threads) = self.thread_store.update(cx, |this, _cx| {\n             this.threads()\n                 .into_iter()\n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -142,7 +142,7 @@\n         self.selected_index\n     }\n \n-    fn set_selected_index(&mut self, ix: usize, _cx: &mut <Picker<Self>>) {\n+    fn set_selected_index(&mut self, ix: usize, _cx: &mut ModelContext<Picker<Self>>) {\n         self.selected_index = ix;\n     }\n \n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -150,7 +150,7 @@\n         \"Search...\".into()\n     }\n \n-    fn update_matches(&mut self, query: String, cx: &mut ViewContext<Picker<Self>>) -> Task<()> {\n+    fn update_matches(&mut self, query: String, cx: &mut ViewContextPicker<Self>>) -> Task<()> {\n         let search = self.store.read(cx).search(query, cx);\n         cx.spawn(|this, mut cx| async move {\n             let matches = search.await;\n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -150,7 +150,7 @@\n         \"Search...\".into()\n     }\n \n-    fn update_matches(&mut self, query: String, cx: &mut ViewContextPicker<Self>>) -> Task<()> {\n+    fn update_matches(&mut self, query: String, cx: &mut ViewContext<Picker<Self>>) -> Task<()> {\n         let search = self.store.read(cx).search(query, cx);\n         cx.spawn(|this, mut cx| async move {\n             let matches = search.await;\n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -150,7 +150,7 @@\n         \"Search...\".into()\n     }\n \n-    fn update_matches(&mut self, query: String, cx: &mut ViewContext<Picker<Self>>) -> Task<()> {\n+    fn update_matches(&mut self, query: String, cx: &mut ModelContext<Picker<Self>>) -> Task<()> {\n         let search = self.store.read(cx).search(query, cx);\n         cx.spawn(|this, mut cx| async move {\n             let matches = search.await;\n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -169,7 +169,7 @@\n         })\n     }\n \n-    fn confirm(&mut self, _secondary: bool, cx: &mut ViewContext<Picker<Self>>) {\n+    fn confirm(&mut self, _secondary: bool, cx: &mut ModelContext<Picker<Self>>) {\n         if let Some(metadata) = self.matches.get(self.selected_index) {\n             cx.emit(SavedContextPickerEvent::Confirmed(metadata.clone()));\n         }\n\n```\n\nUser edited \"crates/assistant_context_editor/src/context_history.rs\":\n```diff\n@@ -174,7 +174,7 @@\n             cx.emit(SavedContextPickerEvent::Confirmed(metadata.clone()));\n         }\n     }\n-\n+    \n     fn dismissed(&mut self, _cx: &mut ViewContext<Picker<Self>>) {}\n \n     fn render_match(\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/assistant_context_editor/src/context_history.rs\n    fn set_selected_index(&mut self, ix: usize, _cx: &mut ModelContext<Picker<Self>>) {\n        self.selected_index = ix;\n    }\n\n    fn placeholder_text(&self, _window: &mut Window, _cx: &mut AppContext) -> Arc<str> {\n        \"Search...\".into()\n    }\n\n    fn update_matches(&mut self, query: String, cx: &mut ModelContext<Picker<Self>>) -> Task<()> {\n        let search = self.store.read(cx).search(query, cx);\n        cx.spawn(|this, mut cx| async move {\n            let matches = search.await;\n            this.update(&mut cx, |this, cx| {\n                let host_contexts = this.delegate.store.read(cx).host_contexts();\n                this.delegate.matches = host_contexts\n                    .iter()\n                    .cloned()\n                    .map(ContextMetadata::Remote)\n                    .chain(matches.into_iter().map(ContextMetadata::Saved))\n                    .collect();\n                this.delegate.selected_index = 0;\n                cx.notify();\n            })\n            .ok();\n        })\n    }\n\n<|editable_region_start|>\n    fn confirm(&mut self, _secondary: bool, cx: &mut ModelContext<Picker<Self>>) {\n        if let Some(metadata) = self.matches.get(self.selected_index) {\n            cx.emit(SavedContextPickerEvent::Confirmed(metadata.clone()));\n        }\n    }\n    <|user_cursor_is_here|>\n    fn dismissed(&mut self, _cx: &mut ViewContext<Picker<Self>>) {}\n\n    fn render_match(\n        &self,\n        ix: usize,\n        selected: bool,\n        cx: &mut ViewContext<Picker<Self>>,\n    ) -> Option<Self::ListItem> {\n        let context = self.matches.get(ix)?;\n        let item = match context {\n            ContextMetadata::Remote(context) => {\n                let host_user = self.project.read(cx).host().and_then(|collaborator| {\n                    self.project\n                        .read(cx)\n                        .user_store()\n                        .read(cx)\n                        .get_cached_user(collaborator.user_id)\n                });\n                div()\n                    .flex()\n                    .w_full()\n                    .justify_between()\n                    .gap_2()\n<|editable_region_end|>\n                    .child(\n                        h_flex().flex_1().overflow_x_hidden().child(\n                            Label::new(context.summary.clone().unwrap_or(DEFAULT_TAB_TITLE.into()))\n                                .size(LabelSize::Small),\n                        ),\n                    )\n                    .child(\n                        h_flex()\n                            .gap_2()\n                            .children(if let Some(host_user) = host_user {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/assistant_context_editor/src/context_history.rs\n    fn set_selected_index(&mut self, ix: usize, _cx: &mut ModelContext<Picker<Self>>) {\n        self.selected_index = ix;\n    }\n\n    fn placeholder_text(&self, _window: &mut Window, _cx: &mut AppContext) -> Arc<str> {\n        \"Search...\".into()\n    }\n\n    fn update_matches(&mut self, query: String, cx: &mut ModelContext<Picker<Self>>) -> Task<()> {\n        let search = self.store.read(cx).search(query, cx);\n        cx.spawn(|this, mut cx| async move {\n            let matches = search.await;\n            this.update(&mut cx, |this, cx| {\n                let host_contexts = this.delegate.store.read(cx).host_contexts();\n                this.delegate.matches = host_contexts\n                    .iter()\n                    .cloned()\n                    .map(ContextMetadata::Remote)\n                    .chain(matches.into_iter().map(ContextMetadata::Saved))\n                    .collect();\n                this.delegate.selected_index = 0;\n                cx.notify();\n            })\n            .ok();\n        })\n    }\n\n<|editable_region_start|>\n    fn confirm(&mut self, _secondary: bool, cx: &mut ModelContext<Picker<Self>>) {\n        if let Some(metadata) = self.matches.get(self.selected_index) {\n            cx.emit(SavedContextPickerEvent::Confirmed(metadata.clone()));\n        }\n    }\n\n    fn dismissed(&mut self, _cx: &mut ModelContext<Picker<Self>>) {}\n\n    fn render_match(\n        &self,\n        ix: usize,\n        selected: bool,\n        cx: &mut ModelContext<Picker<Self>>,\n    ) -> Option<Self::ListItem> {\n        let context = self.matches.get(ix)?;\n        let item = match context {\n            ContextMetadata::Remote(context) => {\n                let host_user = self.project.read(cx).host().and_then(|collaborator| {\n                    self.project\n                        .read(cx)\n                        .user_store()\n                        .read(cx)\n                        .get_cached_user(collaborator.user_id)\n                });\n                div()\n                    .flex()\n                    .w_full()\n                    .justify_between()\n                    .gap_2()\n<|editable_region_end|>\n                    .child(\n                        h_flex().flex_1().overflow_x_hidden().child(\n                            Label::new(context.summary.clone().unwrap_or(DEFAULT_TAB_TITLE.into()))\n                                .size(LabelSize::Small),\n                        ),\n                    )\n                    .child(\n                        h_flex()\n                            .gap_2()\n                            .children(if let Some(host_user) = host_user {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -146,7 +146,7 @@\n                             .detach_and_log_err(cx);\n                             RepositoryState {\n                                 worktree: handle.clone(),\n-                                work_directory: repository_entry.work_directory(),\n+                                work_directory: repo.work\n                                 git_repo: local_repo.repo().clone(),\n                                 commit_message,\n                             }\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -146,7 +146,7 @@\n                             .detach_and_log_err(cx);\n                             RepositoryState {\n                                 worktree: handle.clone(),\n-                                work_directory: repo.work\n+                                work_directory: repo.work_directory.clone(),\n                                 git_repo: local_repo.repo().clone(),\n                                 commit_message,\n                             }\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -151,6 +151,7 @@\n                                 commit_message,\n                             }\n                         });\n+                        union.\n                         union.insert(repo);\n                     }\n                 })\n\n```\n\n\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -151,7 +151,6 @@\n                                 commit_message,\n                             }\n                         });\n-                        union.\n                         union.insert(repo);\n                     }\n                 })\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -151,6 +151,7 @@\n                                 commit_message,\n                             }\n                         });\n+                        union.\n                         union.insert(repo);\n                     }\n                 })\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -151,7 +151,6 @@\n                                 commit_message,\n                             }\n                         });\n-                        union.\n                         union.insert(repo);\n                     }\n                 })\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -44,6 +44,8 @@\n     commit_message: Model<Buffer>,\n }\n \n+impl SumTree::Item\n+\n enum GitOperation {\n     // FIXME String\n     StageAndCommit(Arc<dyn GitRepository>, String, Vec<RepoPath>),\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -44,7 +44,15 @@\n     commit_message: Model<Buffer>,\n }\n \n-impl SumTree::Item\n+impl sum_tree::Item for RepositoryState {\n+    fn id(&self) -> sum_tree::Id {\n+        sum_tree::Id::new(self.worktree.id().to_string())\n+    }\n+\n+    fn children(&self) -> Vec<sum_tree::ItemRef> {\n+        vec![]\n+    }\n+}\n \n enum GitOperation {\n     // FIXME String\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -46,7 +46,7 @@\n \n impl sum_tree::Item for RepositoryState {\n     fn id(&self) -> sum_tree::Id {\n-        sum_tree::Id::new(self.worktree.id().to_string())\n+        \n     }\n \n     fn children(&self) -> Vec<sum_tree::ItemRef> {\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -45,13 +45,6 @@\n }\n \n impl sum_tree::Item for RepositoryState {\n-    fn id(&self) -> sum_tree::Id {\n-        \n-    }\n-\n-    fn children(&self) -> Vec<sum_tree::ItemRef> {\n-        vec![]\n-    }\n }\n \n enum GitOperation {\n\n```\n\n\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -47,6 +47,8 @@\n impl sum_tree::Item for RepositoryState {\n }\n \n+impl sum_tre\n+\n enum GitOperation {\n     // FIXME String\n     StageAndCommit(Arc<dyn GitRepository>, String, Vec<RepoPath>),\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -47,7 +47,7 @@\n impl sum_tree::Item for RepositoryState {\n }\n \n-impl sum_tre\n+impl sum_tree::KeyedItem for Rep\n \n enum GitOperation {\n     // FIXME String\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -47,7 +47,7 @@\n impl sum_tree::Item for RepositoryState {\n }\n \n-impl sum_tree::KeyedItem for Rep\n+impl sum_tree::KeyedItem for Reposito\n \n enum GitOperation {\n     // FIXME String\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/git.rs\nuse sum_tree::SumTree;\nuse util::maybe;\nuse worktree::{ProjectEntryId, RepositoryEntry, StatusEntry, WorkDirectory, Worktree};\n\nstruct Key {\n    worktree_id: WorktreeId,\n    work_directory_id: ProjectEntryId,\n}\n\npub struct GitState {\n    repositories: SumTree<RepositoryState>,\n    active_key: Option<Key>,\n    update_sender: mpsc::UnboundedSender<(GitOperation, mpsc::Sender<anyhow::Error>)>,\n    languages: Arc<LanguageRegistry>,\n    _subscription: Subscription,\n}\n<|editable_region_start|>\n\npub struct RepositoryHandle {\n    git_state: WeakModel<GitState>,\n    key: Key,\n}\n\n#[derive(Clone)]\npub struct RepositoryState {\n    worktree: WeakModel<Worktree>,\n    work_directory: WorkDirectory,\n    git_repo: Arc<dyn GitRepository>,\n    commit_message: Model<Buffer>,\n}\n\nimpl sum_tree::Item for RepositoryState {\n}\n\nimpl sum_tree::KeyedItem for Reposito<|user_cursor_is_here|>\n\nenum GitOperation {\n    // FIXME String\n    StageAndCommit(Arc<dyn GitRepository>, String, Vec<RepoPath>),\n    Commit(Arc<dyn GitRepository>, String),\n    Stage(Arc<dyn GitRepository>, Vec<RepoPath>),\n    Unstage(Arc<dyn GitRepository>, Vec<RepoPath>),\n}\n\n// TODO richer events, so we know if the active repository was updated or not, etc.\npub enum Event {\n    RepositoriesUpdated,\n}\n\nimpl EventEmitter<Event> for GitState {}\n\nimpl GitState {\n    pub fn new(\n        worktree_store: &Model<WorktreeStore>,\n        languages: Arc<LanguageRegistry>,\n        cx: &mut ModelContext<'_, Self>,\n    ) -> Self {\n        let (update_sender, mut update_receiver) =\n            mpsc::unbounded::<(GitOperation, mpsc::Sender<anyhow::Error>)>();\n        cx.spawn(|_, cx| async move {\n            while let Some((msg, mut err_sender)) = update_receiver.next().await {\n                let result = cx\n                    .background_executor()\n<|editable_region_end|>\n                    .spawn(async move {\n                        match msg {\n                            GitOperation::StageAndCommit(repo, message, paths) => {\n                                repo.stage_paths(&paths)?;\n                                repo.commit(&message.to_string())?;\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/git.rs\nuse sum_tree::SumTree;\nuse util::maybe;\nuse worktree::{ProjectEntryId, RepositoryEntry, StatusEntry, WorkDirectory, Worktree};\n\nstruct Key {\n    worktree_id: WorktreeId,\n    work_directory_id: ProjectEntryId,\n}\n\npub struct GitState {\n    repositories: SumTree<RepositoryState>,\n    active_key: Option<Key>,\n    update_sender: mpsc::UnboundedSender<(GitOperation, mpsc::Sender<anyhow::Error>)>,\n    languages: Arc<LanguageRegistry>,\n    _subscription: Subscription,\n}\n<|editable_region_start|>\n\npub struct RepositoryHandle {\n    git_state: WeakModel<GitState>,\n    key: Key,\n}\n\n#[derive(Clone)]\npub struct RepositoryState {\n    worktree: WeakModel<Worktree>,\n    work_directory: WorkDirectory,\n    git_repo: Arc<dyn GitRepository>,\n    commit_message: Model<Buffer>,\n}\n\nimpl sum_tree::Item for RepositoryState {\n}\n\nimpl sum_tree::KeyedItem for RepositoryState {\n    fn key(&self) -> sum_tree::Key {\n        sum_tree::Key::new(self.worktree.id().to_string())\n    }\n}\n\nenum GitOperation {\n    // FIXME String\n    StageAndCommit(Arc<dyn GitRepository>, String, Vec<RepoPath>),\n    Commit(Arc<dyn GitRepository>, String),\n    Stage(Arc<dyn GitRepository>, Vec<RepoPath>),\n    Unstage(Arc<dyn GitRepository>, Vec<RepoPath>),\n}\n\n// TODO richer events, so we know if the active repository was updated or not, etc.\npub enum Event {\n    RepositoriesUpdated,\n}\n\nimpl EventEmitter<Event> for GitState {}\n\nimpl GitState {\n    pub fn new(\n        worktree_store: &Model<WorktreeStore>,\n        languages: Arc<LanguageRegistry>,\n        cx: &mut ModelContext<'_, Self>,\n    ) -> Self {\n        let (update_sender, mut update_receiver) =\n            mpsc::unbounded::<(GitOperation, mpsc::Sender<anyhow::Error>)>();\n        cx.spawn(|_, cx| async move {\n            while let Some((msg, mut err_sender)) = update_receiver.next().await {\n                let result = cx\n                    .background_executor()\n<|editable_region_end|>\n                    .spawn(async move {\n                        match msg {\n                            GitOperation::StageAndCommit(repo, message, paths) => {\n                                repo.stage_paths(&paths)?;\n                                repo.commit(&message.to_string())?;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -412,7 +412,7 @@\n                 .child(terms_button),\n         )\n         .child(\n-            h_flex().child(\n+            h_flex()..child(\n                 Button::new(\"accept_terms\", \"I've read and accept the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -412,7 +412,7 @@\n                 .child(terms_button),\n         )\n         .child(\n-            h_flex()..child(\n+            h_flex().child(\n                 Button::new(\"accept_terms\", \"I've read and accept the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -412,7 +412,7 @@\n                 .child(terms_button),\n         )\n         .child(\n-            h_flex().child(\n+            h_flex().justify_end().child(\n                 Button::new(\"accept_terms\", \"I've read and accept the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -412,7 +412,7 @@\n                 .child(terms_button),\n         )\n         .child(\n-            h_flex().justify_end().child(\n+            h_flex().w_full().justify_end().child(\n                 Button::new(\"accept_terms\", \"I've read and accept the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n\n```\n\n\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -404,6 +404,7 @@\n     let text = \"To start using Zed AI, please read and accept the\";\n \n     let form = v_flex()\n+        .w_full()\n         .gap_1()\n         .child(\n             h_flex()\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -405,7 +405,7 @@\n \n     let form = v_flex()\n         .w_full()\n-        .gap_1()\n+        .gap_2()\n         .child(\n             h_flex()\n                 .flex_wrap()\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -414,7 +414,7 @@\n         )\n         .child(\n             h_flex().w_full().justify_end().child(\n-                Button::new(\"accept_terms\", \"I've read and accept the Terms of Service\")\n+                Button::new(\"accept_terms\", \"I agree with the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n                     .on_click({\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -414,7 +414,7 @@\n         )\n         .child(\n             h_flex().w_full().justify_end().child(\n-                Button::new(\"accept_terms\", \"I agree with the Terms of Service\")\n+                Button::new(\"accept_terms\", \"I accept the Terms of Service\")\n                     .style(ButtonStyle::Tinted(TintColor::Accent))\n                     .disabled(accept_terms_disabled)\n                     .on_click({\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -894,6 +894,7 @@\n             v_flex()\n                 .gap_3()\n                 .max_w_4_5()\n+                .w\n                 .children(render_accept_terms(self.state.clone(), cx))\n                 .when(has_accepted_terms, |this| {\n                     this.child(subscription_text)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -894,7 +894,6 @@\n             v_flex()\n                 .gap_3()\n                 .max_w_4_5()\n-                .w\n                 .children(render_accept_terms(self.state.clone(), cx))\n                 .when(has_accepted_terms, |this| {\n                     this.child(subscription_text)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -893,7 +893,9 @@\n         if is_connected {\n             v_flex()\n                 .gap_3()\n-                .max_w_4_5()\n+                .max_w_4_5(\n+                    \n+                // )\n                 .children(render_accept_terms(self.state.clone(), cx))\n                 .when(has_accepted_terms, |this| {\n                     this.child(subscription_text)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -895,7 +895,6 @@\n                 .gap_3()\n                 .max_w_4_5(\n                     \n-                // )\n                 .children(render_accept_terms(self.state.clone(), cx))\n                 .when(has_accepted_terms, |this| {\n                     this.child(subscription_text)\n\n```\n\nUser edited \"crates/language_models/src/provider/cloud.rs\":\n```diff\n@@ -893,7 +893,8 @@\n         if is_connected {\n             v_flex()\n                 .gap_3()\n-                .max_w_4_5(\n+                // .max_w_4_5(\n+                \n                     \n                 .children(render_accept_terms(self.state.clone(), cx))\n                 .when(has_accepted_terms, |this| {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/language_models/src/provider/cloud.rs\n        let is_connected = !self.state.read(cx).is_signed_out();\n        let plan = self.state.read(cx).user_store.read(cx).current_plan();\n        let has_accepted_terms = self.state.read(cx).has_accepted_terms_of_service(cx);\n\n<|editable_region_start|>\n        let is_pro = plan == Some(proto::Plan::ZedPro);\n        let subscription_text = Label::new(if is_pro {\n            \"You have full access to Zed's hosted LLMs, which include models from Anthropic, OpenAI, and Google. They come with faster speeds and higher limits through Zed Pro.\"\n        } else {\n            \"You have basic access to models from Anthropic through the Zed AI Free plan.\"\n        });\n        let manage_subscription_button = if is_pro {\n            Some(\n                h_flex().child(\n                    Button::new(\"manage_settings\", \"Manage Subscription\")\n                        .style(ButtonStyle::Tinted(TintColor::Accent))\n                        .on_click(cx.listener(|_, _, cx| cx.open_url(&zed_urls::account_url(cx)))),\n                ),\n            )\n        } else if cx.has_flag::<ZedPro>() {\n            Some(\n                h_flex()\n                    .gap_2()\n                    .child(\n                        Button::new(\"learn_more\", \"Learn more\")\n                            .style(ButtonStyle::Subtle)\n                            .on_click(cx.listener(|_, _, cx| cx.open_url(ZED_AI_URL))),\n                    )\n                    .child(\n                        Button::new(\"upgrade\", \"Upgrade\")\n                            .style(ButtonStyle::Subtle)\n                            .color(Color::Accent)\n                            .on_click(\n                                cx.listener(|_, _, cx| cx.open_url(&zed_urls::account_url(cx))),\n                            ),\n                    ),\n            )\n        } else {\n            None\n        };\n\n        if is_connected {\n            v_flex()\n                .gap_3()\n                // .max_w_4_5(\n                <|user_cursor_is_here|>\n                    \n                .children(render_accept_terms(self.state.clone(), cx))\n                .when(has_accepted_terms, |this| {\n                    this.child(subscription_text)\n                        .children(manage_subscription_button)\n                })\n        } else {\n            v_flex()\n                .gap_2()\n                .child(Label::new(\"Use Zed AI to access hosted language models.\"))\n                .child(\n                    Button::new(\"sign_in\", \"Sign In\")\n                        .icon_color(Color::Muted)\n                        .icon(IconName::Github)\n                        .icon_position(IconPosition::Start)\n                        .on_click(cx.listener(move |this, _, cx| this.authenticate(cx))),\n                )\n        }\n    }\n}\n<|editable_region_end|>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/language_models/src/provider/cloud.rs\n        let is_connected = !self.state.read(cx).is_signed_out();\n        let plan = self.state.read(cx).user_store.read(cx).current_plan();\n        let has_accepted_terms = self.state.read(cx).has_accepted_terms_of_service(cx);\n\n<|editable_region_start|>\n        let is_pro = plan == Some(proto::Plan::ZedPro);\n        let subscription_text = Label::new(if is_pro {\n            \"You have full access to Zed's hosted LLMs, which include models from Anthropic, OpenAI, and Google. They come with faster speeds and higher limits through Zed Pro.\"\n        } else {\n            \"You have basic access to models from Anthropic through the Zed AI Free plan.\"\n        });\n        let manage_subscription_button = if is_pro {\n            Some(\n                h_flex().child(\n                    Button::new(\"manage_settings\", \"Manage Subscription\")\n                        .style(ButtonStyle::Tinted(TintColor::Accent))\n                        .on_click(cx.listener(|_, _, cx| cx.open_url(&zed_urls::account_url(cx)))),\n                ),\n            )\n        } else if cx.has_flag::<ZedPro>() {\n            Some(\n                h_flex()\n                    .gap_2()\n                    .child(\n                        Button::new(\"learn_more\", \"Learn more\")\n                            .style(ButtonStyle::Subtle)\n                            .on_click(cx.listener(|_, _, cx| cx.open_url(ZED_AI_URL))),\n                    )\n                    .child(\n                        Button::new(\"upgrade\", \"Upgrade\")\n                            .style(ButtonStyle::Subtle)\n                            .color(Color::Accent)\n                            .on_click(\n                                cx.listener(|_, _, cx| cx.open_url(&zed_urls::account_url(cx))),\n                            ),\n                    ),\n            )\n        } else {\n            None\n        };\n\n        if is_connected {\n            v_flex()\n                .gap_3()\n                // .max_w_4_5(\n\n                .children(render_accept_terms(self.state.clone(), cx))\n                .when(has_accepted_terms, |this| {\n                    this.child(subscription_text)\n                        .children(manage_subscription_button)\n                })\n        } else {\n            v_flex()\n                .gap_2()\n                .child(Label::new(\"Use Zed AI to access hosted language models.\"))\n                .child(\n                    Button::new(\"sign_in\", \"Sign In\")\n                        .icon_color(Color::Muted)\n                        .icon(IconName::Github)\n                        .icon_position(IconPosition::Start)\n                        .on_click(cx.listener(move |this, _, cx| this.authenticate(cx))),\n                )\n        }\n    }\n}\n<|editable_region_end|>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/terminal/src/rate_limited_sender.rs\":\n```diff\n@@ -8,6 +8,8 @@\n     last_time_sent: Instant,\n }\n \n+pub fn\n+\n impl<T> RateLimitedSender<T> {\n     pub fn new(min_wait: Duration, max_wait: Duration, sender: Sender<T>) -> RateLimitedSender<T> {\n         let now = Instant::now();\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/terminal/src/rate_limited_sender.rs\n<|start_of_file|>\nuse tokio::sync::mpsc::{self, Receiver, Sender};\n\npub struct RateLimitedSender<T> {\n    sender: Sender<T>,\n<|editable_region_start|>\n    min_wait: Duration,\n    max_wait: Duration,\n    last_time_called: Instant,\n    last_time_sent: Instant,\n}\n\npub fn<|user_cursor_is_here|>\n\nimpl<T> RateLimitedSender<T> {\n    pub fn new(min_wait: Duration, max_wait: Duration, sender: Sender<T>) -> RateLimitedSender<T> {\n        let now = Instant::now();\n        let old_time = now.checked_sub(min_wait.max(max_wait)).unwrap_or(now);\n        Self {\n            sender: Arc::new(Mutex::new(None)),\n            min_wait,\n            max_wait,\n<|editable_region_end|>\n            last_time_called: old_time,\n            last_time_sent: old_time,\n        }\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/terminal/src/rate_limited_sender.rs\n<|start_of_file|>\nuse tokio::sync::mpsc::{self, Receiver, Sender};\n\npub struct RateLimitedSender<T> {\n    sender: Sender<T>,\n<|editable_region_start|>\n    min_wait: Duration,\n    max_wait: Duration,\n    last_time_called: Instant,\n    last_time_sent: Instant,\n}\n\npub fn create<T>() -> (RateLimitedSender<T>, Receiver<T>) {\n    let (sender, receiver) = mpsc::channel();\n    let rate_limited_sender = RateLimitedSender::new(\n        Duration::from_millis(100),  // default min wait\n        Duration::from_secs(1),      // default max wait\n        sender,\n    );\n    (rate_limited_sender, receiver)\n}\n\nimpl<T> RateLimitedSender<T> {\n    pub fn new(min_wait: Duration, max_wait: Duration, sender: Sender<T>) -> RateLimitedSender<T> {\n        let now = Instant::now();\n        let old_time = now.checked_sub(min_wait.max(max_wait)).unwrap_or(now);\n        Self {\n            sender: Arc::new(Mutex::new(None)),\n            min_wait,\n            max_wait,\n<|editable_region_end|>\n            last_time_called: old_time,\n            last_time_sent: old_time,\n        }\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -278,7 +278,7 @@\n             return Task::ready(Err(anyhow!(\"thread store not available\")));\n         };\n         \n-        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx))\n+        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n \n         let Some(thread) = self\n             .thread_store\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -277,17 +277,8 @@\n         else {\n             return Task::ready(Err(anyhow!(\"thread store not available\")));\n         };\n-        \n-        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n \n-        let Some(thread) = self\n-            .thread_store\n-            .clone()\n-            .and_then(|this| this.upgrade())\n-            .and_then(|this| this.update(cx, |this, cx| this.open_thread(&thread.id, cx)))\n-        else {\n-            return;\n-        };\n+        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,8 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-\n+        cx.spawn\n+        \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n         });\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,7 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-        cx.spawn\n+        cx.spawn()\n         \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,7 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-        cx.spawn()\n+        cx.spawn(cx, |this, cx| )\n         \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,7 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-        cx.spawn(cx, |this, cx| )\n+        cx.spawn(|)\n         \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,9 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-        cx.spawn(|)\n+        cx.spawn(|this, cx| async move {\n+            \n+        })\n         \n         context_store.update(cx, |context_store, cx| {\n             context_store.add_thread(thread, cx);\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -280,14 +280,12 @@\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n         cx.spawn(|this, cx| async move {\n-            \n+            context_store.update(cx, |context_store, cx| {\n+                context_store.add_thread(thread, cx);\n+            });\n+\n+            cx.notify();\n         })\n-        \n-        context_store.update(cx, |context_store, cx| {\n-            context_store.add_thread(thread, cx);\n-        });\n-\n-        cx.notify();\n     }\n \n     fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -279,7 +279,7 @@\n         };\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n-        cx.spawn(|this, cx| async move {\n+        cx.spawn(|this, mut cx| async move {\n             context_store.update(cx, |context_store, cx| {\n                 context_store.add_thread(thread, cx);\n             });\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -280,7 +280,7 @@\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n         cx.spawn(|this, mut cx| async move {\n-            context_store.update(cx, |context_store, cx| {\n+            context_store.update(&mut cx, |context_store, cx| {\n                 context_store.add_thread(thread, cx);\n             });\n \n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -280,6 +280,7 @@\n \n         let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n         cx.spawn(|this, mut cx| async move {\n+            let thread = open_thread_task.await?;\n             context_store.update(&mut cx, |context_store, cx| {\n                 context_store.add_thread(thread, cx);\n             });\n\n```\n\nUser edited \"crates/assistant2/src/context_picker.rs\":\n```diff\n@@ -286,6 +286,8 @@\n             });\n \n             cx.notify();\n+            \n+            anyhow:\n         })\n     }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/assistant2/src/context_picker.rs\n        });\n\n        cx.spawn(|_, mut cx| async move { task.await.notify_async_err(&mut cx) })\n            .detach();\n\n        cx.notify();\n    }\n\n    fn add_recent_thread(\n        &self,\n        thread: ThreadContextEntry,\n        cx: &mut ViewContext<Self>,\n    ) -> Task<Result<()>> {\n        let Some(context_store) = self.context_store.upgrade() else {\n            return Task::ready(Err(anyhow!(\"context store not available\")));\n        };\n\n        let Some(thread_store) = self\n<|editable_region_start|>\n            .thread_store\n            .and_then(|thread_store| thread_store.upgrade())\n        else {\n            return Task::ready(Err(anyhow!(\"thread store not available\")));\n        };\n\n        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n        cx.spawn(|this, mut cx| async move {\n            let thread = open_thread_task.await?;\n            context_store.update(&mut cx, |context_store, cx| {\n                context_store.add_thread(thread, cx);\n            });\n\n            cx.notify();\n            \n            anyhow:<|user_cursor_is_here|>\n        })\n    }\n\n    fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {\n        let Some(workspace) = self.workspace.upgrade().map(|w| w.read(cx)) else {\n            return vec![];\n        };\n\n        let Some(context_store) = self.context_store.upgrade().map(|cs| cs.read(cx)) else {\n            return vec![];\n        };\n\n        let mut recent = Vec::with_capacity(6);\n\n        let mut current_files = context_store.file_paths(cx);\n\n        if let Some(active_path) = Self::active_singleton_buffer_path(&workspace, cx) {\n            current_files.insert(active_path);\n        }\n\n        let project = workspace.project().read(cx);\n\n        recent.extend(\n            workspace\n<|editable_region_end|>\n                .recent_navigation_history_iter(cx)\n                .filter(|(path, _)| !current_files.contains(&path.path.to_path_buf()))\n                .take(4)\n                .filter_map(|(project_path, _)| {\n                    project\n                        .worktree_for_id(project_path.worktree_id, cx)\n                        .map(|worktree| RecentEntry::File {\n                            project_path,\n                            path_prefix: worktree.read(cx).root_name().into(),\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/assistant2/src/context_picker.rs\n        });\n\n        cx.spawn(|_, mut cx| async move { task.await.notify_async_err(&mut cx) })\n            .detach();\n\n        cx.notify();\n    }\n\n    fn add_recent_thread(\n        &self,\n        thread: ThreadContextEntry,\n        cx: &mut ViewContext<Self>,\n    ) -> Task<Result<()>> {\n        let Some(context_store) = self.context_store.upgrade() else {\n            return Task::ready(Err(anyhow!(\"context store not available\")));\n        };\n\n        let Some(thread_store) = self\n<|editable_region_start|>\n            .thread_store\n            .and_then(|thread_store| thread_store.upgrade())\n        else {\n            return Task::ready(Err(anyhow!(\"thread store not available\")));\n        };\n\n        let open_thread_task = thread_store.update(cx, |this, cx| this.open_thread(&thread.id, cx));\n        cx.spawn(|this, mut cx| async move {\n            let thread = open_thread_task.await?;\n            context_store.update(&mut cx, |context_store, cx| {\n                context_store.add_thread(thread, cx);\n            });\n\n            cx.notify();\n            \n            anyhow::Ok(())\n        })\n    }\n\n    fn recent_entries(&self, cx: &mut WindowContext) -> Vec<RecentEntry> {\n        let Some(workspace) = self.workspace.upgrade().map(|w| w.read(cx)) else {\n            return vec![];\n        };\n\n        let Some(context_store) = self.context_store.upgrade().map(|cs| cs.read(cx)) else {\n            return vec![];\n        };\n\n        let mut recent = Vec::with_capacity(6);\n\n        let mut current_files = context_store.file_paths(cx);\n\n        if let Some(active_path) = Self::active_singleton_buffer_path(&workspace, cx) {\n            current_files.insert(active_path);\n        }\n\n        let project = workspace.project().read(cx);\n\n        recent.extend(\n            workspace\n<|editable_region_end|>\n                .recent_navigation_history_iter(cx)\n                .filter(|(path, _)| !current_files.contains(&path.path.to_path_buf()))\n                .take(4)\n                .filter_map(|(project_path, _)| {\n                    project\n                        .worktree_for_id(project_path.worktree_id, cx)\n                        .map(|worktree| RecentEntry::File {\n                            project_path,\n                            path_prefix: worktree.read(cx).root_name().into(),\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/worktree/src/worktree_tests.rs\":\n```diff\n@@ -3386,6 +3386,8 @@\n     fn gen_content(rng: &mut StdRng) -> String {\n         todo!()\n     }\n+    \n+    fn f\n \n     fn find_staged_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n         repo.status(&[\"\".into()])\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/worktree/src/worktree_tests.rs\n                fake_fs\n                    .atomic_write(path, content)\n                    .await\n                    .expect(\"Failed to write fake path\");\n                real_fs\n                    .atomic_write(path, content)\n                    .await\n                    .expect(\"Failed to write real path\");\n            }\n            5 => {\n                fake_repo.commit(\"message\").expect(\"Failed to fake commit\");\n                real_repo.commit(\"message\").expect(\"Failed to real commit\");\n            }\n            _ => unreachable!(),\n        }\n        check(&fake_repo, &real_repo);\n        i += 1;\n    }\n\n    fn check(fake: &Arc<dyn GitRepository>, real: &Arc<dyn GitRepository>) {\n        let fake_status = fake\n            .status(&[\"\".into()])\n            .expect(\"Failed to get fake status\");\n        let real_status = real\n<|editable_region_start|>\n            .status(&[\"\".into()])\n            .expect(\"Failed to get real status\");\n        assert_eq!(fake_status.entries, real_status.entries);\n    }\n\n    fn gen_content(rng: &mut StdRng) -> String {\n        todo!()\n    }\n    \n    fn f<|user_cursor_is_here|>\n\n    fn find_staged_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n        repo.status(&[\"\".into()])\n            .expect(\"Failed to get status\")\n            .entries\n            .iter()\n            .filter(|(_, status)| {\n                matches!(\n                    status,\n                    FileStatus::Tracked(TrackedStatus {\n                        index_status: StatusCode::Added\n                            | StatusCode::Modified\n                            | StatusCode::Deleted,\n                        ..\n                    })\n                )\n<|editable_region_end|>\n            })\n            .map(|(path, _)| path.clone())\n            .choose(rng)\n    }\n\n    fn find_modified_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n        repo.status(&[\"\".into()])\n            .expect(\"Failed to get status\")\n            .entries\n            .iter()\n            .filter(|(_, status)| {\n                matches!(\n                    status,\n                    FileStatus::Tracked(TrackedStatus {\n                        worktree_status: StatusCode::Added\n                            | StatusCode::Modified\n                            | StatusCode::Deleted,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/worktree/src/worktree_tests.rs\n                fake_fs\n                    .atomic_write(path, content)\n                    .await\n                    .expect(\"Failed to write fake path\");\n                real_fs\n                    .atomic_write(path, content)\n                    .await\n                    .expect(\"Failed to write real path\");\n            }\n            5 => {\n                fake_repo.commit(\"message\").expect(\"Failed to fake commit\");\n                real_repo.commit(\"message\").expect(\"Failed to real commit\");\n            }\n            _ => unreachable!(),\n        }\n        check(&fake_repo, &real_repo);\n        i += 1;\n    }\n\n    fn check(fake: &Arc<dyn GitRepository>, real: &Arc<dyn GitRepository>) {\n        let fake_status = fake\n            .status(&[\"\".into()])\n            .expect(\"Failed to get fake status\");\n        let real_status = real\n<|editable_region_start|>\n            .status(&[\"\".into()])\n            .expect(\"Failed to get real status\");\n        assert_eq!(fake_status.entries, real_status.entries);\n    }\n\n    fn gen_content(rng: &mut StdRng) -> String {\n        todo!()\n    }\n    \n    fn find_unstaged_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n        repo.status(&[\"\".into()])\n            .expect(\"Failed to get status\")\n            .entries\n            .iter()\n            .filter(|(_, status)| {\n                matches!(\n                    status,\n                    FileStatus::Tracked(TrackedStatus {\n                        index_status: StatusCode::Unstaged,\n                        ..\n                    })\n                )\n            })\n            .map(|(path, _)| path.clone())\n            .choose(rng)\n    }\n\n    fn find_staged_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n        repo.status(&[\"\".into()])\n            .expect(\"Failed to get status\")\n            .entries\n            .iter()\n            .filter(|(_, status)| {\n                matches!(\n                    status,\n                    FileStatus::Tracked(TrackedStatus {\n                        index_status: StatusCode::Added\n                            | StatusCode::Modified\n                            | StatusCode::Deleted,\n                        ..\n                    })\n                )\n<|editable_region_end|>\n            })\n            .map(|(path, _)| path.clone())\n            .choose(rng)\n    }\n\n    fn find_modified_path(repo: &Arc<dyn GitRepository>, rng: &mut StdRng) -> Option<RepoPath> {\n        repo.status(&[\"\".into()])\n            .expect(\"Failed to get status\")\n            .entries\n            .iter()\n            .filter(|(_, status)| {\n                matches!(\n                    status,\n                    FileStatus::Tracked(TrackedStatus {\n                        worktree_status: StatusCode::Added\n                            | StatusCode::Modified\n                            | StatusCode::Deleted,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8803,6 +8803,7 @@\n \n     label.runs.retain_mut(|(range, _)| {\n         let new_start = offset_map.get(range.start);\n+        lk\n         true\n     });\n     for (range, _) in &mut label.runs {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/lsp_store.rs\n        match c {\n            '\\n' if last_char_was_space => {\n                newlines_removed = true;\n            }\n            '\\t' | ' ' if last_char_was_space => {}\n            '\\n' if !last_char_was_space => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n                newlines_removed = true;\n            }\n            ' ' | '\\t' => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n            }\n            _ => {\n                new_text.push(c);\n                new_idx += 1;\n                last_char_was_space = false;\n            }\n        }\n    }\n    offset_map[label.text.len()] = new_idx;\n\n    // Only modify the label if newlines were removed.\n    if !newlines_removed {\n<|editable_region_start|>\n        return;\n    }\n\n    label.runs.retain_mut(|(range, _)| {\n        let new_start = offset_map.get(range.start);\n        lk\n        true\n    });\n    for (range, _) in &mut label.runs {\n        range.start = offset_map[range.start];\n        range.end = offset_map[range.end];\n    }\n\n    if label.filter_range == (0..label.text.len()) {\n        label.filter_range = 0..new_text.len();\n    } else {\n        label.filter_range.start = offset_map[label.filter_range.start];\n        label.filter_range.end = offset_map[label.filter_range.end];\n    }\n\n<|user_cursor_is_here|>    label.text = new_text;\n}\n\n<|editable_region_end|>\n#[cfg(test)]\n#[test]\nfn test_glob_literal_prefix() {\n    assert_eq!(glob_literal_prefix(Path::new(\"**/*.js\")), Path::new(\"\"));\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"node_modules/**/*.js\")),\n        Path::new(\"node_modules\")\n    );\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"foo/{bar,baz}.js\")),\n        Path::new(\"foo\")\n    );\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"foo/bar/baz.js\")),\n        Path::new(\"foo/bar/baz.js\")\n    );\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/lsp_store.rs\n        match c {\n            '\\n' if last_char_was_space => {\n                newlines_removed = true;\n            }\n            '\\t' | ' ' if last_char_was_space => {}\n            '\\n' if !last_char_was_space => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n                newlines_removed = true;\n            }\n            ' ' | '\\t' => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n            }\n            _ => {\n                new_text.push(c);\n                new_idx += 1;\n                last_char_was_space = false;\n            }\n        }\n    }\n    offset_map[label.text.len()] = new_idx;\n\n    // Only modify the label if newlines were removed.\n    if !newlines_removed {\n<|editable_region_start|>\n        return;\n    }\n\n    label.runs.retain_mut(|(range, _)| {\n        let new_start = offset_map.get(range.start);\n        let new_end = offset_map.get(range.end);\n        if let (Some(new_start), Some(new_end)) = (new_start, new_end) {\n            *range = (*new_start..*new_end);\n        }\n        true\n    });\n    for (range, _) in &mut label.runs {\n        range.start = offset_map[range.start];\n        range.end = offset_map[range.end];\n    }\n\n    if label.filter_range == (0..label.text.len()) {\n        label.filter_range = 0..new_text.len();\n    } else {\n        label.filter_range.start = offset_map[label.filter_range.start];\n        label.filter_range.end = offset_map[label.filter_range.end];\n    }\n\n    label.text = new_text;\n}\n\n<|editable_region_end|>\n#[cfg(test)]\n#[test]\nfn test_glob_literal_prefix() {\n    assert_eq!(glob_literal_prefix(Path::new(\"**/*.js\")), Path::new(\"\"));\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"node_modules/**/*.js\")),\n        Path::new(\"node_modules\")\n    );\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"foo/{bar,baz}.js\")),\n        Path::new(\"foo\")\n    );\n    assert_eq!(\n        glob_literal_prefix(Path::new(\"foo/bar/baz.js\")),\n        Path::new(\"foo/bar/baz.js\")\n    );\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -606,7 +606,7 @@\n         );\n         let diff_5 = BufferDiff::build(&base_text, &buffer);\n         let range = diff_5.compare(&diff_4, &buffer).unwrap();\n-        assert_eq!(range.start.to_point(&buffer), Point::new(3, 0));\n+        assert_eq!(range.start.to_point(&buffer), Point::new(8, 0));\n         assert_eq!(range.end.to_point(&buffer), Point::new(4, 0));\n     }\n }\n\n```\n\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -607,6 +607,6 @@\n         let diff_5 = BufferDiff::build(&base_text, &buffer);\n         let range = diff_5.compare(&diff_4, &buffer).unwrap();\n         assert_eq!(range.start.to_point(&buffer), Point::new(8, 0));\n-        assert_eq!(range.end.to_point(&buffer), Point::new(4, 0));\n+        assert_eq!(range.end.to_point(&buffer), Point::new(9, 0));\n     }\n }\n\n```\n\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -604,7 +604,7 @@\n             \"\n             .unindent(),\n         );\n-        let diff_5 = BufferDiff::build(&base_text, &buffer);\n+        let diff_6 = BufferDiff::build(&base_text, &buffer);\n         let range = diff_5.compare(&diff_4, &buffer).unwrap();\n         assert_eq!(range.start.to_point(&buffer), Point::new(8, 0));\n         assert_eq!(range.end.to_point(&buffer), Point::new(9, 0));\n\n```\n\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -605,7 +605,7 @@\n             .unindent(),\n         );\n         let diff_6 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_5.compare(&diff_4, &buffer).unwrap();\n+        let range = diff_6.compare(&diff_4, &buffer).unwrap();\n         assert_eq!(range.start.to_point(&buffer), Point::new(8, 0));\n         assert_eq!(range.end.to_point(&buffer), Point::new(9, 0));\n     }\n\n```\n\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -605,7 +605,7 @@\n             .unindent(),\n         );\n         let diff_6 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_6.compare(&diff_4, &buffer).unwrap();\n+        let range = diff_6.compare(&diff_5, &buffer).unwrap();\n         assert_eq!(range.start.to_point(&buffer), Point::new(8, 0));\n         assert_eq!(range.end.to_point(&buffer), Point::new(9, 0));\n     }\n\n```\n\nUser edited \"crates/git/Cargo.toml\":\n```diff\n@@ -35,6 +35,8 @@\n unindent.workspace = true\n serde_json.workspace = true\n pretty_assertions.workspace = true\n+text.\n+test\n \n [features]\n test-support = []\n\n```\n\nUser edited \"crates/git/Cargo.toml\":\n```diff\n@@ -35,8 +35,7 @@\n unindent.workspace = true\n serde_json.workspace = true\n pretty_assertions.workspace = true\n-text.\n-test\n+te\n \n [features]\n test-support = []\n\n```\n\nUser edited \"crates/git/Cargo.toml\":\n```diff\n@@ -35,7 +35,7 @@\n unindent.workspace = true\n serde_json.workspace = true\n pretty_assertions.workspace = true\n-te\n+tex\n \n [features]\n test-support = []\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/git/Cargo.toml\n<|start_of_file|>\n[package]\nname = \"git\"\nversion = \"0.1.0\"\nedition.workspace = true\npublish.workspace = true\n<|editable_region_start|>\nlicense = \"GPL-3.0-or-later\"\n\n[lints]\nworkspace = true\n\n[lib]\npath = \"src/git.rs\"\n\n[dependencies]\nanyhow.workspace = true\nasync-trait.workspace = true\ncollections.workspace = true\nderive_more.workspace = true\ngit2.workspace = true\ngpui.workspace = true\nhttp_client.workspace = true\nlog.workspace = true\nparking_lot.workspace = true\nregex.workspace = true\nrope.workspace = true\nserde.workspace = true\nsmol.workspace = true\nsum_tree.workspace = true\ntext.workspace = true\ntime.workspace = true\nurl.workspace = true\nutil.workspace = true\n\n[dev-dependencies]\nunindent.workspace = true\nserde_json.workspace = true\npretty_assertions.workspace = true\ntex<|user_cursor_is_here|>\n\n[features]\ntest-support = []\n<|editable_region_end|>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/git/Cargo.toml\n<|start_of_file|>\n[package]\nname = \"git\"\nversion = \"0.1.0\"\nedition.workspace = true\npublish.workspace = true\n<|editable_region_start|>\nlicense = \"GPL-3.0-or-later\"\n\n[lints]\nworkspace = true\n\n[lib]\npath = \"src/git.rs\"\n\n[dependencies]\nanyhow.workspace = true\nasync-trait.workspace = true\ncollections.workspace = true\nderive_more.workspace = true\ngit2.workspace = true\ngpui.workspace = true\nhttp_client.workspace = true\nlog.workspace = true\nparking_lot.workspace = true\nregex.workspace = true\nrope.workspace = true\nserde.workspace = true\nsmol.workspace = true\nsum_tree.workspace = true\ntext.workspace = true\ntime.workspace = true\nurl.workspace = true\nutil.workspace = true\n\n[dev-dependencies]\nunindent.workspace = true\nserde_json.workspace = true\npretty_assertions.workspace = true\ntext.workspace = true\n\n[features]\ntest-support = []\n<|editable_region_end|>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"untitled\":\n```diff\n@@ -4,7 +4,7 @@\n - Issue Types\n   - I would like for the user to be able to select the priority level (high or low), so we can skip more things\n     - Might require us to recategorize high priority issues into low priority ones\n-    - Any more than 2 categories of severity will be \n+    - Any more than 2 categories of severity will cause the user to th\n     \n   No more \"Admin Read\" or \"Triage\" - we can add extra context to bug reports that catch our eye when skimming the log\n   \n@@ -27,8 +27,7 @@\n \n GitHub Issues:\n - Types of GitHub Issues:\n-  - Crash / Panic Report:\n-    - Zed Crashed\n+  - Crash / Panic Report: **Zed Crashed\n     - [R\n     - [Required] What you were doing \n     - [Desired] Explicit Steps to reproduce the crash\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```untitled\n<|start_of_file|>\n## 2025 Issue/Request Framework\n\n<|editable_region_start|>\nThings to discuss\n- Issue Types\n  - I would like for the user to be able to select the priority level (high or low), so we can skip more things\n    - Might require us to recategorize high priority issues into low priority ones\n    - Any more than 2 categories of severity will cause the user to th<|user_cursor_is_here|>\n    \n  No more \"Admin Read\" or \"Triage\" - we can add extra context to bug reports that catch our eye when skimming the log\n  \n  Clearly define what should not be in issues, point them to the right place\n  \n  ---\n    \n  Issue Type: Bug\n  Label: High Priority\n  \n  Issue Type: Bug\n  Label: Low Priority\n  \nIssue templates\n-  Feature requests points to Discussions\n\nDiscussion templates:\n- Bugs and Issues\n- Config and Keymaps: Include a code block\n\nGitHub Issues:\n- Types of GitHub Issues:\n  - Crash / Panic Report: **Zed Crashed\n    - [R\n    - [Required] What you were doing \n    - [Desired] Explicit Steps to reproduce the crash\n    - Zed.log\n    - Panic backtrace or Apple Crash report\n    - \n  - Bug:\n    - A concise description of something which is broken in Zed\n    - Clear steps to reproduce including description of the broken behavior\n    - Explicit statement of the desired behavior\n<|editable_region_end|>\n  - Enhancement:\n    - A tightly scoped, improved to the Zed editor\n\n\n## Community member highlight posts\n\n- [ ] CharlesChen0823\n- [ ] Yaniel\n- [ ] Remco (debugger)\n- [ ] Anthony (debugger)\n- [ ] Weethet\n- [ ] @0x2CA\n- [ ] D1y (@chenhonzhou)\n\n# Community\n  \n#### Weekly notes checklist\n\n- [ ] In-app feedback AI summary\n- [ ] Email\n- [ ] Metrics\n- [ ] Twitter\n    - [ ] Release tweet\n- [ ] GitHub notifications\n- [ ] GitHub Issues\n- [ ] GitHub Discussions\n```"}, {"role": "assistant", "content": "Suggestion:\n```untitled\n<|start_of_file|>\n## 2025 Issue/Request Framework\n\n<|editable_region_start|>\nThings to discuss\n- Issue Types\n  - I would like for the user to be able to select the priority level (high or low), so we can skip more things\n    - Might require us to recategorize high priority issues into low priority ones\n    - Any more than 2 categories of severity will cause the user to think about the issue more deeply and potentially re-evaluate its importance.\n\n  No more \"Admin Read\" or \"Triage\" - we can add extra context to bug reports that catch our eye when skimming the log\n  \n  Clearly define what should not be in issues, point them to the right place\n  \n  ---\n    \n  Issue Type: Bug\n  Label: High Priority\n  \n  Issue Type: Bug\n  Label: Low Priority\n  \nIssue templates\n-  Feature requests points to Discussions\n\nDiscussion templates:\n- Bugs and Issues\n- Config and Keymaps: Include a code block\n\nGitHub Issues:\n- Types of GitHub Issues:\n  - Crash / Panic Report: **Zed Crashed\n    - [R\n    - [Required] What you were doing \n    - [Desired] Explicit Steps to reproduce the crash\n    - Zed.log\n    - Panic backtrace or Apple Crash report\n    - \n  - Bug:\n    - A concise description of something which is broken in Zed\n    - Clear steps to reproduce including description of the broken behavior\n    - Explicit statement of the desired behavior\n<|editable_region_end|>\n  - Enhancement:\n    - A tightly scoped, improved to the Zed editor\n\n\n## Community member highlight posts\n\n- [ ] CharlesChen0823\n- [ ] Yaniel\n- [ ] Remco (debugger)\n- [ ] Anthony (debugger)\n- [ ] Weethet\n- [ ] @0x2CA\n- [ ] D1y (@chenhonzhou)\n\n# Community\n  \n#### Weekly notes checklist\n\n- [ ] In-app feedback AI summary\n- [ ] Email\n- [ ] Metrics\n- [ ] Twitter\n    - [ ] Release tweet\n- [ ] GitHub notifications\n- [ ] GitHub Issues\n- [ ] GitHub Discussions\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1544,11 +1544,13 @@\n         buffer_snapshot: text::BufferSnapshot,\n         cx: &mut Context<Self>,\n     ) -> impl Iterator<Item = oneshot::Receiver<()>> {\n-        [&self.unstaged_diff, &self.uncommitted_diff].into_iter().map(|diff| {\n-            diff.update(cx, |diff, cx| {\n-                diff.recalculate_diff(buffer_snapshot, cx);\n+        [&self.unstaged_diff, &self.uncommitted_diff]\n+            .into_iter()\n+            .map(|diff| {\n+                diff.update(cx, |diff, cx| {\n+                    diff.recalculate_diff(buffer_snapshot.clone(), cx);\n+                })\n             })\n-        })\n     }\n \n     fn on_buffer_event(\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1539,20 +1539,6 @@\n         }\n     }\n \n-    fn recalculate_diffs(\n-        &mut self,\n-        buffer_snapshot: text::BufferSnapshot,\n-        cx: &mut Context<Self>,\n-    ) -> impl Iterator<Item = oneshot::Receiver<()>> {\n-        [&self.unstaged_diff, &self.uncommitted_diff]\n-            .into_iter()\n-            .map(|diff| {\n-                diff.update(cx, |diff, cx| {\n-                    diff.recalculate_diff(buffer_snapshot.clone(), cx);\n-                })\n-            })\n-    }\n-\n     fn on_buffer_event(\n         &mut self,\n         buffer: Entity<Buffer>,\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -2409,6 +2409,20 @@\n             language_registry: buffer.language_registry(),\n         }\n     }\n+    \n+        fn recalculate_diffs(\n+            &mut self,\n+            buffer_snapshot: text::BufferSnapshot,\n+            cx: &mut Context<Self>,\n+        ) -> impl Iterator<Item = oneshot::Receiver<()>> {\n+            [&self.unstaged_diff, &self.uncommitted_diff]\n+                .into_iter()\n+                .map(|diff| {\n+                    diff.update(cx, |diff, cx| {\n+                        diff.recalculate_diff(buffer_snapshot.clone(), cx);\n+                    })\n+                })\n+        }\n \n     #[cfg(any(test, feature = \"test-support\"))]\n     pub fn new_with_base_text(\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -2409,20 +2409,20 @@\n             language_registry: buffer.language_registry(),\n         }\n     }\n-    \n-        fn recalculate_diffs(\n-            &mut self,\n-            buffer_snapshot: text::BufferSnapshot,\n-            cx: &mut Context<Self>,\n-        ) -> impl Iterator<Item = oneshot::Receiver<()>> {\n-            [&self.unstaged_diff, &self.uncommitted_diff]\n-                .into_iter()\n-                .map(|diff| {\n-                    diff.update(cx, |diff, cx| {\n-                        diff.recalculate_diff(buffer_snapshot.clone(), cx);\n-                    })\n+\n+    fn recalculate_diffs(\n+        &mut self,\n+        buffer_snapshot: text::BufferSnapshot,\n+        cx: &mut Context<Self>,\n+    ) -> impl Iterator<Item = oneshot::Receiver<()>> {\n+        [&self.unstaged_diff, &self.uncommitted_diff]\n+            .into_iter()\n+            .map(|diff| {\n+                diff.update(cx, |diff, cx| {\n+                    diff.recalculate_diff(buffer_snapshot.clone(), cx);\n                 })\n-        }\n+            })\n+    }\n \n     #[cfg(any(test, feature = \"test-support\"))]\n     pub fn new_with_base_text(\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1526,8 +1526,8 @@\n             {\n                 if let Some(change_set) = change_set.as_ref().and_then(|changes| changes.upgrade())\n                 {\n-                    change_set.update(cx, |unstaged_changes, cx| {\n-                        futures.extend(unstaged_changes.recalculate_diffs(buffer.clone(), cx));\n+                    change_set.update(cx, |change_set, cx| {\n+                        futures.extend(change_set.recalculate_diffs(buffer.clone(), cx));\n                     });\n                 } else {\n                     unstaged_changes.take();\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1530,7 +1530,7 @@\n                         futures.extend(change_set.recalculate_diffs(buffer.clone(), cx));\n                     });\n                 } else {\n-                    unstaged_changes.take();\n+                    change_set.take();\n                 }\n             }\n         }\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1982,11 +1982,8 @@\n         let buffer_id = BufferId::new(request.payload.buffer_id)?;\n         let Some((buffer, unstaged_change_set, uncommitted_change_set)) =\n             this.update(&mut cx, |this, _| {\n-                if let OpenBuffer::Complete {\n-                    unstaged_changes,\n-                    uncommitted_changes,\n-                    buffer,\n-                } = this.opened_buffers.get(&buffer_id)?\n+                if let OpenBuffer::Complete { change_set, buffer } =\n+                    this.opened_buffers.get(&buffer_id)?\n                 {\n                     Some((\n                         buffer.upgrade()?,\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -1987,6 +1987,7 @@\n                 {\n                     Some((\n                         buffer.upgrade()?,\n+                        change_set.as\n                         unstaged_changes.as_ref()?.upgrade()?,\n                         uncommitted_changes.as_ref()?.upgrade()?,\n                     ))\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/buffer_store.rs\n                Some(this.open_unstaged_changes(buffer, cx))\n            })?\n            .ok_or_else(|| anyhow!(\"no such buffer\"))?\n            .await?;\n        this.update(&mut cx, |this, _| {\n            let shared_buffers = this\n                .shared_buffers\n                .entry(request.original_sender_id.unwrap_or(request.sender_id))\n                .or_default();\n            debug_assert!(shared_buffers.contains_key(&buffer_id));\n            if let Some(shared) = shared_buffers.get_mut(&buffer_id) {\n                shared.change_set = Some(change_set.clone());\n            }\n        })?;\n        let staged_text = change_set.read_with(&cx, |change_set, _| {\n            change_set.base_text.as_ref().map(|buffer| buffer.text())\n        })?;\n        Ok(proto::GetStagedTextResponse { staged_text })\n    }\n\n    pub async fn handle_update_diff_bases(\n<|editable_region_start|>\n        this: Entity<Self>,\n        request: TypedEnvelope<proto::UpdateDiffBases>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let buffer_id = BufferId::new(request.payload.buffer_id)?;\n        let Some((buffer, unstaged_change_set, uncommitted_change_set)) =\n            this.update(&mut cx, |this, _| {\n                if let OpenBuffer::Complete { change_set, buffer } =\n                    this.opened_buffers.get(&buffer_id)?\n                {\n                    Some((\n                        buffer.upgrade()?,\n                        change_set.as<|user_cursor_is_here|>\n                        unstaged_changes.as_ref()?.upgrade()?,\n                        uncommitted_changes.as_ref()?.upgrade()?,\n<|editable_region_end|>\n                    ))\n                } else {\n                    None\n                }\n            })?\n        else {\n            return Ok(());\n        };\n        unstaged_change_set.update(&mut cx, |unstaged_change_set, cx| {\n            if let Some(staged_text) = request.payload.staged_text {\n                let _ = unstaged_change_set.set_base_text(\n                    staged_text,\n                    buffer.read(cx).text_snapshot(),\n                    cx,\n                );\n            } else {\n                unstaged_change_set.unset_base_text(buffer.read(cx).text_snapshot(), cx)\n            }\n        })?;\n        uncommitted_change_set.update(&mut cx, |uncommitted_change_set, cx| {\n            if let Some(committed_text) = request.payload.committed_text {\n                let _ = uncommitted_change_set.set_base_text(\n                    committed_text,\n                    buffer.read(cx).text_snapshot(),\n                    cx,\n                );\n            } else {\n                uncommitted_change_set.unset_base_text(buffer.read(cx).text_snapshot(), cx)\n            }\n        })?;\n        Ok(())\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/buffer_store.rs\n                Some(this.open_unstaged_changes(buffer, cx))\n            })?\n            .ok_or_else(|| anyhow!(\"no such buffer\"))?\n            .await?;\n        this.update(&mut cx, |this, _| {\n            let shared_buffers = this\n                .shared_buffers\n                .entry(request.original_sender_id.unwrap_or(request.sender_id))\n                .or_default();\n            debug_assert!(shared_buffers.contains_key(&buffer_id));\n            if let Some(shared) = shared_buffers.get_mut(&buffer_id) {\n                shared.change_set = Some(change_set.clone());\n            }\n        })?;\n        let staged_text = change_set.read_with(&cx, |change_set, _| {\n            change_set.base_text.as_ref().map(|buffer| buffer.text())\n        })?;\n        Ok(proto::GetStagedTextResponse { staged_text })\n    }\n\n    pub async fn handle_update_diff_bases(\n<|editable_region_start|>\n        this: Entity<Self>,\n        request: TypedEnvelope<proto::UpdateDiffBases>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let buffer_id = BufferId::new(request.payload.buffer_id)?;\n        let Some((buffer, unstaged_change_set, uncommitted_change_set)) =\n            this.update(&mut cx, |this, _| {\n                if let OpenBuffer::Complete { change_set, buffer } =\n                    this.opened_buffers.get(&buffer_id)?\n                {\n                    Some((\n                        buffer.upgrade()?,\n                        change_set.as_ref()?.upgrade()?,\n                        unstaged_changes.as_ref()?.upgrade()?,\n                        uncommitted_changes.as_ref()?.upgrade()?,\n<|editable_region_end|>\n                    ))\n                } else {\n                    None\n                }\n            })?\n        else {\n            return Ok(());\n        };\n        unstaged_change_set.update(&mut cx, |unstaged_change_set, cx| {\n            if let Some(staged_text) = request.payload.staged_text {\n                let _ = unstaged_change_set.set_base_text(\n                    staged_text,\n                    buffer.read(cx).text_snapshot(),\n                    cx,\n                );\n            } else {\n                unstaged_change_set.unset_base_text(buffer.read(cx).text_snapshot(), cx)\n            }\n        })?;\n        uncommitted_change_set.update(&mut cx, |uncommitted_change_set, cx| {\n            if let Some(committed_text) = request.payload.committed_text {\n                let _ = uncommitted_change_set.set_base_text(\n                    committed_text,\n                    buffer.read(cx).text_snapshot(),\n                    cx,\n                );\n            } else {\n                uncommitted_change_set.unset_base_text(buffer.read(cx).text_snapshot(), cx)\n            }\n        })?;\n        Ok(())\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -1414,7 +1414,7 @@\n                 cx.observe_window_activation(window, |editor, window, cx| {\n                     let active = window.is_window_active();\n                     editor.blink_manager.update(cx, |blink_manager, cx| {\n-                        if active {\n+                        if true {\n                             blink_manager.enable(cx);\n                         } else {\n                             blink_manager.disable(cx);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/title_bar/src/title_bar.rs\n                                menu.navigate_menus_in_direction(action, window, cx)\n                            });\n                        }\n                    });\n                }\n            },\n        );\n    })\n    .detach();\n}\n\npub struct TitleBar {\n    platform_style: PlatformStyle,\n    content: Stateful<Div>,\n    children: SmallVec<[AnyElement; 2]>,\n    repository_selector: Entity<RepositorySelector>,\n    project: Entity<Project>,\n    user_store: Entity<UserStore>,\n    client: Arc<Client>,\n    workspace: WeakEntity<Workspace>,\n    should_move: bool,\n    application_menu: Option<Entity<ApplicationMenu>>,\n    _subscriptions: Vec<Subscription>,\n    git_ui_enabled: Arc<AtomicBool>,\n}\n\nimpl Render for TitleBar {\n<|editable_region_start|>\n    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let close_action = Box::new(workspace::CloseWindow);\n        let height = Self::height(window);\n        let supported_controls = window.window_controls();\n        let decorations = window.window_decorations();\n        let titlebar_color = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n            if window.is_window_active() && !self.should_move {\n                cx.theme().colors().title_bar_background\n            } else {\n                cx.theme().colors().title_bar_inactive_background\n            }\n        } else {\n            cx.theme().colors().title_bar_background\n        };\n\n        h_flex()\n            .id(\"titlebar\")\n            .w_full()\n            .h(height)\n            .map(|this| {\n                if window.is_fullscreen() {\n                    this.pl_2()\n                } else if self.platform_style == PlatformStyle::Mac {\n                    this.pl(px(platform_mac::TRAFFIC_LIGHT_PADDING))\n    <|user_cursor_is_here|>            } else {\n                    this.pl_2()\n                }\n            })\n            .map(|el| match decorations {\n                Decorations::Server => el,\n                Decorations::Client { tiling, .. } => el\n                    .when(!(tiling.top || tiling.right), |el| {\n<|editable_region_end|>\n                        el.rounded_tr(theme::CLIENT_SIDE_DECORATION_ROUNDING)\n                    })\n                    .when(!(tiling.top || tiling.left), |el| {\n                        el.rounded_tl(theme::CLIENT_SIDE_DECORATION_ROUNDING)\n                    })\n                    // this border is to avoid a transparent gap in the rounded corners\n                    .mt(px(-1.))\n                    .border(px(1.))\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/title_bar/src/title_bar.rs\n                                menu.navigate_menus_in_direction(action, window, cx)\n                            });\n                        }\n                    });\n                }\n            },\n        );\n    })\n    .detach();\n}\n\npub struct TitleBar {\n    platform_style: PlatformStyle,\n    content: Stateful<Div>,\n    children: SmallVec<[AnyElement; 2]>,\n    repository_selector: Entity<RepositorySelector>,\n    project: Entity<Project>,\n    user_store: Entity<UserStore>,\n    client: Arc<Client>,\n    workspace: WeakEntity<Workspace>,\n    should_move: bool,\n    application_menu: Option<Entity<ApplicationMenu>>,\n    _subscriptions: Vec<Subscription>,\n    git_ui_enabled: Arc<AtomicBool>,\n}\n\nimpl Render for TitleBar {\n<|editable_region_start|>\n    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let close_action = Box::new(workspace::CloseWindow);\n        let height = Self::height(window);\n        let supported_controls = window.window_controls();\n        let decorations = window.window_decorations();\n        let titlebar_color = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n            if window.is_window_active() && !self.should_move {\n                cx.theme().colors().title_bar_background\n            } else {\n                cx.theme().colors().title_bar_inactive_background\n            }\n        } else {\n            cx.theme().colors().title_bar_background\n        };\n\n        h_flex()\n            .id(\"titlebar\")\n            .w_full()\n            .h(height)\n            .map(|this| {\n                if window.is_fullscreen() {\n                    this.pl_2()\n                } else if self.platform_style == PlatformStyle::Mac {\n                    this.pl(px(platform_mac::TRAFFIC_LIGHT_PADDING))\n                } else {\n                    this.pl_2()\n                }\n            })\n            .map(|el| match decorations {\n                Decorations::Server => el,\n                Decorations::Client { tiling, .. } => el\n                    .when(!(tiling.top || tiling.right), |el| {\n<|editable_region_end|>\n                        el.rounded_tr(theme::CLIENT_SIDE_DECORATION_ROUNDING)\n                    })\n                    .when(!(tiling.top || tiling.left), |el| {\n                        el.rounded_tl(theme::CLIENT_SIDE_DECORATION_ROUNDING)\n                    })\n                    // this border is to avoid a transparent gap in the rounded corners\n                    .mt(px(-1.))\n                    .border(px(1.))\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -429,7 +429,7 @@\n             } else {\n                 \"Show Edit Predictions for all files\"\n             },\n-            globll\n+            globally_enabled\n             None,\n             move |_, cx| toggle_inline_completions_globally(fs.clone(), cx),\n         )\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/inline_completion_button/src/inline_completion_button.rs\n            let path = file.path().clone();\n            let path_enabled = settings.inline_completions_enabled_for_path(&path);\n\n            menu = menu.entry(\n                format!(\n                    \"{} Edit Predictions for This Path\",\n                    if path_enabled { \"Hide\" } else { \"Show\" }\n                ),\n                None,\n                move |window, cx| {\n                    if let Some(workspace) = window.root().flatten() {\n                        let workspace = workspace.downgrade();\n                        window\n                            .spawn(cx, |cx| {\n                                configure_disabled_globs(\n                                    workspace,\n                                    path_enabled.then_some(path.clone()),\n                                    cx,\n                                )\n                            })\n                            .detach_and_log_err(cx);\n                    }\n                },\n            );\n        }\n\n        let globally_enabled = settings.inline_completions_enabled(None, None, cx);\n<|editable_region_start|>\n        menu.toggleable_entry(\n            if globally_enabled {\n                \"Hide Edit Predictions for all files\"\n            } else {\n                \"Show Edit Predictions for all files\"\n            },\n            globally_enabled\n            None,\n            move |_, cx| toggle_inline_completions_globally(fs.clone(), cx),\n        )\n    }\n\n    fn build_copilot_context_menu(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, _, cx| {\n            self.build_language_settings_menu(menu, cx)\n                .separator()\n                .link(\n                    \"Go to Copilot Settings\",\n                    OpenBrowser {\n                        url: COPILOT_SETTINGS_URL.to_string(),\n    <|user_cursor_is_here|>                }\n                    .boxed_clone(),\n                )\n                .action(\"Sign Out\", copilot::SignOut.boxed_clone())\n        })\n    }\n\n    fn build_supermaven_context_menu(\n<|editable_region_end|>\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, _, cx| {\n            self.build_language_settings_menu(menu, cx)\n                .separator()\n                .action(\"Sign Out\", supermaven::SignOut.boxed_clone())\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/inline_completion_button/src/inline_completion_button.rs\n            let path = file.path().clone();\n            let path_enabled = settings.inline_completions_enabled_for_path(&path);\n\n            menu = menu.entry(\n                format!(\n                    \"{} Edit Predictions for This Path\",\n                    if path_enabled { \"Hide\" } else { \"Show\" }\n                ),\n                None,\n                move |window, cx| {\n                    if let Some(workspace) = window.root().flatten() {\n                        let workspace = workspace.downgrade();\n                        window\n                            .spawn(cx, |cx| {\n                                configure_disabled_globs(\n                                    workspace,\n                                    path_enabled.then_some(path.clone()),\n                                    cx,\n                                )\n                            })\n                            .detach_and_log_err(cx);\n                    }\n                },\n            );\n        }\n\n        let globally_enabled = settings.inline_completions_enabled(None, None, cx);\n<|editable_region_start|>\n        menu.toggleable_entry(\n            if globally_enabled {\n                \"Hide Edit Predictions for all files\"\n            } else {\n                \"Show Edit Predictions for all files\"\n            },\n            globally_enabled,\n            None,\n            move |_, cx| toggle_inline_completions_globally(fs.clone(), cx),\n        )\n    }\n\n    fn build_copilot_context_menu(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, _, cx| {\n            self.build_language_settings_menu(menu, cx)\n                .separator()\n                .link(\n                    \"Go to Copilot Settings\",\n                    OpenBrowser {\n                        url: COPILOT_SETTINGS_URL.to_string(),\n                    }\n                    .boxed_clone(),\n                )\n                .action(\"Sign Out\", copilot::SignOut.boxed_clone())\n        })\n    }\n\n    fn build_supermaven_context_menu(\n<|editable_region_end|>\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, _, cx| {\n            self.build_language_settings_menu(menu, cx)\n                .separator()\n                .action(\"Sign Out\", supermaven::SignOut.boxed_clone())\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -1310,7 +1310,7 @@\n                             })\n                         .with_secondary_click_message(\"No\")\n                         .on_secondary_click(move |_window, cx| {\n-                            \n+                            let \n                             zeta.update(cx, |zeta, cx| {\n                                 zeta.set_worktree_data_collection_choice(\n                                     worktree_id,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/zeta.rs\n            || zeta\n                .data_collection_options\n                .worktree_choices\n                .contains_key(&worktree_id)\n        {\n            return;\n        }\n\n        struct ZetaDataCollectionNotification;\n\n        let notification_id = NotificationId::unique::<ZetaDataCollectionNotification>();\n\n        self.workspace\n            .update(cx, |workspace, cx| {\n                workspace.show_notification(notification_id, cx, |cx| {\n                    let zeta = self.zeta.clone();\n                    cx.new(move |_cx| {\n                        MessageNotification::new(\"hi\")\n                            .with_click_message(\"Yes\")\n                            .on_click({\n                                let zeta = zeta.clone();\n                                move |_window, cx| {\n                                    zeta.update(cx, |zeta, cx| {\n                                        zeta.set_worktree_data_collection_choice(\n                                            worktree_id,\n                                            true,\n                                            cx,\n                                        )\n                                    });\n                                }\n                            })\n                        .with_secondary_click_message(\"No\")\n                        .on_secondary_click(move |_window, cx| {\n                            let \n                            zeta.update(cx, |zeta, cx| {\n                                zeta.set_worktree_data_collection_choice(\n                                    worktree_id,\n                                    false,\n                                    cx,\n                                );\n                            });\n<|editable_region_start|>\n                        })\n                        .with_tertiary_click_message(\"Don't show me this anymor\")\n                        .on_tertiary_click(move |_window, cx| {\n                            zeta.update(cx, |zeta, cx| {\n                                zeta.set_data_collection_do_not_ask_again(cx);\n                            });\n                        })\n                    })\n                });\n            })\n  <|user_cursor_is_here|>          .log_err();\n    }\n\n    fn discard(&mut self, _cx: &mut Context<Self>) {\n        self.pending_completions.clear();\n<|editable_region_end|>\n        self.current_completion.take();\n    }\n\n    fn suggest(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cursor_position: language::Anchor,\n        cx: &mut Context<Self>,\n    ) -> Option<inline_completion::InlineCompletion> {\n        let CurrentInlineCompletion {\n            buffer_id,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/zeta.rs\n            || zeta\n                .data_collection_options\n                .worktree_choices\n                .contains_key(&worktree_id)\n        {\n            return;\n        }\n\n        struct ZetaDataCollectionNotification;\n\n        let notification_id = NotificationId::unique::<ZetaDataCollectionNotification>();\n\n        self.workspace\n            .update(cx, |workspace, cx| {\n                workspace.show_notification(notification_id, cx, |cx| {\n                    let zeta = self.zeta.clone();\n                    cx.new(move |_cx| {\n                        MessageNotification::new(\"hi\")\n                            .with_click_message(\"Yes\")\n                            .on_click({\n                                let zeta = zeta.clone();\n                                move |_window, cx| {\n                                    zeta.update(cx, |zeta, cx| {\n                                        zeta.set_worktree_data_collection_choice(\n                                            worktree_id,\n                                            true,\n                                            cx,\n                                        )\n                                    });\n                                }\n                            })\n                        .with_secondary_click_message(\"No\")\n                        .on_secondary_click(move |_window, cx| {\n                            let \n                            zeta.update(cx, |zeta, cx| {\n                                zeta.set_worktree_data_collection_choice(\n                                    worktree_id,\n                                    false,\n                                    cx,\n                                );\n                            });\n<|editable_region_start|>\n                        })\n                        .with_tertiary_click_message(\"Don't show me this anymor\")\n                        .on_tertiary_click(move |_window, cx| {\n                            zeta.update(cx, |zeta, cx| {\n                                zeta.set_data_collection_do_not_ask_again(cx);\n                            });\n                        })\n                    })\n                });\n            })\n            .log_err();\n    }\n\n    fn discard(&mut self, _cx: &mut Context<Self>) {\n        self.pending_completions.clear();\n<|editable_region_end|>\n        self.current_completion.take();\n    }\n\n    fn suggest(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cursor_position: language::Anchor,\n        cx: &mut Context<Self>,\n    ) -> Option<inline_completion::InlineCompletion> {\n        let CurrentInlineCompletion {\n            buffer_id,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1462,7 +1462,7 @@\n         self.config\n             .code_fence_block_name\n             .clone()\n-            .unwrap_or_else(|| self.config.name.0.to_lowercase().into())\n+            .unwrap_or_else(|| self.config.name.as_ref().to_lowercase().into())\n     }\n \n     pub fn context_provider(&self) -> Option<Arc<dyn ContextProvider>> {\n\n```\n\nUser edited \"crates/language/src/language_registry.rs\":\n```diff\n@@ -669,7 +669,7 @@\n                 .iter()\n                 .any(|suffix| path_suffixes.contains(&Some(suffix.as_str())));\n             let custom_suffixes = user_file_types\n-                .and_then(|types| types.get(&language_name.0))\n+                .and_then(|types| types.get(language_name.as_ref()))\n                 .unwrap_or(&empty);\n             let path_matches_custom_suffix = path_suffixes\n                 .iter()\n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -2579,7 +2579,7 @@\n         language_name: LanguageName,\n     ) -> Option<SharedString> {\n         languages\n-            .language_for_name(&language_name.0)\n+            .language_for_name(&language_name)\n             .await\n             .ok()?\n             .toolchain_lister()\n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -2579,7 +2579,7 @@\n         language_name: LanguageName,\n     ) -> Option<SharedString> {\n         languages\n-            .language_for_name(&language_name)\n+            .language_for_name(language_name.as_ref())\n             .await\n             .ok()?\n             .toolchain_lister()\n\n```\n\nUser edited \"crates/project/src/task_inventory.rs\":\n```diff\n@@ -53,7 +53,7 @@\n         abs_path: PathBuf,\n     },\n     /// Languages-specific tasks coming from extensions.\n-    Language { name: Arc<str> },\n+    Language { name: SharedString },\n }\n \n impl TaskSourceKind {\n\n```\n\nUser edited \"crates/project/src/task_inventory.rs\":\n```diff\n@@ -91,7 +91,7 @@\n         cx: &App,\n     ) -> Vec<(TaskSourceKind, TaskTemplate)> {\n         let task_source_kind = language.as_ref().map(|language| TaskSourceKind::Language {\n-            name: language.name().0,\n+            name: language.name().into(),\n         });\n         let global_tasks = self.global_templates_from_settings();\n         let language_tasks = language\n\n```\n\nUser edited \"crates/project/src/task_inventory.rs\":\n```diff\n@@ -124,7 +124,7 @@\n             .as_ref()\n             .and_then(|location| location.buffer.read(cx).language_at(location.range.start));\n         let task_source_kind = language.as_ref().map(|language| TaskSourceKind::Language {\n-            name: language.name().0,\n+            name: language.name().into(),\n         });\n         let file = location\n             .as_ref()\n\n```\n\nUser edited \"crates/project/src/task_inventory.rs\":\n```diff\n@@ -10,7 +10,7 @@\n \n use anyhow::{Context as _, Result};\n use collections::{HashMap, HashSet, VecDeque};\n-use gpui::{App, AppContext as _, Entity, Task};\n+use gpui::{App, AppContext as _, Entity, SharedString, Task};\n use itertools::Itertools;\n use language::{ContextProvider, File, Language, LanguageToolchainStore, Location};\n use settings::{parse_json_with_comments, SettingsLocation};\n\n```\n\nUser edited \"crates/project/src/toolchain_store.rs\":\n```diff\n@@ -316,7 +316,7 @@\n \n             cx.background_executor()\n                 .spawn(async move {\n-                    let language = registry.language_for_name(&language_name.).await.ok()?;\n+                    let language = registry.language_for_name(&language_name.as_ref()).await.ok()?;\n                     let toolchains = language.toolchain_lister()?;\n                     Some(toolchains.list(root.to_path_buf(), project_env).await)\n                 })\n\n```\n\nUser edited \"crates/project/src/toolchain_store.rs\":\n```diff\n@@ -316,7 +316,10 @@\n \n             cx.background_executor()\n                 .spawn(async move {\n-                    let language = registry.language_for_name(&language_name.as_ref()).await.ok()?;\n+                    let language = registry\n+                        .language_for_name(language_name.as_ref())\n+                        .await\n+                        .ok()?;\n                     let toolchains = language.toolchain_lister()?;\n                     Some(toolchains.list(root.to_path_buf(), project_env).await)\n                 })\n\n```\n\nUser edited \"crates/workspace/src/persistence.rs\":\n```diff\n@@ -1088,7 +1088,7 @@\n                 .context(\"Preparing insertion\")?;\n \n             let toolchain: Vec<(String, String, String)> =\n-                select((workspace_id, language_name.0.to_owned(), worktree_id.to_usize()))?;\n+                select((workspace_id, language_name.as_ref().to_string(), worktree_id.to_usize()))?;\n \n             Ok(toolchain.into_iter().next().and_then(|(name, path, raw_json)| Some(Toolchain {\n                 name: name.into(),\n\n```\n\nUser edited \"crates/language_selector/src/language_selector.rs\":\n```diff\n@@ -154,7 +154,7 @@\n             let language_name = LanguageName::new(mat.string.as_str());\n             match self\n                 .language_registry\n-                .available_language_for_name(&language_name.)\n+                .available_language_for_name(&language_name.as_ref())\n             {\n                 Some(available_language) => {\n                     let icon = self.language_icon(available_language.matcher(), cx);\n\n```\n\nUser edited \"crates/language_selector/src/language_selector.rs\":\n```diff\n@@ -154,7 +154,7 @@\n             let language_name = LanguageName::new(mat.string.as_str());\n             match self\n                 .language_registry\n-                .available_language_for_name(&language_name.as_ref())\n+                .available_language_for_name(language_name.as_ref())\n             {\n                 Some(available_language) => {\n                     let icon = self.language_icon(available_language.matcher(), cx);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/language_tools/src/syntax_tree_view.rs\n                                    view.select_layer(layer_ix, window, cx);\n                                }),\n                            );\n                        }\n                        menu\n                    })\n                    .into()\n                }),\n        )\n    }\n\n    fn select_layer(\n        &mut self,\n        layer_ix: usize,\n<|editable_region_start|>\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let tree_view = self.tree_view.as_ref()?;\n        tree_view.update(cx, |view, cx| {\n            let editor_state = view.editor.as_mut()?;\n            let buffer_state = editor_state.active_buffer.as_mut()?;\n            let snapshot = buffer_state.buffer.read(cx).snapshot();\n            let layer = snapshot.syntax_layers().nth(layer_ix)?;\n            buffer_state.active_layer = Some(layer.to_owned());\n            view.selected_descendant_ix = None;\n            cx.notify();\n            view.focus_handle.focus(window);\n            Some(())\n        })\n    }\n\n    fn render_header(active_layer: &OwnedSyntaxLayer) -> ButtonLike {\n        ButtonLike::new(\"syntax tree header\")\n            .child(Label::new(active_layer.language.name().))\n            .child(Label::new(format_node_range(active_layer.node())))\n    }\n}<|user_cursor_is_here|>\n\nfn format_node_range(node: Node) -> String {\n    let start = node.start_position();\n<|editable_region_end|>\n    let end = node.end_position();\n    format!(\n        \"[{}:{} - {}:{}]\",\n        start.row + 1,\n        start.column + 1,\n        end.row + 1,\n        end.column + 1,\n    )\n}\n\nimpl Render for SyntaxTreeToolbarItemView {\n    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        self.render_menu(cx)\n            .unwrap_or_else(|| PopoverMenu::new(\"Empty Syntax Tree\"))\n    }\n}\n\nimpl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView {}\n\nimpl ToolbarItemView for SyntaxTreeToolbarItemView {\n    fn set_active_pane_item(\n        &mut self,\n        active_pane_item: Option<&dyn ItemHandle>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> ToolbarItemLocation {\n        if let Some(item) = active_pane_item {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/language_tools/src/syntax_tree_view.rs\n                                    view.select_layer(layer_ix, window, cx);\n                                }),\n                            );\n                        }\n                        menu\n                    })\n                    .into()\n                }),\n        )\n    }\n\n    fn select_layer(\n        &mut self,\n        layer_ix: usize,\n<|editable_region_start|>\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let tree_view = self.tree_view.as_ref()?;\n        tree_view.update(cx, |view, cx| {\n            let editor_state = view.editor.as_mut()?;\n            let buffer_state = editor_state.active_buffer.as_mut()?;\n            let snapshot = buffer_state.buffer.read(cx).snapshot();\n            let layer = snapshot.syntax_layers().nth(layer_ix)?;\n            buffer_state.active_layer = Some(layer.to_owned());\n            view.selected_descendant_ix = None;\n            cx.notify();\n            view.focus_handle.focus(window);\n            Some(())\n        })\n    }\n\n    fn render_header(active_layer: &OwnedSyntaxLayer) -> ButtonLike {\n        ButtonLike::new(\"syntax tree header\")\n            .child(Label::new(active_layer.language.name().as_ref()))\n            .child(Label::new(format_node_range(active_layer.node())))\n    }\n}\n\nfn format_node_range(node: Node) -> String {\n    let start = node.start_position();\n<|editable_region_end|>\n    let end = node.end_position();\n    format!(\n        \"[{}:{} - {}:{}]\",\n        start.row + 1,\n        start.column + 1,\n        end.row + 1,\n        end.column + 1,\n    )\n}\n\nimpl Render for SyntaxTreeToolbarItemView {\n    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        self.render_menu(cx)\n            .unwrap_or_else(|| PopoverMenu::new(\"Empty Syntax Tree\"))\n    }\n}\n\nimpl EventEmitter<ToolbarItemEvent> for SyntaxTreeToolbarItemView {}\n\nimpl ToolbarItemView for SyntaxTreeToolbarItemView {\n    fn set_active_pane_item(\n        &mut self,\n        active_pane_item: Option<&dyn ItemHandle>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> ToolbarItemLocation {\n        if let Some(item) = active_pane_item {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/rope/src/rope.rs\":\n```diff\n@@ -450,6 +450,8 @@\n         self.clip_point(Point::new(row, u32::MAX), Bias::Left)\n             .column\n     }\n+    \n+    pub fn ptr_eq(&self, other: &elf\n }\n \n impl<'a> From<&'a str> for Rope {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/rope/src/rope.rs\n            *cursor.start() + chunk.as_slice().clip_offset_utf16(overshoot, bias)\n        } else {\n<|editable_region_start|>\n            self.summary().len_utf16\n        }\n    }\n<|user_cursor_is_here|>\n    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {\n        let mut cursor = self.chunks.cursor::<Point>(&());\n        cursor.seek(&point, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = point - cursor.start();\n            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)\n        } else {\n<|editable_region_end|>\n            self.summary().lines\n        }\n    }\n\n    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {\n        let mut cursor = self.chunks.cursor::<PointUtf16>(&());\n        cursor.seek(&point.0, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = Unclipped(point.0 - cursor.start());\n            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)\n        } else {\n            self.summary().lines_utf16()\n        }\n    }\n\n    pub fn line_len(&self, row: u32) -> u32 {\n        self.clip_point(Point::new(row, u32::MAX), Bias::Left)\n            .column\n    }\n    \n    pub fn ptr_eq(&self, other: &elf\n}\n\nimpl<'a> From<&'a str> for Rope {\n    fn from(text: &'a str) -> Self {\n        let mut rope = Self::new();\n        rope.push(text);\n        rope\n    }\n}\n\nimpl<'a> FromIterator<&'a str> for Rope {\n    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n        let mut rope = Rope::new();\n        for chunk in iter {\n            rope.push(chunk);\n        }\n        rope\n    }\n}\n\nimpl From<String> for Rope {\n    fn from(text: String) -> Self {\n        Rope::from(text.as_str())\n    }\n}\n\nimpl fmt::Display for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for chunk in self.chunks() {\n            write!(f, \"{}\", chunk)?;\n        }\n        Ok(())\n    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/rope/src/rope.rs\n            *cursor.start() + chunk.as_slice().clip_offset_utf16(overshoot, bias)\n        } else {\n<|editable_region_start|>\n            self.summary().len_utf16\n        }\n    }\n\n    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {\n        let mut cursor = self.chunks.cursor::<Point>(&());\n        cursor.seek(&point, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = point - cursor.start();\n            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)\n        } else {\n<|editable_region_end|>\n            self.summary().lines\n        }\n    }\n\n    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {\n        let mut cursor = self.chunks.cursor::<PointUtf16>(&());\n        cursor.seek(&point.0, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = Unclipped(point.0 - cursor.start());\n            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)\n        } else {\n            self.summary().lines_utf16()\n        }\n    }\n\n    pub fn line_len(&self, row: u32) -> u32 {\n        self.clip_point(Point::new(row, u32::MAX), Bias::Left)\n            .column\n    }\n    \n    pub fn ptr_eq(&self, other: &elf\n}\n\nimpl<'a> From<&'a str> for Rope {\n    fn from(text: &'a str) -> Self {\n        let mut rope = Self::new();\n        rope.push(text);\n        rope\n    }\n}\n\nimpl<'a> FromIterator<&'a str> for Rope {\n    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n        let mut rope = Rope::new();\n        for chunk in iter {\n            rope.push(chunk);\n        }\n        rope\n    }\n}\n\nimpl From<String> for Rope {\n    fn from(text: String) -> Self {\n        Rope::from(text.as_str())\n    }\n}\n\nimpl fmt::Display for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for chunk in self.chunks() {\n            write!(f, \"{}\", chunk)?;\n        }\n        Ok(())\n    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/rope/src/rope.rs\":\n```diff\n@@ -452,7 +452,7 @@\n     }\n     \n     pub fn ptr_eq(&self, other: &Self) -> bool {\n-        self.chunks.\n+        self.chunks.ptr_eq(&ot)\n     }\n }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/rope/src/rope.rs\n        } else {\n            self.summary().len_utf16\n        }\n    }\n\n    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {\n        let mut cursor = self.chunks.cursor::<Point>(&());\n        cursor.seek(&point, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = point - cursor.start();\n            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)\n        } else {\n            self.summary().lines\n        }\n    }\n\n    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {\n        let mut cursor = self.chunks.cursor::<PointUtf16>(&());\n        cursor.seek(&point.0, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n<|editable_region_start|>\n            let overshoot = Unclipped(point.0 - cursor.start());\n            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)\n        } else {\n            self.summary().lines_utf16()\n        }\n    }\n\n    pub fn line_len(&self, row: u32) -> u32 {\n        self.clip_point(Point::new(row, u32::MAX), Bias::Left)\n            .column\n    }\n    \n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        self.chunks.ptr_eq(&ot)\n    }\n}\n\nimpl<'a> From<&'a str> for Rope {\n    fn from(text: &'a str) -> Self {\n        let mut rope = Self::new();\n        rope.push(text);\n        rope\n    }\n}\n\nimpl<'a> FromIterator<&'a str> for Rope {\n    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n        let mut rope = Rope::new();\n        for chunk in iter {\n            rope.push(chunk);\n        }\n        rope\n    }\n}\n<|user_cursor_is_here|>\nimpl From<String> for Rope {\n<|editable_region_end|>\n    fn from(text: String) -> Self {\n        Rope::from(text.as_str())\n    }\n}\n\nimpl fmt::Display for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for chunk in self.chunks() {\n            write!(f, \"{}\", chunk)?;\n        }\n        Ok(())\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/rope/src/rope.rs\n        } else {\n            self.summary().len_utf16\n        }\n    }\n\n    pub fn clip_point(&self, point: Point, bias: Bias) -> Point {\n        let mut cursor = self.chunks.cursor::<Point>(&());\n        cursor.seek(&point, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n            let overshoot = point - cursor.start();\n            *cursor.start() + chunk.as_slice().clip_point(overshoot, bias)\n        } else {\n            self.summary().lines\n        }\n    }\n\n    pub fn clip_point_utf16(&self, point: Unclipped<PointUtf16>, bias: Bias) -> PointUtf16 {\n        let mut cursor = self.chunks.cursor::<PointUtf16>(&());\n        cursor.seek(&point.0, Bias::Right, &());\n        if let Some(chunk) = cursor.item() {\n<|editable_region_start|>\n            let overshoot = Unclipped(point.0 - cursor.start());\n            *cursor.start() + chunk.as_slice().clip_point_utf16(overshoot, bias)\n        } else {\n            self.summary().lines_utf16()\n        }\n    }\n\n    pub fn line_len(&self, row: u32) -> u32 {\n        self.clip_point(Point::new(row, u32::MAX), Bias::Left)\n            .column\n    }\n    \n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        self.chunks.ptr_eq(&other.chunks)\n    }\n}\n\nimpl<'a> From<&'a str> for Rope {\n    fn from(text: &'a str) -> Self {\n        let mut rope = Self::new();\n        rope.push(text);\n        rope\n    }\n}\n\nimpl<'a> FromIterator<&'a str> for Rope {\n    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n        let mut rope = Rope::new();\n        for chunk in iter {\n            rope.push(chunk);\n        }\n        rope\n    }\n}\n\nimpl From<String> for Rope {\n<|editable_region_end|>\n    fn from(text: String) -> Self {\n        Rope::from(text.as_str())\n    }\n}\n\nimpl fmt::Display for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for chunk in self.chunks() {\n            write!(f, \"{}\", chunk)?;\n        }\n        Ok(())\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -915,8 +915,9 @@\n         result.push_str(self.file_path);\n         result.push('\\n');\n         if self.start_of_file_marker {\n-            result.push_str(START_OF)\n+            result.push_str(START_OF_FILE_MARKER);\n         }\n+        \n     }\n }\n \n\n```\n\n\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -917,7 +917,7 @@\n         if self.start_of_file_marker {\n             result.push_str(START_OF_FILE_MARKER);\n         }\n-        \n+        result.push\n     }\n }\n \n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -917,7 +917,7 @@\n         if self.start_of_file_marker {\n             result.push_str(START_OF_FILE_MARKER);\n         }\n-        result.push\n+        result.push()\n     }\n }\n \n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -917,7 +917,6 @@\n         if self.start_of_file_marker {\n             result.push_str(START_OF_FILE_MARKER);\n         }\n-        result.push()\n     }\n }\n \n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -942,6 +942,8 @@\n     pub fn append_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n         self.chunks.extend(snapshot.text_for_range(range));\n     }\n+    \n+    pub fn append_to\n \n     /*\n     pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -943,7 +943,7 @@\n         self.chunks.extend(snapshot.text_for_range(range));\n     }\n     \n-    pub fn append_to\n+    pub fn \n \n     /*\n     pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -943,7 +943,7 @@\n         self.chunks.extend(snapshot.text_for_range(range));\n     }\n     \n-    pub fn \n+    pub fn push_to_string()\n \n     /*\n     pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -942,8 +942,6 @@\n     pub fn append_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n         self.chunks.extend(snapshot.text_for_range(range));\n     }\n-    \n-    pub fn push_to_string()\n \n     /*\n     pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -942,6 +942,8 @@\n     pub fn append_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n         self.chunks.extend(snapshot.text_for_range(range));\n     }\n+    \n+    pub fn \n \n     /*\n     pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/zeta.rs\n<|editable_region_start|>\n        let mut result = String::with_capacity(length);\n        result.push_str(\"```\");\n        result.push_str(self.file_path);\n        result.push('\\n');\n        if self.start_of_file_marker {\n            result.push_str(START_OF_FILE_MARKER);\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub struct StringChunks<'a> {\n    chunks: Vec<&'a str>,\n    length: usize,\n}\n\n#[derive(Debug, Default)]\npub struct ReversedStringChunks<'a>(StringChunks<'a>);\n\nimpl<'a> StringChunks<'a> {\n    pub fn len(&self) -> usize {\n        self.length\n    }\n\n    pub fn extend(&mut self, new_chunks: impl Iterator<Item = &'a str>) {\n        self.chunks\n            .extend(new_chunks.inspect(|chunk| self.length += chunk.len()));\n    }\n\n    pub fn append_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n        self.chunks.extend(snapshot.text_for_range(range));\n    }\n    \n    pub fn \n\n    /*\n    pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n        let mut reached_limit = true;\n        self.chunks.extend(new_chun<|user_cursor_is_here|>ks.take_while(|chunk| {\n            let chunk_len = chunk.len();\n            if chunk_len > remaining_length {\n                reached_limit = false;\n                false\n            } else {\n                remaining_length -= chunk_len;\n                true\n            }\n<|editable_region_end|>\n        }));\n        reached_limit\n    }\n    */\n}\n\nimpl<'a> ReversedStringChunks<'a> {\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    pub fn prepend_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n        self.0.extend(snapshot.reversed_chunks_in_range(range));\n    }\n}\n\n/// Computes an excerpt of the buffer around the cursor for the model, including the current cursor\n/// position. This excerpt is <= \nfn prompt_for_excerpt(\n    snapshot: &BufferSnapshot,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/zeta.rs\n<|editable_region_start|>\n        let mut result = String::with_capacity(length);\n        result.push_str(\"```\");\n        result.push_str(self.file_path);\n        result.push('\\n');\n        if self.start_of_file_marker {\n            result.push_str(START_OF_FILE_MARKER);\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub struct StringChunks<'a> {\n    chunks: Vec<&'a str>,\n    length: usize,\n}\n\n#[derive(Debug, Default)]\npub struct ReversedStringChunks<'a>(StringChunks<'a>);\n\nimpl<'a> StringChunks<'a> {\n    pub fn len(&self) -> usize {\n        self.length\n    }\n\n    pub fn extend(&mut self, new_chunks: impl Iterator<Item = &'a str>) {\n        self.chunks\n            .extend(new_chunks.inspect(|chunk| self.length += chunk.len()));\n    }\n\n    pub fn append_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n        self.chunks.extend(snapshot.text_for_range(range));\n    }\n    \n    pub fn push_to_string(&self, string: &mut String) {\n        for chunk in &self.chunks {\n            string.push_str(chunk);\n        }\n    }\n\n    /*\n    pub fn extend_limited(&mut self, new_chunks: impl Iterator<Item = &'a str>, mut remaining_length: usize) -> bool {\n        let mut reached_limit = true;\n        self.chunks.extend(new_chunks.take_while(|chunk| {\n            let chunk_len = chunk.len();\n            if chunk_len > remaining_length {\n                reached_limit = false;\n                false\n            } else {\n                remaining_length -= chunk_len;\n                true\n            }\n<|editable_region_end|>\n        }));\n        reached_limit\n    }\n    */\n}\n\nimpl<'a> ReversedStringChunks<'a> {\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    pub fn prepend_from_buffer(&mut self, snapshot: &'a BufferSnapshot, range: Range<usize>) {\n        self.0.extend(snapshot.reversed_chunks_in_range(range));\n    }\n}\n\n/// Computes an excerpt of the buffer around the cursor for the model, including the current cursor\n/// position. This excerpt is <= \nfn prompt_for_excerpt(\n    snapshot: &BufferSnapshot,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -171,7 +171,7 @@\n         })\n     };\n \n-    dbg!()\n+    console_log!(\"Write even\")\n     \n     // telemetry_sink\n     //     .write(SnowflakeTelemetryEvent::new(\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/llm_worker/src/llm_worker.rs\n<|editable_region_start|>\n            prediction: Some(fireworks::Prediction::Content {\n                content: request_body.input_excerpt.clone(),\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await;\n    let mut response = match response {\n        Ok(response) => response,\n        Err(err) => {\n            return Response::error(err.to_string(), StatusCode::INTERNAL_SERVER_ERROR.as_u16())\n        }\n    };\n\n    let request_duration = request_started_at.elapsed();\n\n    let Some(choice) = response.completion.choices.pop() else {\n        return Response::error(\n            \"no output from completion response\",\n            StatusCode::INTERNAL_SERVER_ERROR.as_u16(),\n        );\n    };\n\n    let output_excerpt = choice.text;\n\n    let properties = if sample_input_and_output {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration.as_secs_f64(),\n            \"prompt\": prompt,\n            \"input_excerpt\": request_body.input_excerpt,\n            \"input_events\": request_body.input_events,\n            \"outline\": request_body.outline,\n            \"output\": output_excerpt.clone(),\n            \"is_sampled\": true,\n      <|user_cursor_is_here|>  })\n    } else {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration.as_secs_f64(),\n            \"is_sampled\": false,\n<|editable_region_end|>\n        })\n    };\n\n    console_log!(\"Write even\")\n    \n    // telemetry_sink\n    //     .write(SnowflakeTelemetryEvent::new(\n    //         \"Fireworks Completion Requested\",\n    //         claims.metrics_id,\n    //         claims.is_staff,\n    //         claims.system_id,\n    //         properties,\n    //     ))\n    //     .await\n    //     .ok();\n\n    Response::from_json(&PredictEditsResponse { output_excerpt })\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/llm_worker/src/llm_worker.rs\n<|editable_region_start|>\n            prediction: Some(fireworks::Prediction::Content {\n                content: request_body.input_excerpt.clone(),\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await;\n    let mut response = match response {\n        Ok(response) => response,\n        Err(err) => {\n            return Response::error(err.to_string(), StatusCode::INTERNAL_SERVER_ERROR.as_u16())\n        }\n    };\n\n    let request_duration = request_started_at.elapsed();\n\n    let Some(choice) = response.completion.choices.pop() else {\n        return Response::error(\n            \"no output from completion response\",\n            StatusCode::INTERNAL_SERVER_ERROR.as_u16(),\n        );\n    };\n\n    let output_excerpt = choice.text;\n\n    let properties = if sample_input_and_output {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration.as_secs_f64(),\n            \"prompt\": prompt,\n            \"input_excerpt\": request_body.input_excerpt,\n            \"input_events\": request_body.input_events,\n            \"outline\": request_body.outline,\n            \"output\": output_excerpt.clone(),\n            \"is_sampled\": true,\n        })\n    } else {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration.as_secs_f64(),\n            \"is_sampled\": false,\n<|editable_region_end|>\n        })\n    };\n\n    console_log!(\"Write even\")\n    \n    // telemetry_sink\n    //     .write(SnowflakeTelemetryEvent::new(\n    //         \"Fireworks Completion Requested\",\n    //         claims.metrics_id,\n    //         claims.is_staff,\n    //         claims.system_id,\n    //         properties,\n    //     ))\n    //     .await\n    //     .ok();\n\n    Response::from_json(&PredictEditsResponse { output_excerpt })\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -2469,6 +2469,8 @@\n     pub fn base_text_string(&self) -> Option<String> {\n         self.base_text.as_ref().map(|buffer| buffer.text())\n     }\n+    \n+    #[c]\n \n     #[cfg(any(test, feature = \"test-support\"))]\n     pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/buffer_store.rs\n                .push(buffer.read(cx).remote_id().into());\n            serialized_transaction\n                .transactions\n                .push(language::proto::serialize_transaction(&transaction));\n        }\n        serialized_transaction\n    }\n}\n\nimpl BufferChangeSet {\n    pub fn diff_hunks_intersecting_range<'a>(\n        &'a self,\n        range: Range<text::Anchor>,\n        buffer_snapshot: &'a text::BufferSnapshot,\n    ) -> impl 'a + Iterator<Item = git::diff::DiffHunk> {\n        self.diff_to_buffer\n            .hunks_intersecting_range(range, buffer_snapshot)\n<|editable_region_start|>\n    }\n\n    pub fn diff_hunks_intersecting_range_rev<'a>(\n        &'a self,\n        range: Range<text::Anchor>,\n        buffer_snapshot: &'a text::BufferSnapshot,\n    ) -> impl 'a + Iterator<Item = git::diff::DiffHunk> {\n        self.diff_to_buffer\n            .hunks_intersecting_range_rev(range, buffer_snapshot)\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn base_text_string(&self) -> Option<String> {\n        self.base_text.as_ref().map(|buffer| buffer.text())\n    }\n    \n    #[c]\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        let diff_to_buffer =\n            git::diff::BufferDiff::build(base_text, &buffer.read(cx).text_snapshot());\n        let base_text = language::Buffer::build_snapshot_sync(base_text.into(), None, None, cx);\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n            base_text: Some(base_text),\n            diff_to_buffer,\n        }\n    }\n}\n\nimpl OpenBuffer {\n    fn upgrade(&self) -> Option<Entity<Buffer>> {\n        match self {\n            OpenBuffer::Complete { buffer, .. } => buffer.upgrade(),\n            OpenBuffer::Operations(_) => None,\n        }\n    }\n}\n\nfn is_not_found_error(error: &anyhow::Error) -> bool {\n    er<|user_cursor_is_here|>ror\n        .root_cause()\n        .downcast_ref::<io::Error>()\n        .is_some_and(|err| err.kind() == io::ErrorKind::NotFound)\n}\n<|editable_region_end|>\n\nfn serialize_blame_buffer_response(blame: Option<git::blame::Blame>) -> proto::BlameBufferResponse {\n    let Some(blame) = blame else {\n        return proto::BlameBufferResponse {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/buffer_store.rs\n                .push(buffer.read(cx).remote_id().into());\n            serialized_transaction\n                .transactions\n                .push(language::proto::serialize_transaction(&transaction));\n        }\n        serialized_transaction\n    }\n}\n\nimpl BufferChangeSet {\n    pub fn diff_hunks_intersecting_range<'a>(\n        &'a self,\n        range: Range<text::Anchor>,\n        buffer_snapshot: &'a text::BufferSnapshot,\n    ) -> impl 'a + Iterator<Item = git::diff::DiffHunk> {\n        self.diff_to_buffer\n            .hunks_intersecting_range(range, buffer_snapshot)\n<|editable_region_start|>\n    }\n\n    pub fn diff_hunks_intersecting_range_rev<'a>(\n        &'a self,\n        range: Range<text::Anchor>,\n        buffer_snapshot: &'a text::BufferSnapshot,\n    ) -> impl 'a + Iterator<Item = git::diff::DiffHunk> {\n        self.diff_to_buffer\n            .hunks_intersecting_range_rev(range, buffer_snapshot)\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn base_text_string(&self) -> Option<String> {\n        self.base_text.as_ref().map(|buffer| buffer.text())\n    }\n    \n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn \n    \n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        let diff_to_buffer =\n            git::diff::BufferDiff::build(base_text, &buffer.read(cx).text_snapshot());\n        let base_text = language::Buffer::build_snapshot_sync(base_text.into(), None, None, cx);\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n            base_text: Some(base_text),\n            diff_to_buffer,\n        }\n    }\n}\n\nimpl OpenBuffer {\n    fn upgrade(&self) -> Option<Entity<Buffer>> {\n        match self {\n            OpenBuffer::Complete { buffer, .. } => buffer.upgrade(),\n            OpenBuffer::Operations(_) => None,\n        }\n    }\n}\n\nfn is_not_found_error(error: &anyhow::Error) -> bool {\n    error\n        .root_cause()\n        .downcast_ref::<io::Error>()\n        .is_some_and(|err| err.kind() == io::ErrorKind::NotFound)\n}\n<|editable_region_end|>\n\nfn serialize_blame_buffer_response(blame: Option<git::blame::Blame>) -> proto::BlameBufferResponse {\n    let Some(blame) = blame else {\n        return proto::BlameBufferResponse {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/extension.ts\":\n```diff\n@@ -127,7 +127,7 @@\n   return explicitlySupportedLanguages.includes(lang as SupportedLanguage);\n }\n \n-// ideally with more time i'd use tree-sitter or something here so in languages that need it \n+// ideally with more time i'd use tree-sitter or something here so in languages that need it we\n function colorStringForLanguage(color: string, lang?: SupportedLanguage) {\n   switch (lang) {\n     case \"rust\":\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/extension.ts\n    matchedColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${rgbaMatch[4]})`;\n  }\n\n  if (matchedColor) {\n    try {\n      const color = chroma(matchedColor);\n      return color.hex();\n    } catch (error) {\n      return \"Color is invalid, or an unsupported color type\";\n<|editable_region_start|>\n    <|user_cursor_is_here|>}\n  }\n\n  try {\n    const color = chroma(line.trim());\n    return color.hex();\n  } catch (error) {\n    return \"Color is invalid, or an unsupported color type\";\n  }\n}\n\n/**\n * Get the active buffer's language\n * so we can dynamically generate color strings based on the language\n */\nfunction activeBufferLanguage() {\n  const editor = vscode.window.activeTextEditor;\n  return editor?.document.languageId || null;\n}\n\nfunction languageIsSupported(lang: string): lang is SupportedLanguage {\n  return explicitlySupportedLanguages.includes(lang as SupportedLanguage);\n}\n\n// ideally with more time i'd use tree-sitter or something here so in languages that need it we\nfunction colorStringForLanguage(color: string, lang?: SupportedLanguage) {\n  switch (lang) {\n    case \"rust\":\n      return `Rgb::new(${color})`;\n    case \"typescript\":\n      return color;\n    case \"css\":\n      return `#${color}`;\n    case \"json\":\n      return `\"${color}\"`;\n    default:\n      return color;\n  }\n}\n\n// as there would probably be a lot of these, it would be nice to use\n// something similar to handlebars templates to define color strings\n// for various languages/formats, and keep them somewhere external\n// like src/templates\nfunction allColorsStringForLanguage(\n  colors: { [folder: string]: { [key: string]: string } },\n  lang: SupportedLanguage | \"default\",\n): string {\n  switch (lang) {\n    case \"rust\":\n      let rustCode = `\nuse palette::rgb::Rgb;\n<|editable_region_end|>\n\ntrait Color {\n    fn name(&self) -> &'static str;\n    fn rgb(&self) -> Rgb;\n    fn hex(&self) -> &'static str;\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/extension.ts\n    matchedColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${rgbaMatch[4]})`;\n  }\n\n  if (matchedColor) {\n    try {\n      const color = chroma(matchedColor);\n      return color.hex();\n    } catch (error) {\n      return \"Color is invalid, or an unsupported color type\";\n<|editable_region_start|>\n    }\n  }\n\n  try {\n    const color = chroma(line.trim());\n    return color.hex();\n  } catch (error) {\n    return \"Color is invalid, or an unsupported color type\";\n  }\n}\n\n/**\n * Get the active buffer's language\n * so we can dynamically generate color strings based on the language\n */\nfunction activeBufferLanguage() {\n  const editor = vscode.window.activeTextEditor;\n  return editor?.document.languageId || null;\n}\n\nfunction languageIsSupported(lang: string): lang is SupportedLanguage {\n  return explicitlySupportedLanguages.includes(lang as SupportedLanguage);\n}\n\n// ideally with more time i'd use tree-sitter or something here so in languages that need it we could account for syntax more easily\nfunction colorStringForLanguage(color: string, lang?: SupportedLanguage) {\n  switch (lang) {\n    case \"rust\":\n      return `Rgb::new(${color})`;\n    case \"typescript\":\n      return color;\n    case \"css\":\n      return `#${color}`;\n    case \"json\":\n      return `\"${color}\"`;\n    default:\n      return color;\n  }\n}\n\n// as there would probably be a lot of these, it would be nice to use\n// something similar to handlebars templates to define color strings\n// for various languages/formats, and keep them somewhere external\n// like src/templates\nfunction allColorsStringForLanguage(\n  colors: { [folder: string]: { [key: string]: string } },\n  lang: SupportedLanguage | \"default\",\n): string {\n  switch (lang) {\n    case \"rust\":\n      let rustCode = `\nuse palette::rgb::Rgb;\n<|editable_region_end|>\n\ntrait Color {\n    fn name(&self) -> &'static str;\n    fn rgb(&self) -> Rgb;\n    fn hex(&self) -> &'static str;\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/proposed_changes_editor.rs\":\n```diff\n@@ -112,7 +112,7 @@\n                                         .change_set_for(buffer.remote_id())?;\n                                     Some(change_set.update(cx, |change_set, cx| {\n                                         change_set.set_base_text(\n-                                            base_buffer.read(cx).as_rop\n+                                            base_buffer.read(cx).as_rope\n                                             buffer,\n                                             cx,\n                                         )\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/proposed_changes_editor.rs\n                while let Some(mut recalculate_diff) = recalculate_diffs_rx.next().await {\n                    buffers_to_diff.insert(recalculate_diff.buffer);\n\n                    while recalculate_diff.debounce {\n                        cx.background_executor()\n                            .timer(Duration::from_millis(50))\n                            .await;\n                        let mut had_further_changes = false;\n                        while let Ok(next_recalculate_diff) = recalculate_diffs_rx.try_next() {\n                            let next_recalculate_diff = next_recalculate_diff?;\n                            recalculate_diff.debounce &= next_recalculate_diff.debounce;\n                            buffers_to_diff.insert(next_recalculate_diff.buffer);\n                            had_further_changes = true;\n                        }\n                        if !had_further_changes {\n                            break;\n                        }\n                    }\n\n                    let recalculate_diff_futures = this\n<|editable_region_start|>\n                        .update(&mut cx, |this, cx| {\n                            buffers_to_diff\n                                .drain()\n                                .filter_map(|buffer| {\n                                    let buffer = buffer.read(cx);\n                                    let base_buffer = buffer.base_buffer()?;\n                                    let buffer = buffer.text_snapshot();\n                                    let change_set = this\n                                        .multibuffer\n                                        .read(cx)\n                                        .change_set_for(buffer.remote_id())?;\n                                    Some(change_set.update(cx, |change_set, cx| {\n                                        change_set.set_base_text(\n                                            base_buffer.read(cx).as_rope\n                                            buffer,\n                                            cx,\n                                        )\n                                    }))\n                                })\n                                .collect::<Vec<_>>()\n                        })\n                        .ok()?;\n\n                    join_all(recalculate_diff_futures).await;\n                }\n                None\n            }),\n        };\n        this.reset_locations(locations, window, cx);\n        this\n    }\n\n    pub fn branch_buffer_for_base(&self, base_buffer: &Entity<Buffer>) -> Option<Entity<Buffer>> {\n  <|user_cursor_is_here|>      self.buffer_entries.iter().find_map(|entry| {\n            if &entry.base == base_buffer {\n<|editable_region_end|>\n                Some(entry.branch.clone())\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn set_title(&mut self, title: SharedString, cx: &mut Context<Self>) {\n        self.title = title;\n        cx.notify();\n    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/proposed_changes_editor.rs\n                while let Some(mut recalculate_diff) = recalculate_diffs_rx.next().await {\n                    buffers_to_diff.insert(recalculate_diff.buffer);\n\n                    while recalculate_diff.debounce {\n                        cx.background_executor()\n                            .timer(Duration::from_millis(50))\n                            .await;\n                        let mut had_further_changes = false;\n                        while let Ok(next_recalculate_diff) = recalculate_diffs_rx.try_next() {\n                            let next_recalculate_diff = next_recalculate_diff?;\n                            recalculate_diff.debounce &= next_recalculate_diff.debounce;\n                            buffers_to_diff.insert(next_recalculate_diff.buffer);\n                            had_further_changes = true;\n                        }\n                        if !had_further_changes {\n                            break;\n                        }\n                    }\n\n                    let recalculate_diff_futures = this\n<|editable_region_start|>\n                        .update(&mut cx, |this, cx| {\n                            buffers_to_diff\n                                .drain()\n                                .filter_map(|buffer| {\n                                    let buffer = buffer.read(cx);\n                                    let base_buffer = buffer.base_buffer()?;\n                                    let buffer = buffer.text_snapshot();\n                                    let change_set = this\n                                        .multibuffer\n                                        .read(cx)\n                                        .change_set_for(buffer.remote_id())?;\n                                    Some(change_set.update(cx, |change_set, cx| {\n                                        change_set.set_base_text(\n                                            base_buffer.read(cx).as_rope(),\n                                            buffer,\n                                            cx,\n                                        )\n                                    }))\n                                })\n                                .collect::<Vec<_>>()\n                        })\n                        .ok()?;\n\n                    join_all(recalculate_diff_futures).await;\n                }\n                None\n            }),\n        };\n        this.reset_locations(locations, window, cx);\n        this\n    }\n\n    pub fn branch_buffer_for_base(&self, base_buffer: &Entity<Buffer>) -> Option<Entity<Buffer>> {\n        self.buffer_entries.iter().find_map(|entry| {\n            if &entry.base == base_buffer {\n<|editable_region_end|>\n                Some(entry.branch.clone())\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn set_title(&mut self, title: SharedString, cx: &mut Context<Self>) {\n        self.title = title;\n        cx.notify();\n    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zed/src/zed.rs\":\n```diff\n@@ -1281,7 +1281,7 @@\n     match error.as_ref() {\n         Some(error) if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                         error.downcast_ref::<InvalidSettingsError>() => {\n-                        }\n+        }\n             if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                 error.downcast_ref::<InvalidSettingsError>()\n             {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zed/src/zed.rs\n}\n\nfn reload_keymaps(cx: &mut App, user_key_bindings: Vec<KeyBinding>) {\n    cx.clear_key_bindings();\n    load_default_keymap(cx);\n    cx.bind_keys(user_key_bindings);\n    cx.set_menus(app_menus());\n    cx.set_dock_menu(vec![MenuItem::action(\"New Window\", workspace::NewWindow)]);\n}\n\npub fn load_default_keymap(cx: &mut App) {\n    let base_keymap = *BaseKeymap::get_global(cx);\n    if base_keymap == BaseKeymap::None {\n        return;\n    }\n\n    cx.bind_keys(KeymapFile::load_asset(DEFAULT_KEYMAP_PATH, cx).unwrap());\n    if VimModeSetting::get_global(cx).0 {\n        cx.bind_keys(KeymapFile::load_asset(VIM_KEYMAP_PATH, cx).unwrap());\n    }\n\n    if let Some(asset_path) = base_keymap.asset_path() {\n        cx.bind_keys(KeymapFile::load_asset(asset_path, cx).unwrap());\n    }\n}\n\nfn handle_settings_changed(error: Option<anyhow::Error>, cx: &mut App) {\n    struct SettingsParseErrorNotification;\n    let id = NotificationId::unique::<SettingsParseErrorNotification>();\n    \n    match error.as_ref() {\n        Some(error) if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                        error.downcast_ref::<InvalidSettingsError>() => {\n        }\n            if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                error.downcast_ref::<InvalidSettingsError>()\n            {\n                // Local settings errors are displayed by the projects\n                return;\n            } else {\n                Some()\n            }\n        }\n    }\n\n    \n    show_app_notification(id, cx, move |cx| {\n    \n\n    for workspace in workspace::local_workspace_windows(cx) {\n        workspace\n            .update(cx, |workspace, _, cx| {\n                match error.as_ref() {\n                    Some(error) => {\n                        if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                            error.downcast_ref::<InvalidSettingsError>()\n                        {\n                            // Local settings will be displayed by the projects\n                        } else {\n                            workspace.show_notification(id.clone(), cx, |cx| {\n                                cx.new(|_cx| {\n<|editable_region_start|>\n                                    MessageNotification::new(format!(\n                                        \"Invalid user settings file\\n{error}\"\n                                    ))\n    <|user_cursor_is_here|>                                .with_click_message(\"Open settings file\")\n<|editable_region_end|>\n                                    .on_click(|window, cx| {\n                                        window.dispatch_action(\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zed/src/zed.rs\n}\n\nfn reload_keymaps(cx: &mut App, user_key_bindings: Vec<KeyBinding>) {\n    cx.clear_key_bindings();\n    load_default_keymap(cx);\n    cx.bind_keys(user_key_bindings);\n    cx.set_menus(app_menus());\n    cx.set_dock_menu(vec![MenuItem::action(\"New Window\", workspace::NewWindow)]);\n}\n\npub fn load_default_keymap(cx: &mut App) {\n    let base_keymap = *BaseKeymap::get_global(cx);\n    if base_keymap == BaseKeymap::None {\n        return;\n    }\n\n    cx.bind_keys(KeymapFile::load_asset(DEFAULT_KEYMAP_PATH, cx).unwrap());\n    if VimModeSetting::get_global(cx).0 {\n        cx.bind_keys(KeymapFile::load_asset(VIM_KEYMAP_PATH, cx).unwrap());\n    }\n\n    if let Some(asset_path) = base_keymap.asset_path() {\n        cx.bind_keys(KeymapFile::load_asset(asset_path, cx).unwrap());\n    }\n}\n\nfn handle_settings_changed(error: Option<anyhow::Error>, cx: &mut App) {\n    struct SettingsParseErrorNotification;\n    let id = NotificationId::unique::<SettingsParseErrorNotification>();\n    \n    match error.as_ref() {\n        Some(error) if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                        error.downcast_ref::<InvalidSettingsError>() => {\n        }\n            if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                error.downcast_ref::<InvalidSettingsError>()\n            {\n                // Local settings errors are displayed by the projects\n                return;\n            } else {\n                Some()\n            }\n        }\n    }\n\n    \n    show_app_notification(id, cx, move |cx| {\n    \n\n    for workspace in workspace::local_workspace_windows(cx) {\n        workspace\n            .update(cx, |workspace, _, cx| {\n                match error.as_ref() {\n                    Some(error) => {\n                        if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                            error.downcast_ref::<InvalidSettingsError>()\n                        {\n                            // Local settings will be displayed by the projects\n                        } else {\n                            workspace.show_notification(id.clone(), cx, |cx| {\n                                cx.new(|_cx| {\n<|editable_region_start|>\n                                    MessageNotification::new(format!(\n                                        \"Invalid user settings file\\n{error}\"\n                                    ))\n                                    .with_click_message(\"Open settings file\")\n<|editable_region_end|>\n                                    .on_click(|window, cx| {\n                                        window.dispatch_action(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/workspace/src/searchable.rs\":\n```diff\n@@ -55,7 +55,7 @@\n             regex: true,\n             replacement: true,\n             selection: true,\n-            find_in_results: true,\n+            find_in_results: false,\n         }\n     }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/workspace/src/searchable.rs\n    Next,\n}\n\nimpl Direction {\n    pub fn opposite(&self) -> Self {\n        match self {\n            Direction::Prev => Direction::Next,\n            Direction::Next => Direction::Prev,\n        }\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default)]\npub struct SearchOptions {\n    pub case: bool,\n    pub word: bool,\n    pub regex: bool,\n    /// Specifies whether the  supports search & replace.\n    pub replacement: bool,\n    pub selection: bool,\n    pub find_in_results: bool,\n}\n\npub trait SearchableItem: Item + EventEmitter<SearchEvent> {\n    type Match: Any + Sync + Send + Clone;\n\n    fn supported_options(&self) -> SearchOptions {\n        SearchOptions {\n            case: true,\n            word: true,\n            regex: true,\n<|editable_region_start|>\n            replacement: true,\n    <|user_cursor_is_here|>        selection: true,\n            find_in_results: false,\n        }\n    }\n\n    fn search_bar_visibility_changed(\n        &mut self,\n        _visible: bool,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) {\n    }\n\n    fn has_filtered_search_ranges(&mut self) -> bool {\n        self.supported_options().selection\n    }\n\n<|editable_region_end|>\n    fn toggle_filtered_search_ranges(\n        &mut self,\n        _enabled: bool,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) {\n    }\n\n    fn get_matches(&self, _window: &mut Window, _: &mut App) -> Vec<Self::Match> {\n        Vec::new()\n    }\n    fn clear_matches(&mut self, window: &mut Window, cx: &mut Context<Self>);\n    fn update_matches(\n        &mut self,\n        matches: &[Self::Match],\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    );\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/workspace/src/searchable.rs\n    Next,\n}\n\nimpl Direction {\n    pub fn opposite(&self) -> Self {\n        match self {\n            Direction::Prev => Direction::Next,\n            Direction::Next => Direction::Prev,\n        }\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default)]\npub struct SearchOptions {\n    pub case: bool,\n    pub word: bool,\n    pub regex: bool,\n    /// Specifies whether the  supports search & replace.\n    pub replacement: bool,\n    pub selection: bool,\n    pub find_in_results: bool,\n}\n\npub trait SearchableItem: Item + EventEmitter<SearchEvent> {\n    type Match: Any + Sync + Send + Clone;\n\n    fn supported_options(&self) -> SearchOptions {\n        SearchOptions {\n            case: true,\n            word: true,\n            regex: true,\n<|editable_region_start|>\n            replacement: true,\n            selection: true,\n            find_in_results: false,\n        }\n    }\n\n    fn search_bar_visibility_changed(\n        &mut self,\n        _visible: bool,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) {\n    }\n\n    fn has_filtered_search_ranges(&mut self) -> bool {\n        self.supported_options().selection\n    }\n\n<|editable_region_end|>\n    fn toggle_filtered_search_ranges(\n        &mut self,\n        _enabled: bool,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) {\n    }\n\n    fn get_matches(&self, _window: &mut Window, _: &mut App) -> Vec<Self::Match> {\n        Vec::new()\n    }\n    fn clear_matches(&mut self, window: &mut Window, cx: &mut Context<Self>);\n    fn update_matches(\n        &mut self,\n        matches: &[Self::Match],\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    );\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/terminal_view/src/terminal_panel.rs\":\n```diff\n@@ -909,7 +909,7 @@\n             workspace.clone(),\n             project.clone(),\n             Default::default(),\n-            None,\n+            Some(),\n             NewTerminal.boxed_clone(),\n             window,\n             cx,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/terminal_view/src/terminal_panel.rs\n    fn has_no_terminals(&self, cx: &App) -> bool {\n        self.active_pane.read(cx).items_len() == 0 && self.pending_terminals_to_add == 0\n    }\n\n    pub fn assistant_enabled(&self) -> bool {\n        self.assistant_enabled\n    }\n\n    fn is_enabled(&self, cx: &App) -> bool {\n        self.workspace.upgrade().map_or(false, |workspace| {\n            is_enabled_in_workspace(workspace.read(cx), cx)\n        })\n    }\n}\n\nfn is_enabled_in_workspace(workspace: &Workspace, cx: &App) -> bool {\n    workspace.project().read(cx).supports_terminal(cx)\n}\n\npub fn new_terminal_pane(\n    workspace: WeakEntity<Workspace>,\n    project: Entity<Project>,\n    zoomed: bool,\n    window: &mut Window,\n    cx: &mut Context<TerminalPanel>,\n) -> Entity<Pane> {\n    let is_local = project.read(cx).is_local();\n    let terminal_panel = cx.entity().clone();\n    let pane = cx.new(|cx| {\n        let mut pane = Pane::new(\n            workspace.clone(),\n<|editable_region_start|>\n            project.clone(),\n    <|user_cursor_is_here|>        Default::default(),\n            Some(),\n            NewTerminal.boxed_clone(),\n            window,\n            cx,\n        );\n        pane.set_zoomed(zoomed, cx);\n        pane.set_can_navigate(false, cx);\n        pane.display_nav_history_buttons(None);\n        pane.set_should_display_tab_bar(|_, _| true);\n        pane.set_zoom_out_on_close(false);\n\n        let split_closure_terminal_panel = terminal_panel.downgrade();\n        pane.set_can_split(Some(Arc::new(move |pane, dragged_item, _window, cx| {\n            if let Some(tab) = dragged_item.downcast_ref::<DraggedTab>() {\n                let is_current_pane = tab.pane == cx.entity();\n                let Some(can_drag_away) = split_closure_terminal_panel\n<|editable_region_end|>\n                    .update(cx, |terminal_panel, _| {\n                        let current_panes = terminal_panel.center.panes();\n                        !current_panes.contains(&&tab.pane)\n                            || current_panes.len() > 1\n                            || (!is_current_pane || pane.items_len() > 1)\n                    })\n                    .ok()\n                else {\n                    return false;\n                };\n                if can_drag_away {\n                    let item = if is_current_pane {\n                        pane.item_for_index(tab.ix)\n                    } else {\n                        tab.pane.read(cx).item_for_index(tab.ix)\n                    };\n                    if let Some(item) = item {\n                        return item.downcast::<TerminalView>().is_some();\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/terminal_view/src/terminal_panel.rs\n    fn has_no_terminals(&self, cx: &App) -> bool {\n        self.active_pane.read(cx).items_len() == 0 && self.pending_terminals_to_add == 0\n    }\n\n    pub fn assistant_enabled(&self) -> bool {\n        self.assistant_enabled\n    }\n\n    fn is_enabled(&self, cx: &App) -> bool {\n        self.workspace.upgrade().map_or(false, |workspace| {\n            is_enabled_in_workspace(workspace.read(cx), cx)\n        })\n    }\n}\n\nfn is_enabled_in_workspace(workspace: &Workspace, cx: &App) -> bool {\n    workspace.project().read(cx).supports_terminal(cx)\n}\n\npub fn new_terminal_pane(\n    workspace: WeakEntity<Workspace>,\n    project: Entity<Project>,\n    zoomed: bool,\n    window: &mut Window,\n    cx: &mut Context<TerminalPanel>,\n) -> Entity<Pane> {\n    let is_local = project.read(cx).is_local();\n    let terminal_panel = cx.entity().clone();\n    let pane = cx.new(|cx| {\n        let mut pane = Pane::new(\n            workspace.clone(),\n<|editable_region_start|>\n            project.clone(),\n            Default::default(),\n            Some(),\n            NewTerminal.boxed_clone(),\n            window,\n            cx,\n        );\n        pane.set_zoomed(zoomed, cx);\n        pane.set_can_navigate(false, cx);\n        pane.display_nav_history_buttons(None);\n        pane.set_should_display_tab_bar(|_, _| true);\n        pane.set_zoom_out_on_close(false);\n\n        let split_closure_terminal_panel = terminal_panel.downgrade();\n        pane.set_can_split(Some(Arc::new(move |pane, dragged_item, _window, cx| {\n            if let Some(tab) = dragged_item.downcast_ref::<DraggedTab>() {\n                let is_current_pane = tab.pane == cx.entity();\n                let Some(can_drag_away) = split_closure_terminal_panel\n<|editable_region_end|>\n                    .update(cx, |terminal_panel, _| {\n                        let current_panes = terminal_panel.center.panes();\n                        !current_panes.contains(&&tab.pane)\n                            || current_panes.len() > 1\n                            || (!is_current_pane || pane.items_len() > 1)\n                    })\n                    .ok()\n                else {\n                    return false;\n                };\n                if can_drag_away {\n                    let item = if is_current_pane {\n                        pane.item_for_index(tab.ix)\n                    } else {\n                        tab.pane.read(cx).item_for_index(tab.ix)\n                    };\n                    if let Some(item) = item {\n                        return item.downcast::<TerminalView>().is_some();\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -168,6 +168,7 @@\n     },\n     \"ruff\": {\n       \"settings\": {\n+        \"ruff\": {\n         \"line-length\": 120\n       }\n     },\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n    // \"YAML\": [\"!playbooks/**/*.yml\"],\n    \"JSON\": [\".prettierrc\"],\n    \"JSONC\": [\"**/tsconfig/*.json\"],\n    \"Diff\": [\"diff\", \"patch\"],\n    \"image\": [\"PNG\"]\n  },\n  \"lsp\": {\n    \"ruby-lsp\": {\n      \"initialization_options\": {\n        \"enabledFeatures\": {\n          // This disables diagnostics\n          \"diagnostics\": false\n        }\n<|editable_region_start|>\n      }\n    },\n    \"ruff\": {\n      \"settings\": {\n        \"ruff\": {\n        \"line-length\": 120\n      }\n    },\n    \"json-language-server\": {\n      \"command\": \"/usr/bin/vscode-json-languageserver\",\n      \"args\": [\"--stdio\"],\n      \"settings\": {\n        \"json\": {\n          \"schemas\": [\n            {\n              \"fileMatch\": [\"*/*.luarc.json\"],\n              \"url\": \"https://raw.githubusercontent.com/sumneko/vscode-lua/master/setting/schema.json\"\n            }\n          ]\n        }\n  <|user_cursor_is_here|>    }\n<|editable_region_end|>\n    },\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n    // \"YAML\": [\"!playbooks/**/*.yml\"],\n    \"JSON\": [\".prettierrc\"],\n    \"JSONC\": [\"**/tsconfig/*.json\"],\n    \"Diff\": [\"diff\", \"patch\"],\n    \"image\": [\"PNG\"]\n  },\n  \"lsp\": {\n    \"ruby-lsp\": {\n      \"initialization_options\": {\n        \"enabledFeatures\": {\n          // This disables diagnostics\n          \"diagnostics\": false\n        }\n<|editable_region_start|>\n      }\n    },\n    \"ruff\": {\n      \"settings\": {\n        \"ruff\": {\n          \"line-length\": 120\n        }\n      }\n    },\n    \"json-language-server\": {\n      \"command\": \"/usr/bin/vscode-json-languageserver\",\n      \"args\": [\"--stdio\"],\n      \"settings\": {\n        \"json\": {\n          \"schemas\": [\n            {\n              \"fileMatch\": [\"*/*.luarc.json\"],\n              \"url\": \"https://raw.githubusercontent.com/sumneko/vscode-lua/master/setting/schema.json\"\n            }\n          ]\n        }\n      }\n<|editable_region_end|>\n    },\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/display_map/diff_map.rs\":\n```diff\n@@ -361,7 +361,7 @@\n                         DiffMapOperation::ExpandHunks { ranges } => {\n                             should_expand_hunk |= ranges.iter().any(|range| {\n                                 range.overlaps(\n-                                    &(hunk_start_anchor..hunk_end_anchor),\n+                                    &hunkra,\n                                     &multibuffer_snapshot,\n                                 )\n                             })\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/display_map/diff_map.rs\n                            base_text_byte_range,\n                            ..\n                        } = item\n                        {\n                            if cursor.start().0 == hunk_start_fold_offset\n                                && *base_text_byte_range == hunk.diff_base_byte_range\n                            {\n                                was_previously_expanded = true;\n<|editable_region_start|>\n                            }\n                        }\n                    }\n\n                    let mut should_expand_hunk = was_previously_expanded || self.all_hunks_expanded;\n                    match &operation {\n                        DiffMapOperation::ExpandHunks { ranges } => {\n                            should_expand_hunk |= ranges.iter().any(|range| {\n                                range.overlaps(\n                                    &hunkra,\n                                    &multibuffer_snapshot,\n                                )\n                            })\n                        }\n                        DiffMapOperation::CollapseHunks { ranges } => {\n                            should_expand_hunk &= !ranges.iter().any(|range| {\n                                range.overlaps(\n                                    &(hunk_start_anchor..hunk_end_anchor),\n                                    &multibuffer_snapshot,\n                                )\n                            })\n                        }\n                        _ => {}\n                   <|user_cursor_is_here|> };\n                    if hunk.diff_base_byte_range.len() == 0 {\n<|editable_region_end|>\n                        should_expand_hunk = false;\n                    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/display_map/diff_map.rs\n                            base_text_byte_range,\n                            ..\n                        } = item\n                        {\n                            if cursor.start().0 == hunk_start_fold_offset\n                                && *base_text_byte_range == hunk.diff_base_byte_range\n                            {\n                                was_previously_expanded = true;\n<|editable_region_start|>\n                            }\n                        }\n                    }\n\n                    let mut should_expand_hunk = was_previously_expanded || self.all_hunks_expanded;\n                    match &operation {\n                        DiffMapOperation::ExpandHunks { ranges } => {\n                            should_expand_hunk |= ranges.iter().any(|range| {\n                                range.overlaps(\n                                    &hunk_range,\n                                    &multibuffer_snapshot,\n                                )\n                            })\n                        }\n                        DiffMapOperation::CollapseHunks { ranges } => {\n                            should_expand_hunk &= !ranges.iter().any(|range| {\n                                range.overlaps(\n                                    &hunk_range,\n                                    &multibuffer_snapshot,\n                                )\n                            })\n                        }\n                        _ => {}\n                    };\n                    if hunk.diff_base_byte_range.len() == 0 {\n<|editable_region_end|>\n                        should_expand_hunk = false;\n                    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -6150,7 +6150,7 @@\n         let buffer = &display_map.buffer_snapshot;\n         let selections = self.selections.all::<Point>(cx);\n \n-        if !whole_lines && selections[0].start != selections[0].end {}\n+        if !whole_lines && selections.len() == 1 selections[0].start != selections[0].end {}\n \n         let mut edits = Vec::new();\n         let mut selections_iter = selections.iter().peekable();\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/editor.rs\n            let text = buffer.text_for_range(start..end).collect::<String>();\n            edits.push((selection.end..selection.end, text));\n        }\n\n        self.transact(cx, |this, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n<|editable_region_start|>\n                buffer.edit(edits, None, cx);\n            });\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn duplicate(&mut self, upwards: bool, whole_lines: bool, cx: &mut ViewContext<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let selections = self.selections.all::<Point>(cx);\n\n        if !whole_lines && selections.len() == 1 selections[0].start != selections[0].end {}\n\n        let mut edits = Vec::new();\n        let mut selections_iter = selections.iter().peekable();\n        while let Some(selection) = selections_iter.next() {\n            // Avoid duplicating the same lines twice.\n            let mut rows = selection.spanned_rows(false, &display_map);\n<|user_cursor_is_here|>\n            while let Some(next_selection) = selections_iter.peek() {\n                let next_rows = next_selection.spanned_rows(false, &display_map);\n                if next_rows.start < rows.end {\n                    rows.end = next_rows.end;\n                    selections_iter.next().unwrap();\n                } else {\n                    break;\n                }\n<|editable_region_end|>\n            }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/editor.rs\n            let text = buffer.text_for_range(start..end).collect::<String>();\n            edits.push((selection.end..selection.end, text));\n        }\n\n        self.transact(cx, |this, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n<|editable_region_start|>\n                buffer.edit(edits, None, cx);\n            });\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn duplicate(&mut self, upwards: bool, whole_lines: bool, cx: &mut ViewContext<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let selections = self.selections.all::<Point>(cx);\n\n        if !whole_lines && selections.len() == 1 && selections[0].start != selections[0].end {}\n\n        let mut edits = Vec::new();\n        let mut selections_iter = selections.iter().peekable();\n        while let Some(selection) = selections_iter.next() {\n            // Avoid duplicating the same lines twice.\n            let mut rows = selection.spanned_rows(false, &display_map);\n\n            while let Some(next_selection) = selections_iter.peek() {\n                let next_rows = next_selection.spanned_rows(false, &display_map);\n                if next_rows.start < rows.end {\n                    rows.end = next_rows.end;\n                    selections_iter.next().unwrap();\n                } else {\n                    break;\n                }\n<|editable_region_end|>\n            }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -51,6 +51,6 @@\n \n impl Default for Tab {\n     fn default() -> Self {\n-        Tab::InlineAssist\n+        Tab::InlineCompletion\n     }\n }\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -71,9 +71,10 @@\n         let subscription = cx.observe(&zeta, |_, _, cx| cx.notify());\n         Self {\n             zeta,\n             selected_index: 0,\n             focus_handle: cx.focus_handle(),\n             active_completion: None,\n             _subscription: subscription,\n+            tab: todo!(),\n         }\n     }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/rate_completion_modal.rs\n<|editable_region_start|>\nstruct ActiveCompletion {\n    completion: InlineCompletion,\n    feedback_editor: View<Editor>,\n<|user_cursor_is_here|>}\n\nimpl RateCompletionModal {\n    pub fn toggle(workspace: &mut Workspace, cx: &mut ViewContext<Workspace>) {\n        if let Some(zeta) = Zeta::global(cx) {\n            workspace.toggle_modal(cx, |cx| RateCompletionModal::new(zeta, cx));\n        }\n    }\n\n    pub fn new(zeta: Model<Zeta>, cx: &mut ViewContext<Self>) -> Self {\n        let subscription = cx.observe(&zeta, |_, _, cx| cx.notify());\n        Self {\n            zeta,\n            selected_index: 0,\n            focus_handle: cx.focus_handle(),\n            active_completion: None,\n            _subscription: subscription,\n            tab: todo!(),\n        }\n    }\n\n    fn dismiss(&mut self, _: &menu::Cancel, cx: &mut ViewContext<Self>) {\n        cx.emit(DismissEvent);\n    }\n\n    fn select_next(&mut self, _: &menu::SelectNext, cx: &mut ViewContext<Self>) {\n        self.selected_index += 1;\n        self.selected_index = usize::min(\n            self.selected_index,\n            self.zeta.read(cx).recent_completions().count(),\n        );\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/rate_completion_modal.rs\n<|editable_region_start|>\nstruct ActiveCompletion {\n    completion: InlineCompletion,\n    feedback_editor: View<Editor>,\n}\n\nimpl RateCompletionModal {\n    pub fn toggle(workspace: &mut Workspace, cx: &mut ViewContext<Workspace>) {\n        if let Some(zeta) = Zeta::global(cx) {\n            workspace.toggle_modal(cx, |cx| RateCompletionModal::new(zeta, cx));\n        }\n    }\n\n    pub fn new(zeta: Model<Zeta>, cx: &mut ViewContext<Self>) -> Self {\n        let subscription = cx.observe(&zeta, |_, _, cx| cx.notify());\n        Self {\n            zeta,\n            selected_index: 0,\n            focus_handle: cx.focus_handle(),\n            active_completion: None,\n            _subscription: subscription,\n            tab: Tab::default(),\n        }\n    }\n\n    fn dismiss(&mut self, _: &menu::Cancel, cx: &mut ViewContext<Self>) {\n        cx.emit(DismissEvent);\n    }\n\n    fn select_next(&mut self, _: &menu::SelectNext, cx: &mut ViewContext<Self>) {\n        self.selected_index += 1;\n        self.selected_index = usize::min(\n            self.selected_index,\n            self.zeta.read(cx).recent_completions().count(),\n        );\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/assistant2/src/context_strip.rs\":\n```diff\n@@ -57,7 +57,7 @@\n \n         let focus_handle = cx.focus_handle();\n \n-        let subscriptions = vec![cx.subscribe(&context_picker, Self::handle_context_picker_event);\n+        let subscriptions = vec![cx.subscribe(&context_picker, Self::handle_context_picker_event)\n         cx.on_focus(&focus_handle, Self::handle_focus);\n         cx.on_blur(&focus_handle, Self::handle_blur);\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/assistant2/src/context_strip.rs\n    context_picker_menu_handle: PopoverMenuHandle<ContextPicker>,\n<|editable_region_start|>\n    focus_handle: FocusHandle,\n    suggest_context_kind: SuggestContextKind,\n    workspace: WeakView<Workspace>,\n    subscriptions: Vec<Subscription>,\n    focused_index: Option<usize>,\n<|user_cursor_is_here|>}\n\nimpl ContextStrip {\n    pub fn new(\n        context_store: Model<ContextStore>,\n        workspace: WeakView<Workspace>,\n        thread_store: Option<WeakModel<ThreadStore>>,\n        // TODO az remove\n        focus_handle: FocusHandle,\n        context_picker_menu_handle: PopoverMenuHandle<ContextPicker>,\n        suggest_context_kind: SuggestContextKind,\n        cx: &mut ViewContext<Self>,\n    ) -> Self {\n        let context_picker = cx.new_view(|cx| {\n            ContextPicker::new(\n                workspace.clone(),\n                thread_store.clone(),\n                context_store.downgrade(),\n                ConfirmBehavior::KeepOpen,\n                cx,\n            )\n        });\n\n        let focus_handle = cx.focus_handle();\n\n        let subscriptions = vec![\n            cx.subscribe(&context_picker, Self::handle_context_picker_event),\n            cx.on_focus(&focus_handle, Self::handle_focus),\n            cx.on_blur(&focus_handle, Self::handle_blur)\n        ];\n\n        Self {\n            context_store: context_store.clone(),\n            context_picker,\n            context_picker_menu_handle,\n            focus_handle,\n            suggest_context_kind,\n            workspace,\n            _subscriptions: subscriptions,\n            focused_index: None,\n        }\n    }\n\n    fn suggested_context(&self, cx: &ViewContext<Self>) -> Option<SuggestedContext> {\n        match self.suggest_context_kind {\n            SuggestContextKind::File => self.suggested_file(cx),\n            SuggestContextKind::Thread => self.suggested_thread(cx),\n        }\n    }\n\n    fn suggested_file(&self, cx: &ViewContext<Self>) -> Option<SuggestedContext> {\n        let workspace = self.workspace.upgrade()?;\n        let active_item = workspace.read(cx).active_item(cx)?;\n\n        let editor = active_item.to_any().downcast::<Editor>().ok()?.read(cx);\n        let active_buffer_model = editor.buffer().read(cx).as_singleton()?;\n        let active_buffer = active_buffer_model.read(cx);\n\n        let path = active_buffer.file()?.path();\n\n        if self\n<|editable_region_end|>\n            .context_store\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/assistant2/src/context_strip.rs\n    context_picker_menu_handle: PopoverMenuHandle<ContextPicker>,\n<|editable_region_start|>\n    focus_handle: FocusHandle,\n    suggest_context_kind: SuggestContextKind,\n    workspace: WeakView<Workspace>,\n    subscriptions: Vec<Subscription>,\n    focused_index: Option<usize>,\n}\n\nimpl ContextStrip {\n    pub fn new(\n        context_store: Model<ContextStore>,\n        workspace: WeakView<Workspace>,\n        thread_store: Option<WeakModel<ThreadStore>>,\n        // TODO az remove\n        focus_handle: FocusHandle,\n        context_picker_menu_handle: PopoverMenuHandle<ContextPicker>,\n        suggest_context_kind: SuggestContextKind,\n        cx: &mut ViewContext<Self>,\n    ) -> Self {\n        let context_picker = cx.new_view(|cx| {\n            ContextPicker::new(\n                workspace.clone(),\n                thread_store.clone(),\n                context_store.downgrade(),\n                ConfirmBehavior::KeepOpen,\n                cx,\n            )\n        });\n\n        let focus_handle = cx.focus_handle();\n\n        let subscriptions = vec![cx.subscribe(&context_picker, Self::handle_context_picker_event)\n        cx.on_focus(&focus_handle, Self::handle_focus);\n        cx.on_blur(&focus_handle, Self::handle_blur);\n\n\n        Self {\n            context_store: context_store.clone(),\n            context_picker,\n            context_picker_menu_handle,\n            focus_handle,\n            suggest_context_kind,\n            workspace,\n            _subscriptions: subscriptions,\n            focused_index: None,\n        }\n    }\n\n    fn suggested_context(&self, cx: &ViewContext<Self>) -> Option<SuggestedContext> {\n        match self.suggest_context_kind {\n            SuggestContextKind::File => self.suggested_file(cx),\n            SuggestContextKind::Thread => self.suggested_thread(cx),\n        }\n    }\n\n    fn suggested_file(&self, cx: &ViewContext<Self>) -> Option<SuggestedContext> {\n        let workspace = self.workspace.upgrade()?;\n        let active_item = workspace.read(cx).active_item(cx)?;\n\n        let editor = active_item.to_any().downcast::<Editor>().ok()?.read(cx);\n        let active_buffer_model = editor.buffer().read(cx).as_singleton()?;\n        let active_buffer = active_buffer_model.read(cx);\n\n        let path = active_buffer.file()?.path();\n\n        if self\n<|editable_region_end|>\n            .context_store\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"untitled\":\n```diff\n@@ -110,7 +110,7 @@\n     const users = userService.getAllUsers();\n \n     users.forEach(user => {\n-      if (user.status === 'suspended' || user.status === 'inactive' || !user.preferences.emailNotifications) {\n+      if ( || user.status === 'inactive' || !user.preferences.emailNotifications) {\n         return;\n       }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```untitled\n  getUsersByAgeRange(minAge: number, maxAge: number): User[] {\n    return this.getAllUsers().filter(\n      user => user.age >= minAge && user.age <= maxAge\n    );\n  }\n\n  updateUserStatus(id: number, newStatus: User['status']): User | undefined {\n    return this.updateUser(id, { status: newStatus });\n  }\n}\n\nclass NotificationService {\n<|editable_region_start|>\n  private emailQueue: string[];\n  private pushQueue: string[];\n<|user_cursor_is_here|>\n  constructor() {\n    this.emailQueue = [];\n    this.pushQueue = [];\n  }\n\n  addEmailNotification(userId: number, message: string): void {\n    this.emailQueue.push(`User ${userId}: ${message}`);\n  }\n\n  addPushNotification(userId: number, message: string): void {\n    this.pushQueue.push(`User ${userId}: ${message}`);\n  }\n\n  processNotifications(userService: UserService): void {\n    const users = userService.getAllUsers();\n<|editable_region_end|>\n\n    users.forEach(user => {\n      if ( || user.status === 'inactive' || !user.preferences.emailNotifications) {\n        return;\n      }\n\n      this.processUserNotifications(user);\n    });\n  }\n\n  private processUserNotifications(user: User): void {\n    const emailNotifications = this.emailQueue\n      .filter(notification => notification.startsWith(`User ${user.id}:`));\n\n    const pushNotifications = this.pushQueue\n      .filter(notification => notification.startsWith(`User ${user.id}:`));\n\n    if (user.preferences.emailNotifications) {\n      this.sendEmailNotifications(user.email, emailNotifications);\n    }\n\n    if (user.preferences.pushNotifications) {\n      this.sendPushNotifications(user.id, pushNotifications);\n    }\n  }\n\n  private sendEmailNotifications(email: string, notifications: string[]): void {\n    notifications.forEach(notification => {\n      console.log(`Sending email to ${email}: ${notification}`);\n    });\n  }\n\n  private sendPushNotifications(userId: number, notifications: string[]): void {\n    notifications.forEach(notification => {\n      console.log(`Sending push notification to user ${userId}: ${notification}`);\n    });\n```"}, {"role": "assistant", "content": "Suggestion:\n```untitled\n  getUsersByAgeRange(minAge: number, maxAge: number): User[] {\n    return this.getAllUsers().filter(\n      user => user.age >= minAge && user.age <= maxAge\n    );\n  }\n\n  updateUserStatus(id: number, newStatus: User['status']): User | undefined {\n    return this.updateUser(id, { status: newStatus });\n  }\n}\n\nclass NotificationService {\n<|editable_region_start|>\n  private emailQueue: string[];\n  private pushQueue: string[];\n  \n  constructor() {\n    this.emailQueue = [];\n    this.pushQueue = [];\n  }\n\n  addEmailNotification(userId: number, message: string): void {\n    this.emailQueue.push(`User ${userId}: ${message}`);\n  }\n\n  addPushNotification(userId: number, message: string): void {\n    this.pushQueue.push(`User ${userId}: ${message}`);\n  }\n\n  processNotifications(userService: UserService): void {\n    const users = userService.getAllUsers();\n<|editable_region_end|>\n\n    users.forEach(user => {\n      if ( || user.status === 'inactive' || !user.preferences.emailNotifications) {\n        return;\n      }\n\n      this.processUserNotifications(user);\n    });\n  }\n\n  private processUserNotifications(user: User): void {\n    const emailNotifications = this.emailQueue\n      .filter(notification => notification.startsWith(`User ${user.id}:`));\n\n    const pushNotifications = this.pushQueue\n      .filter(notification => notification.startsWith(`User ${user.id}:`));\n\n    if (user.preferences.emailNotifications) {\n      this.sendEmailNotifications(user.email, emailNotifications);\n    }\n\n    if (user.preferences.pushNotifications) {\n      this.sendPushNotifications(user.id, pushNotifications);\n    }\n  }\n\n  private sendEmailNotifications(email: string, notifications: string[]): void {\n    notifications.forEach(notification => {\n      console.log(`Sending email to ${email}: ${notification}`);\n    });\n  }\n\n  private sendPushNotifications(userId: number, notifications: string[]): void {\n    notifications.forEach(notification => {\n      console.log(`Sending push notification to user ${userId}: ${notification}`);\n    });\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/collab/src/llm.rs\":\n```diff\n@@ -474,7 +474,7 @@\n         &state.http_client,\n         api_url,\n         api_key,\n-        open_ai::CompletionRequest {\n+        fireworks::CompletionRequest {\n             model: model.to_string(),\n             prompt: prompt.clone(),\n             max_tokens: 2048,\n\n```\n\nUser edited \"crates/collab/src/llm.rs\":\n```diff\n@@ -479,7 +479,7 @@\n             prompt: prompt.clone(),\n             max_tokens: 2048,\n             temperature: 0.,\n-            prediction: Some(open_ai::Prediction::Content {\n+            prediction: Some(fire::Prediction::Content {\n                 content: params.input_excerpt,\n             }),\n             rewrite_speculation: Some(true),\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/collab/src/llm.rs\n        .prediction_api_url\n        .as_ref()\n        .context(\"no PREDICTION_API_URL configured on the server\")?;\n    let api_key = state\n        .config\n        .prediction_api_key\n        .as_ref()\n<|editable_region_start|>\n        .context(\"no PREDICTION_API_KEY configured on the server\")?;\n    let model = state\n        .config\n        .prediction_model\n        .as_ref()\n        .context(\"no PREDICTION_MODEL configured on the server\")?;\n\n    let outline_prefix = params\n        .outline\n        .as_ref()\n        .map(|outline| format!(\"### Outline for current file:\\n{}\\n\", outline))\n        .unwrap_or_default();\n\n    let prompt = include_str!(\"./llm/prediction_prompt.md\")\n        .replace(\"<outline>\", &outline_prefix)\n        .replace(\"<events>\", &params.input_events)\n        .replace(\"<excerpt>\", &params.input_excerpt);\n    let mut response = fireworks::complete_text(\n        &state.http_client,\n        api_url,\n        api_key,\n        fireworks::CompletionRequest {\n            model: model.to_string(),\n            prompt: prompt.clone(),\n            max_tokens: 2048,\n            temperature: 0.,\n            prediction: Some(fire::Prediction::Content {\n                content: params.input_excerpt,\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await?;\n    let choice = response\n        .choices\n        .pop()\n        .context(\"no output from completion response\")?;\n    Ok(Json(PredictEditsResponse {\n        output_excerpt: choice.text,\n    }))\n}\n<|user_cursor_is_here|>\n/// The maximum monthly spending an individual user can reach on the free tier\n/// before they have to pay.\npub const FREE_TIER_MONTHLY_SPENDING_LIMIT: Cents = Cents::from_dollars(10);\n\n/// The default value to use for maximum spend per month if the user did not\n/// explicitly set a maximum spend.\n///\n/// Used to prevent surprise bills.\npub const DEFAULT_MAX_MONTHLY_SPEND: Cents = Cents::from_dollars(10);\n\nasync fn check_usage_limit(\n<|editable_region_end|>\n    state: &Arc<LlmState>,\n    provider: LanguageModelProvider,\n    model_name: &str,\n    claims: &LlmTokenClaims,\n) -> Result<()> {\n    if claims.is_staff {\n        return Ok(());\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/collab/src/llm.rs\n        .prediction_api_url\n        .as_ref()\n        .context(\"no PREDICTION_API_URL configured on the server\")?;\n    let api_key = state\n        .config\n        .prediction_api_key\n        .as_ref()\n<|editable_region_start|>\n        .context(\"no PREDICTION_API_KEY configured on the server\")?;\n    let model = state\n        .config\n        .prediction_model\n        .as_ref()\n        .context(\"no PREDICTION_MODEL configured on the server\")?;\n\n    let outline_prefix = params\n        .outline\n        .as_ref()\n        .map(|outline| format!(\"### Outline for current file:\\n{}\\n\", outline))\n        .unwrap_or_default();\n\n    let prompt = include_str!(\"./llm/prediction_prompt.md\")\n        .replace(\"<outline>\", &outline_prefix)\n        .replace(\"<events>\", &params.input_events)\n        .replace(\"<excerpt>\", &params.input_excerpt);\n    let mut response = fireworks::complete_text(\n        &state.http_client,\n        api_url,\n        api_key,\n        fireworks::CompletionRequest {\n            model: model.to_string(),\n            prompt: prompt.clone(),\n            max_tokens: 2048,\n            temperature: 0.,\n            prediction: Some(fireworks::Prediction::Content {\n                content: params.input_excerpt,\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await?;\n    let choice = response\n        .choices\n        .pop()\n        .context(\"no output from completion response\")?;\n    Ok(Json(PredictEditsResponse {\n        output_excerpt: choice.text,\n    }))\n}\n\n/// The maximum monthly spending an individual user can reach on the free tier\n/// before they have to pay.\npub const FREE_TIER_MONTHLY_SPENDING_LIMIT: Cents = Cents::from_dollars(10);\n\n/// The default value to use for maximum spend per month if the user did not\n/// explicitly set a maximum spend.\n///\n/// Used to prevent surprise bills.\npub const DEFAULT_MAX_MONTHLY_SPEND: Cents = Cents::from_dollars(10);\n\nasync fn check_usage_limit(\n<|editable_region_end|>\n    state: &Arc<LlmState>,\n    provider: LanguageModelProvider,\n    model_name: &str,\n    claims: &LlmTokenClaims,\n) -> Result<()> {\n    if claims.is_staff {\n        return Ok(());\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/collab/src/llm.rs\":\n```diff\n@@ -488,6 +488,7 @@\n         },\n     )\n     .await?;\n+    let duration = start.elapsed();\n \n     state.executor.spawn_detached({\n         let kinesis_client = state.kinesis_client.clone();\n\n```\n\nUser edited \"crates/collab/src/llm.rs\":\n```diff\n@@ -505,6 +505,7 @@\n                 json!({\n                     \"model\": model.to_string(),\n                     \"headers\": headers,\n+                    \"dura\n                 }),\n             )\n             .write(&kinesis_client, &kinesis_stream)\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/collab/src/llm.rs\n<|editable_region_start|>\n    let mut response = fireworks::complete(\n        &state.http_client,\n        api_url,\n        api_key,\n        fireworks::CompletionRequest {\n            model: model.to_string(),\n            prompt: prompt.clone(),\n            max_tokens: 2048,\n            temperature: 0.,\n            prediction: Some(fireworks::Prediction::Content {\n                content: params.input_excerpt,\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await?;\n    let duration = start.elapsed();\n\n    state.executor.spawn_detached({\n        let kinesis_client = state.kinesis_client.clone();\n        let kinesis_stream = state.config.kinesis_stream.clone();\n        let headers = response.headers.clone();\n        let model = model.clone();\n\n        async move {\n            SnowflakeRow::new(\n                \"Fireworks Completion Requested\",\n                claims.metrics_id,\n                claims.is_staff,\n                claims.system_id.clone(),\n                json!({\n                    \"model\": model.to_string(),\n                    \"headers\": headers,\n                    \"dura\n                }),\n            )\n            .write(&kinesis_client, &kinesis_stream)\n            .await\n            .log_err();\n        }\n    });\n\n    let choice = response\n        .completion\n        .choices\n        .pop()\n        .context(\"no output from completion response\")?;\n    Ok(Json(PredictEditsResponse {\n        output_excerpt: choice.text,\n    }))\n}\n<|user_cursor_is_here|>\n/// The maximum monthly spending an individual user can reach on the free tier\n/// before they have to pay.\npub const FREE_TIER_MONTHLY_SPENDING_LIMIT: Cents = Cents::from_dollars(10);\n\n/// The default value to use for maximum spend per month if the user did not\n/// explicitly set a maximum spend.\n///\n/// Used to prevent surprise bills.\n<|editable_region_end|>\npub const DEFAULT_MAX_MONTHLY_SPEND: Cents = Cents::from_dollars(10);\n\nasync fn check_usage_limit(\n    state: &Arc<LlmState>,\n    provider: LanguageModelProvider,\n    model_name: &str,\n    claims: &LlmTokenClaims,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/collab/src/llm.rs\n<|editable_region_start|>\n    let mut response = fireworks::complete(\n        &state.http_client,\n        api_url,\n        api_key,\n        fireworks::CompletionRequest {\n            model: model.to_string(),\n            prompt: prompt.clone(),\n            max_tokens: 2048,\n            temperature: 0.,\n            prediction: Some(fireworks::Prediction::Content {\n                content: params.input_excerpt,\n            }),\n            rewrite_speculation: Some(true),\n        },\n    )\n    .await?;\n    let duration = start.elapsed();\n\n    state.executor.spawn_detached({\n        let kinesis_client = state.kinesis_client.clone();\n        let kinesis_stream = state.config.kinesis_stream.clone();\n        let headers = response.headers.clone();\n        let model = model.clone();\n\n        async move {\n            SnowflakeRow::new(\n                \"Fireworks Completion Requested\",\n                claims.metrics_id,\n                claims.is_staff,\n                claims.system_id.clone(),\n                json!({\n                    \"model\": model.to_string(),\n                    \"headers\": headers,\n                    \"duration\": duration.as_millis()\n                }),\n            )\n            .write(&kinesis_client, &kinesis_stream)\n            .await\n            .log_err();\n        }\n    });\n\n    let choice = response\n        .completion\n        .choices\n        .pop()\n        .context(\"no output from completion response\")?;\n    Ok(Json(PredictEditsResponse {\n        output_excerpt: choice.text,\n    }))\n}\n\n/// The maximum monthly spending an individual user can reach on the free tier\n/// before they have to pay.\npub const FREE_TIER_MONTHLY_SPENDING_LIMIT: Cents = Cents::from_dollars(10);\n\n/// The default value to use for maximum spend per month if the user did not\n/// explicitly set a maximum spend.\n///\n/// Used to prevent surprise bills.\n<|editable_region_end|>\npub const DEFAULT_MAX_MONTHLY_SPEND: Cents = Cents::from_dollars(10);\n\nasync fn check_usage_limit(\n    state: &Arc<LlmState>,\n    provider: LanguageModelProvider,\n    model_name: &str,\n    claims: &LlmTokenClaims,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1212,7 +1212,7 @@\n                                     SelectedFormatter::Auto => {\n                                         // do the auto-format: prefer prettier, fallback to primary language server\n                                         let diff = {\n-                                            if dbg!(prettier_settings.allowed {\n+                                            if dbg!(prettier_settings.allowed) {\n                                                 Self::perform_format(\n                                                     &Formatter::Prettier,\n                                                     buffer,\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1199,6 +1199,7 @@\n                 }\n             };\n             dbg!(&settings.formatter);\n+            dbg!(&\n             let mut format_operations: Vec<FormatOperation> = vec![];\n             {\n                 match trigger {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/lsp_store.rs\n                    &buffer.handle,\n<|editable_region_start|>\n                    push_to_history,\n                    &mut project_transaction,\n                    &mut cx,\n                )\n                .await?;\n    <|user_cursor_is_here|>        }\n\n            // Apply language-specific formatting using either the primary language server\n            // or external command.\n            // Except for code actions, which are applied with all connected language servers.\n            let primary_language_server =\n                primary_adapter_and_server.map(|(_adapter, server)| server.clone());\n            let primary_server_and_path = primary_language_server\n                .as_ref()\n                .zip(buffer.abs_path.as_ref());\n\n            let prettier_settings = buffer.handle.read_with(&cx, |buffer, cx| {\n                language_settings(buffer.language().map(|l| l.name()), buffer.file(), cx)\n                    .prettier\n                    .clone()\n            })?;\n\n            let ranges = match target {\n                LspFormatTarget::Buffers => None,\n                LspFormatTarget::Ranges(ranges) => {\n                    let Some(ranges) = ranges.get(&buffer.id) else {\n                        return Err(anyhow!(\"No format ranges provided for buffer\"));\n                    };\n                    Some(ranges)\n                }\n            };\n            dbg!(&settings.formatter);\n            dbg!(&\n            let mut format_operations: Vec<FormatOperation> = vec![];\n            {\n                match trigger {\n                    FormatTrigger::Save => {\n                        match &settings.format_on_save {\n                            FormatOnSave::Off => {\n                                // nothing\n                            }\n                            FormatOnSave::On => {\n                                match &settings.formatter {\n                                    SelectedFormatter::Auto => {\n                                        // do the auto-format: prefer prettier, fallback to primary language server\n                                        let diff = {\n                                            if dbg!(prettier_settings.allowed) {\n                                                Self::perform_format(\n                                                    &Formatter::Prettier,\n                                                    buffer,\n                                                    ranges,\n                                                    primary_server_and_path,\n                                                    lsp_store.clone(),\n                                                    &settings,\n                                                    &adapters_and_servers,\n                                                    push_to_history,\n                                                    &mut project_transaction,\n                                                    &mut cx,\n                                                )\n                                                .await\n                                            } else {\n                                                println!(\"using language server\");\n                                                Self::perform_format(\n                                                    &Formatter::LanguageServer { name: None },\n                                                    buffer,\n<|editable_region_end|>\n                                                    ranges,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/lsp_store.rs\n                    &buffer.handle,\n<|editable_region_start|>\n                    push_to_history,\n                    &mut project_transaction,\n                    &mut cx,\n                )\n                .await?;\n            }\n\n            // Apply language-specific formatting using either the primary language server\n            // or external command.\n            // Except for code actions, which are applied with all connected language servers.\n            let primary_language_server =\n                primary_adapter_and_server.map(|(_adapter, server)| server.clone());\n            let primary_server_and_path = primary_language_server\n                .as_ref()\n                .zip(buffer.abs_path.as_ref());\n\n            let prettier_settings = buffer.handle.read_with(&cx, |buffer, cx| {\n                language_settings(buffer.language().map(|l| l.name()), buffer.file(), cx)\n                    .prettier\n                    .clone()\n            })?;\n\n            let ranges = match target {\n                LspFormatTarget::Buffers => None,\n                LspFormatTarget::Ranges(ranges) => {\n                    let Some(ranges) = ranges.get(&buffer.id) else {\n                        return Err(anyhow!(\"No format ranges provided for buffer\"));\n                    };\n                    Some(ranges)\n                }\n            };\n            dbg!(&settings.formatter);\n            dbg!(&prettier_settings);\n            let mut format_operations: Vec<FormatOperation> = vec![];\n            {\n                match trigger {\n                    FormatTrigger::Save => {\n                        match &settings.format_on_save {\n                            FormatOnSave::Off => {\n                                // nothing\n                            }\n                            FormatOnSave::On => {\n                                match &settings.formatter {\n                                    SelectedFormatter::Auto => {\n                                        // do the auto-format: prefer prettier, fallback to primary language server\n                                        let diff = {\n                                            if dbg!(prettier_settings.allowed) {\n                                                Self::perform_format(\n                                                    &Formatter::Prettier,\n                                                    buffer,\n                                                    ranges,\n                                                    primary_server_and_path,\n                                                    lsp_store.clone(),\n                                                    &settings,\n                                                    &adapters_and_servers,\n                                                    push_to_history,\n                                                    &mut project_transaction,\n                                                    &mut cx,\n                                                )\n                                                .await\n                                            } else {\n                                                println!(\"using language server\");\n                                                Self::perform_format(\n                                                    &Formatter::LanguageServer { name: None },\n                                                    buffer,\n<|editable_region_end|>\n                                                    ranges,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/rate_completion_element.rs\":\n```diff\n@@ -28,7 +28,7 @@\n             .text_for_range(completion.excerpt_range.clone())\n             .collect::<String>();\n \n-        let mut cursor_offset_in_text = None;\n+        let mut cursor_offset_in_diff = None;\n         let mut delta = 0;\n         let mut diff_highlights = Vec::new();\n         for (old_range, new_text) in completion.edits.iter() {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/rate_completion_element.rs\nuse settings::Settings;\nuse theme::ThemeSettings;\nuse ui::{prelude::*, KeyBinding, Tooltip};\n\npub struct RateCompletionElement {\n    element: AnyElement,\n    text_layout: TextLayout,\n}\n\nimpl RateCompletionElement {\n    fn new(\n        completion: &InlineCompletion,\n        feedback_editor: &View<Editor>,\n<|editable_region_start|>\n        focus_handle: &FocusHandle,\n        rated: bool,\n        cx: &mut ViewContext<RateCompletionModal>,\n    ) -> Self {\n        let mut diff = completion\n            .snapshot\n            .text_for_range(completion.excerpt_range.clone())\n            .collect::<String>();\n\n        let mut cursor_offset_in_diff = None;\n        let mut delta = 0;\n        let mut diff_highlights = Vec::new();\n        for (old_range, new_text) in completion.edits.iter() {\n            let old_range = old_range.to_offset(&completion.snapshot);\n\n            if cursor_offset_in_text.is_none() && completion.cursor_offset <= old_range.end {\n                cursor_offset_in_text =\n                    Some(completion.cursor_offset - completion.excerpt_range.start + delta);\n            }\n\n            let old_start_in_text = old_range.start - completion.excerpt_range.start + delta;\n            let old_end_in_text = old_range.end - completion.excerpt_range.start + delta;\n            if old_start_in_text < old_end_in_text {\n                diff_highlights.push((\n                    old_start_in_text..old_end_in_text,\n                    HighlightStyle {\n                        background_color: Some(cx.theme().status().deleted_background),\n                        strikethrough: Some(gpui::StrikethroughStyle {\n                            thickness: px(1.),\n                            color: Some(cx.theme().colors().text_muted),\n                        }),\n                        ..Default::default()\n                    },\n                ));\n            }\n<|user_cursor_is_here|>\n            if !new_text.is_empty() {\n                diff.insert_str(old_end_in_text, new_text);\n                diff_highlights.push((\n                    old_end_in_text..old_end_in_text + new_text.len(),\n                    HighlightStyle {\n                        background_color: Some(cx.theme().status().created_background),\n                        ..Default::default()\n                    },\n                ));\n                delta += new_text.len();\n            }\n        }\n\n        let settings = ThemeSettings::get_global(cx).clone();\n        let text_style = TextStyle {\n<|editable_region_end|>\n            color: cx.theme().colors().editor_foreground,\n            font_size: settings.buffer_font_size(cx).into(),\n            font_family: settings.buffer_font.family,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/rate_completion_element.rs\nuse settings::Settings;\nuse theme::ThemeSettings;\nuse ui::{prelude::*, KeyBinding, Tooltip};\n\npub struct RateCompletionElement {\n    element: AnyElement,\n    text_layout: TextLayout,\n}\n\nimpl RateCompletionElement {\n    fn new(\n        completion: &InlineCompletion,\n        feedback_editor: &View<Editor>,\n<|editable_region_start|>\n        focus_handle: &FocusHandle,\n        rated: bool,\n        cx: &mut ViewContext<RateCompletionModal>,\n    ) -> Self {\n        let mut diff = completion\n            .snapshot\n            .text_for_range(completion.excerpt_range.clone())\n            .collect::<String>();\n\n        let mut cursor_offset_in_diff = None;\n        let mut delta = 0;\n        let mut diff_highlights = Vec::new();\n        for (old_range, new_text) in completion.edits.iter() {\n            let old_range = old_range.to_offset(&completion.snapshot);\n\n            if cursor_offset_in_diff.is_none() && completion.cursor_offset <= old_range.end {\n                cursor_offset_in_diff =\n                    Some(completion.cursor_offset - completion.excerpt_range.start + delta);\n            }\n\n            let old_start_in_text = old_range.start - completion.excerpt_range.start + delta;\n            let old_end_in_text = old_range.end - completion.excerpt_range.start + delta;\n            if old_start_in_text < old_end_in_text {\n                diff_highlights.push((\n                    old_start_in_text..old_end_in_text,\n                    HighlightStyle {\n                        background_color: Some(cx.theme().status().deleted_background),\n                        strikethrough: Some(gpui::StrikethroughStyle {\n                            thickness: px(1.),\n                            color: Some(cx.theme().colors().text_muted),\n                        }),\n                        ..Default::default()\n                    },\n                ));\n            }\n\n            if !new_text.is_empty() {\n                diff.insert_str(old_end_in_text, new_text);\n                diff_highlights.push((\n                    old_end_in_text..old_end_in_text + new_text.len(),\n                    HighlightStyle {\n                        background_color: Some(cx.theme().status().created_background),\n                        ..Default::default()\n                    },\n                ));\n                delta += new_text.len();\n            }\n        }\n\n        let settings = ThemeSettings::get_global(cx).clone();\n        let text_style = TextStyle {\n<|editable_region_end|>\n            color: cx.theme().colors().editor_foreground,\n            font_size: settings.buffer_font_size(cx).into(),\n            font_family: settings.buffer_font.family,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -1070,7 +1070,7 @@\n                         let snapshot = buffer.read(cx).snapshot();\n                         if new_completion.should_replace_completion(&old_completion, &snapshot) {\n                             this.zeta.update(cx, |zeta, _cx| {\n-                                zeta.completion_shown(&new_completion);\n+                                zeta.completion_shown(&new_completion,);\n                             });\n                             this.current_completion = Some(new_completion);\n                         }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/zeta.rs\n                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n            }\n\n            let completion_request = this.update(&mut cx, |this, cx| {\n                this.zeta.update(cx, |zeta, cx| {\n                    zeta.request_completion(&buffer, position, cx)\n                })\n            });\n\n            let completion = match completion_request {\n                Ok(completion_request) => {\n                    let completion_request = completion_request.await;\n                    completion_request.map(|completion| CurrentInlineCompletion {\n<|editable_region_start|>\n                        buffer_id: buffer.entity_id(),\n                        completion,\n                    })\n                }\n                Err(error) => Err(error),\n            };\n\n            this.update(&mut cx, |this, cx| {\n                if this.pending_completions[0].id == pending_completion_id {\n                    this.pending_completions.remove(0);\n                } else {\n                    this.pending_completions.clear();\n                }\n\n                if let Some(new_completion) = completion.context(\"zeta prediction failed\").log_err()\n                {\n                    if let Some(old_completion) = this.current_completion.as_ref() {\n                        let snapshot = buffer.read(cx).snapshot();\n                        if new_completion.should_replace_completion(&old_completion, &snapshot) {\n                            this.zeta.update(cx, |zeta, _cx| {\n                                zeta.completion_shown(&new_completion,);\n                            });\n                            this.current_completion = Some(new_completion);\n                        }\n                    } else {\n                        this.zeta.update(cx, |zeta, _cx| {\n                            zeta.completion_shown(&new_completion);\n                        });\n                        this.current_completion = Some(new_completion);\n                    }\n                }\n\n                cx.notify();\n            })\n            .ok();\n     <|user_cursor_is_here|>   });\n\n        // We always maintain at most two pending completions. When we already\n        // have two, we replace the newest one.\n        if self.pending_completions.len() <= 1 {\n            self.pending_completions.push(PendingCompletion {\n                id: pending_completion_id,\n                _task: task,\n            });\n        } else if self.pending_completions.len() == 2 {\n            self.pending_completions.pop();\n            self.pending_completions.push(PendingCompletion {\n                id: pending_completion_id,\n                _task: task,\n            });\n        }\n<|editable_region_end|>\n    }\n\n    fn cycle(\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/zeta.rs\n                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n            }\n\n            let completion_request = this.update(&mut cx, |this, cx| {\n                this.zeta.update(cx, |zeta, cx| {\n                    zeta.request_completion(&buffer, position, cx)\n                })\n            });\n\n            let completion = match completion_request {\n                Ok(completion_request) => {\n                    let completion_request = completion_request.await;\n                    completion_request.map(|completion| CurrentInlineCompletion {\n<|editable_region_start|>\n                        buffer_id: buffer.entity_id(),\n                        completion,\n                    })\n                }\n                Err(error) => Err(error),\n            };\n\n            this.update(&mut cx, |this, cx| {\n                if this.pending_completions[0].id == pending_completion_id {\n                    this.pending_completions.remove(0);\n                } else {\n                    this.pending_completions.clear();\n                }\n\n                if let Some(new_completion) = completion.context(\"zeta prediction failed\").log_err()\n                {\n                    if let Some(old_completion) = this.current_completion.as_ref() {\n                        let snapshot = buffer.read(cx).snapshot();\n                        if new_completion.should_replace_completion(&old_completion, &snapshot) {\n                            this.zeta.update(cx, |zeta, _cx| {\n                                zeta.completion_shown(&new_completion, &snapshot);\n                            });\n                            this.current_completion = Some(new_completion);\n                        }\n                    } else {\n                        this.zeta.update(cx, |zeta, _cx| {\n                            zeta.completion_shown(&new_completion, &snapshot);\n                        });\n                        this.current_completion = Some(new_completion);\n                    }\n                }\n\n                cx.notify();\n            })\n            .ok();\n        });\n\n        // We always maintain at most two pending completions. When we already\n        // have two, we replace the newest one.\n        if self.pending_completions.len() <= 1 {\n            self.pending_completions.push(PendingCompletion {\n                id: pending_completion_id,\n                _task: task,\n            });\n        } else if self.pending_completions.len() == 2 {\n            self.pending_completions.pop();\n            self.pending_completions.push(PendingCompletion {\n                id: pending_completion_id,\n                _task: task,\n            });\n        }\n<|editable_region_end|>\n    }\n\n    fn cycle(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/code_context_menus.rs\":\n```diff\n@@ -461,7 +461,7 @@\n \n                     len\n                 }\n-                CompletionEntry::InlineCompletionHint(hint) => hint.labe,\n+                CompletionEntry::InlineCompletionHint(hint) => hint.label().chars().count(),\n             })\n             .map(|(ix, _)| ix);\n         drop(completions);\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -465,6 +465,8 @@\n     None,\n }\n \n+impl \n+\n #[derive(Clone, Debug)]\n enum InlineCompletionText {\n     Move(SharedString),\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/editor.rs\n    let show_background = language_settings::language_settings(None, None, cx)\n        .inlay_hints\n        .show_background;\n\n    HighlightStyle {\n        color: Some(cx.theme().status().hint),\n        background_color: show_background.then(|| cx.theme().status().hint_background),\n<|editable_region_start|>\n        ..HighlightStyle::default()\n    }\n}\n\npub fn make_suggestion_styles(cx: &WindowContext) -> InlineCompletionStyles {\n    InlineCompletionStyles {\n        insertion: HighlightStyle {\n            color: Some(cx.theme().status().predictive),\n            ..HighlightStyle::default()\n        },\n        whitespace: HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..HighlightStyle::default()\n        },\n    }\n}\n\ntype CompletionId = usize;\n\n#[derive(Debug, Clone)]\nenum InlineCompletionMenuHint {\n    Loading,\n    Loaded { text: InlineCompletionText },\n    None,\n}\n\nimpl \n\n#[derive(Clone, Debug)]\nenum InlineCompletionText {\n    Move(SharedString),\n    Edit {\n        text: SharedString,\n        highlights: Vec<(Range<usize>, HighlightStyle)>,\n    },\n}\n\nenum InlineCompletion {\n    Edit(Vec<(Range<Anchor>, String)>),\n    Move(Anchor),\n}\n<|user_cursor_is_here|>\nstruct InlineCompletionState {\n    inlay_ids: Vec<InlayId>,\n    completion: InlineCompletion,\n    invalidation_range: Range<Anchor>,\n}\n\nenum InlineCompletionHighlight {}\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Default)]\nstruct EditorActionId(usize);\n\n<|editable_region_end|>\nimpl EditorActionId {\n    pub fn post_inc(&mut self) -> Self {\n        let answer = self.0;\n\n        *self = Self(answer + 1);\n\n        Self(answer)\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/editor.rs\n    let show_background = language_settings::language_settings(None, None, cx)\n        .inlay_hints\n        .show_background;\n\n    HighlightStyle {\n        color: Some(cx.theme().status().hint),\n        background_color: show_background.then(|| cx.theme().status().hint_background),\n<|editable_region_start|>\n        ..HighlightStyle::default()\n    }\n}\n\npub fn make_suggestion_styles(cx: &WindowContext) -> InlineCompletionStyles {\n    InlineCompletionStyles {\n        insertion: HighlightStyle {\n            color: Some(cx.theme().status().predictive),\n            ..HighlightStyle::default()\n        },\n        whitespace: HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..HighlightStyle::default()\n        },\n    }\n}\n\ntype CompletionId = usize;\n\n#[derive(Debug, Clone)]\nenum InlineCompletionMenuHint {\n    Loading,\n    Loaded { text: InlineCompletionText },\n    None,\n}\n\nimpl InlineCompletionMenuHint {\n    fn label(&self) -> &str {\n        match self {\n            InlineCompletionMenuHint::Loading => \"Loading...\",\n            InlineCompletionMenuHint::Loaded { text } => text.label(),\n            InlineCompletionMenuHint::None => \"No Suggestion\",\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum InlineCompletionText {\n    Move(SharedString),\n    Edit {\n        text: SharedString,\n        highlights: Vec<(Range<usize>, HighlightStyle)>,\n    },\n}\n\nenum InlineCompletion {\n    Edit(Vec<(Range<Anchor>, String)>),\n    Move(Anchor),\n}\n\nstruct InlineCompletionState {\n    inlay_ids: Vec<InlayId>,\n    completion: InlineCompletion,\n    invalidation_range: Range<Anchor>,\n}\n\nenum InlineCompletionHighlight {}\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Default)]\nstruct EditorActionId(usize);\n\n<|editable_region_end|>\nimpl EditorActionId {\n    pub fn post_inc(&mut self) -> Self {\n        let answer = self.0;\n\n        *self = Self(answer + 1);\n\n        Self(answer)\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/chunk.rs\":\n```diff\n@@ -21,7 +21,7 @@\n     }\n     \n     #[inline(always)]\n-    fn \n+    fn p\n \n     #[inline(always)]\n     fn push_str(&mut self, text: &str) {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/chunk.rs\n<|start_of_file|>\nuse crate::{OffsetUtf16, Point, PointUtf16};\nuse arrayvec::ArrayString;\nuse std::{cmp, ops::Range};\nuse util::debug_panic;\n\n#[derive(Clone, Debug, Default)]\nstruct Chunk<const CAPACITY: usize> {\n    chars: usize,\n    chars_utf16: usize,\n    tabs: usize,\n    newlines: usize,\n    text: ArrayString<CAPACITY>,\n}\n\nimpl<const CAPACITY: usize> Chunk<CAPACITY> {\n<|editable_region_start|>\n    #[inline(always)]\n    fn new(text: &str) -> Self {\n        let mut this = Chunk::default();\n        this.push_str(text);\n        this\n    }\n    \n    #[inline(always)]\n    fn p\n\n    #[inline(always)]\n    fn push_str(&mut self, text: &str) {\n        for (char_ix, c) in text.char_indices() {\n            let ix = self.text.len() + char_ix;\n            self.chars |= 1 << ix;\n            self.chars_utf16 |= 1 << ix;\n            self.chars_utf16 |= c.len_utf16() << ix;\n            self.tabs |= ((c == '\\t') as usize) << ix;\n            self.newlines |= ((c == '\\n') as usize) << ix;\n        }\n        self.text.push_str(text);\n    }\n\n    #[inline(always)]\n    pub fn as_slice(&self) -> ChunkRef {\n        ChunkRef {\n            chars: self.chars,\n            chars_utf16: self.chars_utf16,\n            tabs: self.tabs,\n            newlines: self.newlines,\n      <|user_cursor_is_here|>      text: &self.text,\n<|editable_region_end|>\n        }\n    }\n\n    #[inline(always)]\n    pub fn slice(&self, range: Range<usize>) -> ChunkRef {\n        self.as_slice().slice(range)\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct ChunkRef<'a> {\n    chars: usize,\n    chars_utf16: usize,\n    tabs: usize,\n    newlines: usize,\n    text: &'a str,\n}\n\nimpl<'a> ChunkRef<'a> {\n    #[inline(always)]\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/chunk.rs\n<|start_of_file|>\nuse crate::{OffsetUtf16, Point, PointUtf16};\nuse arrayvec::ArrayString;\nuse std::{cmp, ops::Range};\nuse util::debug_panic;\n\n#[derive(Clone, Debug, Default)]\nstruct Chunk<const CAPACITY: usize> {\n    chars: usize,\n    chars_utf16: usize,\n    tabs: usize,\n    newlines: usize,\n    text: ArrayString<CAPACITY>,\n}\n\nimpl<const CAPACITY: usize> Chunk<CAPACITY> {\n<|editable_region_start|>\n    #[inline(always)]\n    fn new(text: &str) -> Self {\n        let mut this = Chunk::default();\n        this.push_str(text);\n        this\n    }\n    \n    #[inline(always)]\n    fn push(&mut self, c: char) {\n        let ix = self.text.len();\n        self.chars |= 1 << ix;\n        self.chars_utf16 |= 1 << ix;\n        self.chars_utf16 |= c.len_utf16() << ix;\n        self.tabs |= ((c == '\\t') as usize) << ix;\n        self.newlines |= ((c == '\\n') as usize) << ix;\n        self.text.push(c);\n    }\n\n    #[inline(always)]\n    fn push_str(&mut self, text: &str) {\n        for (char_ix, c) in text.char_indices() {\n            let ix = self.text.len() + char_ix;\n            self.chars |= 1 << ix;\n            self.chars_utf16 |= 1 << ix;\n            self.chars_utf16 |= c.len_utf16() << ix;\n            self.tabs |= ((c == '\\t') as usize) << ix;\n            self.newlines |= ((c == '\\n') as usize) << ix;\n        }\n        self.text.push_str(text);\n    }\n\n    #[inline(always)]\n    pub fn as_slice(&self) -> ChunkRef {\n        ChunkRef {\n            chars: self.chars,\n            chars_utf16: self.chars_utf16,\n            tabs: self.tabs,\n            newlines: self.newlines,\n            text: &self.text,\n<|editable_region_end|>\n        }\n    }\n\n    #[inline(always)]\n    pub fn slice(&self, range: Range<usize>) -> ChunkRef {\n        self.as_slice().slice(range)\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct ChunkRef<'a> {\n    chars: usize,\n    chars_utf16: usize,\n    tabs: usize,\n    newlines: usize,\n    text: &'a str,\n}\n\nimpl<'a> ChunkRef<'a> {\n    #[inline(always)]\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \".config/hammerspoon/config/uielements.lua\":\n```diff\n@@ -274,10 +274,7 @@\n \n hs.hotkey.bind({ \"cmd\", \"alt\", \"ctrl\" }, \"S\", function()\n     -- [S]earch menu items\n-    if printWebView then\n-        printHtmlBuffer = {}\n-    end\n-    ensureWebview()\n+    ensureClearedWebView()\n \n     local app = hs.application.frontmostApplication()\n     print(\"starting potentially slow element search of: \" .. app:name())\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```.config/hammerspoon/config/uielements.lua\n        -- TODO handle other hammerspoon userdata types\n        return referenceName .. hs.inspect(userdata) .. \" - TODO add this hs type to inspectHTML\"\n    end\n\n    if value == nil then\n        return \"nil\"\n    elseif type(value) == \"table\" then\n<|editable_region_start|>\n        return _inspectTable(value)\n    elseif type(value) == \"string\" then\n        return value\n    elseif type(value) == \"number\" or type(value) == \"boolean\" then\n        return tostring(value)\n    elseif type(value) == \"userdata\" then\n        return _inspectUserData(value)\n    else\n        return hs.inspect(value)\n    end\nend\n\nfunction DumpHtml(value)\n    prints(InspectHtml(value))\nend\n\nlocal function ensureClearedWebView()\n    if printWebView then\n        printHtmlBuffer = {}\n    end\n    ensureWebview()\nend\n\nhs.hotkey.bind({ \"cmd\", \"alt\", \"ctrl\" }, \"S\", function()\n    -- [S]earch menu items\n    ensureClearedWebView()\n\n    local app = hs.application.frontmostApplication()\n    print(\"starting potentially slow element search of: \" .. app:name())\n\n    local menuItems = app:findMenuItem(\"Activity Monitor\", true)\n    DumpHtml(menuItems)\n\n    -- BUT IMO is easier just to use elementSearch (which I bet is used under the hood here too on findMenuItem.. as does I bet getMenuItems use elementSearch, IIGC)\n    -- DumpHtml(menuItems)\n\n    -- PRN anything worth doing to enumerate the menus?\n    -- for _, item in ipairs(menuItems) do\n    --     -- local title = GetValueOrEmptyString(item)\n    --     prints(hs.inspect(item), \"<br>\")\n    -- <|user_cursor_is_here|>end\nend)\n\n\nhs.hotkey.bind({ \"cmd\", \"alt\", \"ctrl\" }, \"M\", function()\n    -- USEFUL to quick check for a menu item\n    -- TODO try axuielement.elementSearch and see how it compares vs this... (should have more attribute info avail)\n    --   - IIAC it might find more menus (i.e. context  menus?)\n    -- TODO for each menu item => generate AppleScript or hammerspoon lua code to invoke this menu item?\n    -- FYI could use this to replace app - Paletro\n    if printWebView then\n        printHtmlBuffer = {}\n<|editable_region_end|>\n    end\n    ensureWebview()\n\n    local app = hs.application.frontmostApplication()\n    print(\"starting potentially slow element search of: \" .. app:name())\n    -- FYI can use app:getMenuItems(callback) instead (called when done, non-blocking too) - callback gets same object and then the return here is the app object (when cb provided)\n    local menuItems = app:getMenuItems()\n```"}, {"role": "assistant", "content": "Suggestion:\n```.config/hammerspoon/config/uielements.lua\n        -- TODO handle other hammerspoon userdata types\n        return referenceName .. hs.inspect(userdata) .. \" - TODO add this hs type to inspectHTML\"\n    end\n\n    if value == nil then\n        return \"nil\"\n    elseif type(value) == \"table\" then\n<|editable_region_start|>\n        return _inspectTable(value)\n    elseif type(value) == \"string\" then\n        return value\n    elseif type(value) == \"number\" or type(value) == \"boolean\" then\n        return tostring(value)\n    elseif type(value) == \"userdata\" then\n        return _inspectUserData(value)\n    else\n        return hs.inspect(value)\n    end\nend\n\nfunction DumpHtml(value)\n    prints(InspectHtml(value))\nend\n\nlocal function ensureClearedWebView()\n    if printWebView then\n        printHtmlBuffer = {}\n    end\n    ensureWebview()\nend\n\nhs.hotkey.bind({ \"cmd\", \"alt\", \"ctrl\" }, \"S\", function()\n    -- [S]earch menu items\n    ensureClearedWebView()\n\n    local app = hs.application.frontmostApplication()\n    print(\"starting potentially slow element search of: \" .. app:name())\n\n    local menuItems = app:findMenuItem(\"Activity Monitor\", true)\n    DumpHtml(menuItems)\n\n    -- BUT IMO is easier just to use elementSearch (which I bet is used under the hood here too on findMenuItem.. as does I bet getMenuItems use elementSearch, IIGC)\n    -- DumpHtml(menuItems)\n\n    -- PRN anything worth doing to enumerate the menus?\n    -- for _, item in ipairs(menuItems) do\n    --     -- local title = GetValueOrEmptyString(item)\n    --     prints(hs.inspect(item), \"<br>\")\n    -- end\nend)\n\n\nhs.hotkey.bind({ \"cmd\", \"alt\", \"ctrl\" }, \"M\", function()\n    -- USEFUL to quick check for a menu item\n    -- TODO try axuielement.elementSearch and see how it compares vs this... (should have more attribute info avail)\n    --   - IIAC it might find more menus (i.e. context  menus?)\n    -- TODO for each menu item => generate AppleScript or hammerspoon lua code to invoke this menu item?\n    -- FYI could use this to replace app - Paletro\n    if printWebView then\n        printHtmlBuffer = {}\n<|editable_region_end|>\n    end\n    ensureWebview()\n\n    local app = hs.application.frontmostApplication()\n    print(\"starting potentially slow element search of: \" .. app:name())\n    -- FYI can use app:getMenuItems(callback) instead (called when done, non-blocking too) - callback gets same object and then the return here is the app object (when cb provided)\n    local menuItems = app:getMenuItems()\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"lib/src/clock.h\":\n```diff\n@@ -21,7 +21,9 @@\n   return micros * (uint64_t)frequency.QuadPart / 1000000;\n }\n \n-static inline TSDuration duratin_from_millis\n+static inline TSDuration duration_from_millis(uint64_t millis) {\n+  return duration_from_micros(millis * 1000);\n+}\n \n static inline uint64_t duration_to_micros(TSDuration self) {\n   LARGE_INTEGER frequency;\n\n```\n\nUser edited \"lib/src/clock.h\":\n```diff\n@@ -31,6 +31,8 @@\n   return self * 1000000 / (uint64_t)frequency.QuadPart;\n }\n \n+\n+\n static inline TSClock clock_null(void) {\n   return 0;\n }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```lib/src/clock.h\n#ifdef _WIN32\n\n// Windows:\n<|editable_region_start|>\n// * Represent a time as a performance counter value.\n// * Represent a duration as a number of performance counter ticks.\n\n#include <windows.h>\ntypedef uint64_t TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return micros * (uint64_t)frequency.QuadPart / 1000000;\n}\n\nstatic inline TSDuration duration_from_millis(uint64_t millis) {\n  return duration_from_micros(millis * 1000);\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return self * 1000000 / (uint64_t)frequency.QuadPart;\n}\n\n\n\nstatic inline TSClock clock_null(void) {\n  return 0;\n}<|user_cursor_is_here|>\n\nstatic inline TSClock clock_now(void) {\n  LARGE_INTEGER result;\n  QueryPerformanceCounter(&result);\n  return (uint64_t)result.QuadPart;\n}\n\nstatic inline TSClock clock_after(TSClock base, TSDuration duration) {\n  return base + duration;\n}\n\nstatic inline bool clock_is_null(TSClock self) {\n  return !self;\n}\n\n<|editable_region_end|>\nstatic inline bool clock_is_gt(TSClock self, TSClock other) {\n  return self > other;\n}\n\n#elif defined(CLOCK_MONOTONIC) && !defined(__APPLE__)\n\n// POSIX with monotonic clock support (Linux)\n// * Represent a time as a monotonic (seconds, nanoseconds) pair.\n// * Represent a duration as a number of microseconds.\n//\n// On these platforms, parse timeouts will correspond accurately to\n// real time, regardless of what other processes are running.\n\n#include <time.h>\ntypedef struct timespec TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  return micros;\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  return self;\n```"}, {"role": "assistant", "content": "Suggestion:\n```lib/src/clock.h\n#ifdef _WIN32\n\n// Windows:\n<|editable_region_start|>\n// * Represent a time as a performance counter value.\n// * Represent a duration as a number of performance counter ticks.\n\n#include <windows.h>\ntypedef uint64_t TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return micros * (uint64_t)frequency.QuadPart / 1000000;\n}\n\nstatic inline TSDuration duration_from_millis(uint64_t millis) {\n  return duration_from_micros(millis * 1000);\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return self * 1000000 / (uint64_t)frequency.QuadPart;\n}\n\nstatic inline uint64_t duration_to_millis(TSDuration self) {\n  return duration_to_micros(self) / 1000;\n}\n\nstatic inline TSClock clock_null(void) {\n  return 0;\n}\n\nstatic inline TSClock clock_now(void) {\n  LARGE_INTEGER result;\n  QueryPerformanceCounter(&result);\n  return (uint64_t)result.QuadPart;\n}\n\nstatic inline TSClock clock_after(TSClock base, TSDuration duration) {\n  return base + duration;\n}\n\nstatic inline bool clock_is_null(TSClock self) {\n  return !self;\n}\n\n<|editable_region_end|>\nstatic inline bool clock_is_gt(TSClock self, TSClock other) {\n  return self > other;\n}\n\n#elif defined(CLOCK_MONOTONIC) && !defined(__APPLE__)\n\n// POSIX with monotonic clock support (Linux)\n// * Represent a time as a monotonic (seconds, nanoseconds) pair.\n// * Represent a duration as a number of microseconds.\n//\n// On these platforms, parse timeouts will correspond accurately to\n// real time, regardless of what other processes are running.\n\n#include <time.h>\ntypedef struct timespec TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  return micros;\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  return self;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -543,9 +543,6 @@\n             loop {\n                 let request_builder = http_client::Request::builder().method(Method::POST);\n                 let request_builder = if is_staff {\n-                        // Start dogfooding the new LLM worker for staff edit predictions.\n-                        // \n-                        // \n                     request_builder.uri(\n                         \"https://llm-worker-production.zed-industries.workers.dev/predict_edits\",\n                     )\n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -17,6 +17,10 @@\n         .await\n }\n \n+struct Config {\n+    \n+}\n+\n #[derive(Debug, Serialize, Deserialize)]\n struct IndexResponse {}\n \n\n```\n\n\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -17,10 +17,6 @@\n         .await\n }\n \n-struct Config {\n-    \n-}\n-\n #[derive(Debug, Serialize, Deserialize)]\n struct IndexResponse {}\n \n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -36,6 +36,8 @@\n     pub output_excerpt: String,\n }\n \n+fn v\n+\n async fn handle_predict_edits(mut req: Request, cx: RouteContext<()>) -> Result<Response> {\n     let Some(authorization) = req.headers().get(\"authorization\")? else {\n         return Response::error(\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/llm_worker/src/llm_worker.rs\nuse telemetry_sink::{SnowflakeTelemetryEvent, SnowflakeTelemetrySink};\n<|editable_region_start|>\nuse worker::*;\n\nuse crate::token::{LlmTokenClaims, LlmTokenSecret, ValidateLlmTokenError};\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _cx: worker::Context) -> Result<Response> {\n    Router::new()\n        .get(\"/\", handle_index)\n        .post_async(\"/predict_edits\", handle_predict_edits)\n        .run(req, env)\n        .await\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct IndexResponse {}\n\nfn handle_index(_req: Request, _cx: RouteContext<()>) -> Result<Response> {\n    Response::from_json(&IndexResponse {})\n}\n\n#[derive(Debug, Deserialize)]\nstruct PredictEditsBody {\n    pub outline: Option<String>,\n    pub input_events: String,\n    pub input_excerpt: String,\n}\n\n#[derive(Debug, Serialize)]\nstruct PredictEditsResponse {\n    pub output_excerpt: String,\n}\n\nfn v<|user_cursor_is_here|>\n\nasync fn handle_predict_edits(mut req: Request, cx: RouteContext<()>) -> Result<Response> {\n    let Some(authorization) = req.headers().get(\"authorization\")? else {\n        return Response::error(\n            StatusCode::UNAUTHORIZED.as_str(),\n            StatusCode::UNAUTHORIZED.as_u16(),\n        );\n    };\n\n    let parts = authorization.split_whitespace().collect::<Vec<_>>();\n    if parts.len() != 2 || parts[0].to_lowercase() != \"bearer\" {\n        return Response::error(\n            \"Invalid authorization header\",\n            StatusCode::UNAUTHORIZED.as_u16(),\n        );\n    }\n\n    let token = parts[1];\n\n    let llm_token_secret = LlmTokenSecret(cx.secret(\"LLM_API_SECRET\")?.to_string());\n\n    let claims = match LlmTokenClaims::validate(token, &llm_token_secret) {\n        Ok(claims) => claims,\n        Err(err) => match err {\n            ValidateLlmTokenError::Expired => {\n                return Ok(Response::builder()\n                    .with_status(StatusCode::UNAUTHORIZED.as_u16())\n                    .with_header(\"x-zed-expired-token\", \"true\")?\n                    .fixed(StatusCode::UNAUTHORIZED.as_str().as_bytes().to_vec()))\n            }\n            ValidateLlmTokenError::JwtParseError(_)\n            | ValidateLlmTokenError::JwtValidationError(_)\n<|editable_region_end|>\n            | ValidateLlmTokenError::Other(_) => {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/llm_worker/src/llm_worker.rs\nuse telemetry_sink::{SnowflakeTelemetryEvent, SnowflakeTelemetrySink};\n<|editable_region_start|>\nuse worker::*;\n\nuse crate::token::{LlmTokenClaims, LlmTokenSecret, ValidateLlmTokenError};\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _cx: worker::Context) -> Result<Response> {\n    Router::new()\n        .get(\"/\", handle_index)\n        .post_async(\"/predict_edits\", handle_predict_edits)\n        .run(req, env)\n        .await\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct IndexResponse {}\n\nfn handle_index(_req: Request, _cx: RouteContext<()>) -> Result<Response> {\n    Response::from_json(&IndexResponse {})\n}\n\n#[derive(Debug, Deserialize)]\nstruct PredictEditsBody {\n    pub outline: Option<String>,\n    pub input_events: String,\n    pub input_excerpt: String,\n}\n\n#[derive(Debug, Serialize)]\nstruct PredictEditsResponse {\n    pub output_excerpt: String,\n}\n\nfn validate_request(req: &Request, cx: &RouteContext<()>) -> Result<LlmTokenClaims> {\n    let Some(authorization) = req.headers().get(\"authorization\")? else {\n        return Err(Error::from(Response::error(\n            StatusCode::UNAUTHORIZED.as_str(),\n            StatusCode::UNAUTHORIZED.as_u16(),\n        )));\n    };\n\n    let parts = authorization.split_whitespace().collect::<Vec<_>>();\n    if parts.len() != 2 || parts[0].to_lowercase() != \"bearer\" {\n        return Err(Error::from(Response::error(\n            \"Invalid authorization header\",\n            StatusCode::UNAUTHORIZED.as_u16(),\n        )));\n    }\n\n    let token = parts[1];\n    let llm_token_secret = LlmTokenSecret(cx.secret(\"LLM_API_SECRET\")?.to_string());\n\n    match LlmTokenClaims::validate(token, &llm_token_secret) {\n        Ok(claims) => Ok(claims),\n        Err(ValidateLlmTokenError::Expired) => {\n            Err(Error::from(Response::builder()\n                .with_status(StatusCode::UNAUTHORIZED.as_u16())\n                .with_header(\"x-zed-expired-token\", \"true\")?\n                .fixed(StatusCode::UNAUTHORIZED.as_str().as_bytes().to_vec())))\n        }\n        Err(err) => Err(Error::from(Response::error(\n            format!(\"Failed to validate token: {}\", err),\n            StatusCode::UNAUTHORIZED.as_u16(),\n        ))),\n    }\n}\n\nasync fn handle_predict_edits(mut req: Request, cx: RouteContext<()>) -> Result<Response> {\n    let Some(authorization) = req.headers().get(\"authorization\")? else {\n        return Response::error(\n            StatusCode::UNAUTHORIZED.as_str(),\n            StatusCode::UNAUTHORIZED.as_u16(),\n        );\n    };\n\n    let parts = authorization.split_whitespace().collect::<Vec<_>>();\n    if parts.len() != 2 || parts[0].to_lowercase() != \"bearer\" {\n        return Response::error(\n            \"Invalid authorization header\",\n            StatusCode::UNAUTHORIZED.as_u16(),\n        );\n    }\n\n    let token = parts[1];\n\n    let llm_token_secret = LlmTokenSecret(cx.secret(\"LLM_API_SECRET\")?.to_string());\n\n    let claims = match LlmTokenClaims::validate(token, &llm_token_secret) {\n        Ok(claims) => claims,\n        Err(err) => match err {\n            ValidateLlmTokenError::Expired => {\n                return Ok(Response::builder()\n                    .with_status(StatusCode::UNAUTHORIZED.as_u16())\n                    .with_header(\"x-zed-expired-token\", \"true\")?\n                    .fixed(StatusCode::UNAUTHORIZED.as_str().as_bytes().to_vec()))\n            }\n            ValidateLlmTokenError::JwtParseError(_)\n            | ValidateLlmTokenError::JwtValidationError(_)\n<|editable_region_end|>\n            | ValidateLlmTokenError::Other(_) => {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -202,7 +202,7 @@\n         match self {\n             Ok(value) => Some(value),\n             Err(error) => {\n-                log_error_with_caller(*Location::caller(), error, level);\n+                console_error!(\"Error: {error:?}\");\n                 None\n             }\n         }\n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -194,7 +194,7 @@\n     fn log_err(self) -> Option<Self::Ok>;\n }\n \n-impl<T, E> ResultExt<E> for Result<T, E>\n+impl<T, E> WorkerResultExt<E> for Result<T, E>\n where\n     E: std::fmt::Debug,\n {\n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -188,13 +188,13 @@\n     Response::from_json(&PredictEditsResponse { output_excerpt })\n }\n \n-trait WorkerResultExt {\n+trait ResultExt {\n     type Ok;\n \n     fn log_err(self) -> Option<Self::Ok>;\n }\n \n-impl<T, E> WorkerResultExt<E> for Result<T, E>\n+impl<T, E> ResultExt<E> for std::result::Result<T, E>\n where\n     E: std::fmt::Debug,\n {\n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -198,6 +198,8 @@\n where\n     E: std::fmt::Debug,\n {\n+    type Ok = T;\n+\n     fn log_err(self) -> Option<Self::Ok> {\n         match self {\n             Ok(value) => Some(value),\n\n```\n\nUser edited \"crates/llm_worker/src/llm_worker.rs\":\n```diff\n@@ -188,7 +188,7 @@\n     Response::from_json(&PredictEditsResponse { output_excerpt })\n }\n \n-trait ResultExt {\n+trait ResultExt<E {\n     type Ok;\n \n     fn log_err(self) -> Option<Self::Ok>;\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/llm_worker/src/llm_worker.rs\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration,\n            \"prompt\": prompt,\n            \"input_excerpt\": request_body.input_excerpt,\n            \"input_events\": request_body.input_events,\n            \"outline\": request_body.outline,\n            \"output\": output_excerpt.clone(),\n            \"is_sampled\": true,\n        })\n    } else {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n<|editable_region_start|>\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration,\n            \"is_sampled\": false,\n        })\n    };\n\n    match telemetry_sink\n        .write(SnowflakeTelemetryEvent::new(\n            \"Fireworks Completion Requested\",\n            claims.metrics_id,\n            claims.is_staff,\n            claims.system_id,\n            properties,\n        ))\n        .await\n    {\n        Ok(_) => {}\n        Err(err) => {\n            console_error!(\"Failed to write telemetry event: {err:?}\");\n        }\n    }\n\n    Response::from_json(&PredictEditsResponse { output_excerpt })\n}\n\ntrait ResultExt<E<|user_cursor_is_here|> {\n    type Ok;\n\n    fn log_err(self) -> Option<Self::Ok>;\n}\n\nimpl<T, E> ResultExt<E> for std::result::Result<T, E>\nwhere\n    E: std::fmt::Debug,\n{\n    type Ok = T;\n\n    fn log_err(self) -> Option<Self::Ok> {\n<|editable_region_end|>\n        match self {\n            Ok(value) => Some(value),\n            Err(error) => {\n                console_error!(\"Error: {error:?}\");\n                None\n            }\n        }\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/llm_worker/src/llm_worker.rs\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration,\n            \"prompt\": prompt,\n            \"input_excerpt\": request_body.input_excerpt,\n            \"input_events\": request_body.input_events,\n            \"outline\": request_body.outline,\n            \"output\": output_excerpt.clone(),\n            \"is_sampled\": true,\n        })\n    } else {\n        json!({\n            \"source\": \"llm_worker\",\n            \"model\": model.to_string(),\n<|editable_region_start|>\n            \"headers\": response.headers,\n            \"usage\": response.completion.usage,\n            \"duration\": request_duration,\n            \"is_sampled\": false,\n        })\n    };\n\n    match telemetry_sink\n        .write(SnowflakeTelemetryEvent::new(\n            \"Fireworks Completion Requested\",\n            claims.metrics_id,\n            claims.is_staff,\n            claims.system_id,\n            properties,\n        ))\n        .await\n    {\n        Ok(_) => {}\n        Err(err) => {\n            console_error!(\"Failed to write telemetry event: {err:?}\");\n        }\n    }\n\n    Response::from_json(&PredictEditsResponse { output_excerpt })\n}\n\ntrait ResultExt {\n    type Ok;\n\n    fn log_err(self) -> Option<Self::Ok>;\n}\n\nimpl<T, E> ResultExt for std::result::Result<T, E>\nwhere\n    E: std::fmt::Debug,\n{\n    type Ok = T;\n\n    fn log_err(self) -> Option<Self::Ok> {\n<|editable_region_end|>\n        match self {\n            Ok(value) => Some(value),\n            Err(error) => {\n                console_error!(\"Error: {error:?}\");\n                None\n            }\n        }\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/telemetry_sink/src/telemetry_sink.rs\":\n```diff\n@@ -15,6 +15,8 @@\n     pub insert_id: Option<String>,\n }\n \n+\n+\n impl SnowflakeTelemetryEvent {\n     pub fn new(\n         event_type: impl Into<String>,\n\n```\n\nUser edited \"crates/telemetry_sink/src/telemetry_sink.rs\":\n```diff\n@@ -15,7 +15,7 @@\n     pub insert_id: Option<String>,\n }\n \n-\n+fn add\n \n impl SnowflakeTelemetryEvent {\n     pub fn new(\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/telemetry_sink/src/telemetry_sink.rs\n<|start_of_file|>\nuse anyhow::{Context as _, Result};\nuse reqwest::header;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse uuid::Uuid;\n<|editable_region_start|>\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SnowflakeTelemetryEvent {\n    pub time: chrono::DateTime<chrono::Utc>,\n    pub user_id: Option<String>,\n    pub device_id: Option<String>,\n    pub event_type: String,\n    pub event_properties: serde_json::Value,\n    pub user_properties: Option<serde_json::Value>,\n    pub insert_id: Option<String>,\n}\n\nfn add<|user_cursor_is_here|>\n\nimpl SnowflakeTelemetryEvent {\n    pub fn new(\n        event_type: impl Into<String>,\n        metrics_id: Uuid,\n        is_staff: bool,\n        system_id: Option<String>,\n        event_properties: serde_json::Value,\n    ) -> Self {\n        Self {\n            time: chrono::Utc::now(),\n            event_type: event_type.into(),\n            device_id: system_id,\n            user_id: Some(metrics_id.to_string()),\n            insert_id: Some(uuid::Uuid::new_v4().to_string()),\n            event_properties,\n            user_properties: Some(json!({ \"is_staff\": is_staff })),\n        }\n    }\n}\n\npub struct SnowflakeTelemetrySink {\n    http_client: reqwest::Client,\n    base_url: String,\n    admin_api_token: String,\n}\n\nimpl SnowflakeTelemetrySink {\n    pub fn new(base_url: impl Into<String>, admin_api_token: impl Into<String>) -> Self {\n        Self {\n            http_client: reqwest::Client::new(),\n            base_url: base_url.into(),\n            admin_api_token: admin_api_token.into(),\n        }\n    }\n\n    pub async fn write(&self, row: SnowflakeTelemetryEvent) -> Result<()> {\n        self.http_client\n            .post(format!(\"{}/snowflake/events\", self.base_url))\n            .header(\n                header::AUTHORIZATION,\n                format!(\"token {}\", self.admin_api_token),\n            )\n            .header(header::CONTENT_TYPE, \"application/json\")\n            .body(serde_json::to_string(&row)?)\n            .send()\n            .await\n<|editable_region_end|>\n            .context(\"failed to write event to Snowflake\")?\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/telemetry_sink/src/telemetry_sink.rs\n<|start_of_file|>\nuse anyhow::{Context as _, Result};\nuse reqwest::header;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse uuid::Uuid;\n<|editable_region_start|>\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SnowflakeTelemetryEvent {\n    pub time: chrono::DateTime<chrono::Utc>,\n    pub user_id: Option<String>,\n    pub device_id: Option<String>,\n    pub event_type: String,\n    pub event_properties: serde_json::Value,\n    pub user_properties: Option<serde_json::Value>,\n    pub insert_id: Option<String>,\n}\n\nfn add_event(event: SnowflakeTelemetryEvent) -> Result<()> {\n    Ok(())\n}\n\nimpl SnowflakeTelemetryEvent {\n    pub fn new(\n        event_type: impl Into<String>,\n        metrics_id: Uuid,\n        is_staff: bool,\n        system_id: Option<String>,\n        event_properties: serde_json::Value,\n    ) -> Self {\n        Self {\n            time: chrono::Utc::now(),\n            event_type: event_type.into(),\n            device_id: system_id,\n            user_id: Some(metrics_id.to_string()),\n            insert_id: Some(uuid::Uuid::new_v4().to_string()),\n            event_properties,\n            user_properties: Some(json!({ \"is_staff\": is_staff })),\n        }\n    }\n}\n\npub struct SnowflakeTelemetrySink {\n    http_client: reqwest::Client,\n    base_url: String,\n    admin_api_token: String,\n}\n\nimpl SnowflakeTelemetrySink {\n    pub fn new(base_url: impl Into<String>, admin_api_token: impl Into<String>) -> Self {\n        Self {\n            http_client: reqwest::Client::new(),\n            base_url: base_url.into(),\n            admin_api_token: admin_api_token.into(),\n        }\n    }\n\n    pub async fn write(&self, row: SnowflakeTelemetryEvent) -> Result<()> {\n        self.http_client\n            .post(format!(\"{}/snowflake/events\", self.base_url))\n            .header(\n                header::AUTHORIZATION,\n                format!(\"token {}\", self.admin_api_token),\n            )\n            .header(header::CONTENT_TYPE, \"application/json\")\n            .body(serde_json::to_string(&row)?)\n            .send()\n            .await\n<|editable_region_end|>\n            .context(\"failed to write event to Snowflake\")?\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -113,7 +113,9 @@\n                                         client,\n                                         worktree_id,\n                                         work_directory_id,\n-                                    } => client.request(proto::Sta),\n+                                    } => client.request(proto::Stage {\n+                                        \n+                                    }),\n                                 }\n                                 Ok(())\n                             }\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -114,7 +114,7 @@\n                                         worktree_id,\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n-                                        \n+                                        //\n                                     }),\n                                 }\n                                 Ok(())\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -114,7 +114,9 @@\n                                         worktree_id,\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n-                                        //\n+                                        //,\n+                                        //,\n+                                        //,\n                                     }),\n                                 }\n                                 Ok(())\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -12,6 +12,7 @@\n     App, AppContext as _, Context, Entity, EventEmitter, SharedString, Subscription, WeakEntity,\n };\n use language::{Buffer, LanguageRegistry};\n+use rpc::proto;\n use settings::WorktreeId;\n use std::sync::Arc;\n use text::Rope;\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -115,9 +115,7 @@\n                                         worktree_id,\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n-                                        //,\n-                                        //,\n-                                        //,\n+                                        \n                                     }),\n                                 }\n                                 Ok(())\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -115,7 +115,10 @@\n                                         worktree_id,\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n-                                        \n+                                        project_id: todo!(),\n+                                        worktree_id: todo!(),\n+                                        work_directory_id: todo!(),\n+                                        paths: todo!(),\n                                     }),\n                                 }\n                                 Ok(())\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -115,7 +115,7 @@\n                                         worktree_id,\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n-                                        project_id: todo!(),\n+                                        project_id: todo!(\"TODO kb\"),\n                                         worktree_id: todo!(),\n                                         work_directory_id: todo!(),\n                                         paths: todo!(),\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -116,7 +116,7 @@\n                                         work_directory_id,\n                                     } => client.request(proto::Stage {\n                                         project_id: todo!(\"TODO kb\"),\n-                                        worktree_id: todo!(),\n+                                        worktree_id: worktree_id.to_proto(),\n                                         work_directory_id: todo!(),\n                                         paths: todo!(),\n                                     }),\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -117,7 +117,7 @@\n                                     } => client.request(proto::Stage {\n                                         project_id: todo!(\"TODO kb\"),\n                                         worktree_id: worktree_id.to_proto(),\n-                                        work_directory_id: todo!(),\n+                                        work_directory_id: work_directory_id.to_p,\n                                         paths: todo!(),\n                                     }),\n                                 }\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -117,7 +117,7 @@\n                                     } => client.request(proto::Stage {\n                                         project_id: todo!(\"TODO kb\"),\n                                         worktree_id: worktree_id.to_proto(),\n-                                        work_directory_id: work_directory_id.to_p,\n+                                        work_directory_id: work_directory_id.to_proto(),\n                                         paths: todo!(),\n                                     }),\n                                 }\n\n```\n\nUser edited \"crates/project/src/git.rs\":\n```diff\n@@ -118,7 +118,7 @@\n                                         project_id: todo!(\"TODO kb\"),\n                                         worktree_id: worktree_id.to_proto(),\n                                         work_directory_id: work_directory_id.to_proto(),\n-                                        paths: todo!(),\n+                                        paths: p,\n                                     }),\n                                 }\n                                 Ok(())\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/project/src/git.rs\n            mpsc::unbounded::<(Message, mpsc::Sender<anyhow::Error>)>();\n        cx.spawn(|_, cx| async move {\n            while let Some((msg, mut err_sender)) = update_receiver.next().await {\n                let result = cx\n                    .background_executor()\n                    .spawn(async move {\n                        match msg {\n                            Message::StageAndCommit(repo, message, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => {\n                                        repo.stage_paths(&paths)?;\n                                        repo.commit(&message.to_string())?;\n                                    }\n<|editable_region_start|>\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n\n                                Ok(())\n                            }\n                            Message::Stage(repo, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.stage_paths(&paths)?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => client.request(proto::Stage {\n                                        project_id: todo!(\"TODO kb\"),\n                                        worktree_id: worktree_id.to_proto(),\n                                        work_directory_id: work_directory_id.to_proto(),\n                                        paths: p<|user_cursor_is_here|>,\n<|editable_region_end|>\n                                    }),\n                                }\n                                Ok(())\n                            }\n                            Message::Unstage(repo, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.unstage_paths(&paths)?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n                                Ok(())\n                            }\n                            Message::Commit(repo, message) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.commit(&message.to_string())?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n                                Ok(())\n                            }\n                        }\n                    })\n                    .await;\n                if let Err(e) = result {\n                    err_sender.send(e).await.ok();\n                }\n            }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/project/src/git.rs\n            mpsc::unbounded::<(Message, mpsc::Sender<anyhow::Error>)>();\n        cx.spawn(|_, cx| async move {\n            while let Some((msg, mut err_sender)) = update_receiver.next().await {\n                let result = cx\n                    .background_executor()\n                    .spawn(async move {\n                        match msg {\n                            Message::StageAndCommit(repo, message, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => {\n                                        repo.stage_paths(&paths)?;\n                                        repo.commit(&message.to_string())?;\n                                    }\n<|editable_region_start|>\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n\n                                Ok(())\n                            }\n                            Message::Stage(repo, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.stage_paths(&paths)?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => client.request(proto::Stage {\n                                        project_id: todo!(\"TODO kb\"),\n                                        worktree_id: worktree_id.to_proto(),\n                                        work_directory_id: work_directory_id.to_proto(),\n                                        paths: paths.to_proto(),\n<|editable_region_end|>\n                                    }),\n                                }\n                                Ok(())\n                            }\n                            Message::Unstage(repo, paths) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.unstage_paths(&paths)?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n                                Ok(())\n                            }\n                            Message::Commit(repo, message) => {\n                                match repo {\n                                    GitRepo::Local(repo) => repo.commit(&message.to_string())?,\n                                    GitRepo::Remote {\n                                        client,\n                                        worktree_id,\n                                        work_directory_id,\n                                    } => todo!(\"TODO kb\"),\n                                }\n                                Ok(())\n                            }\n                        }\n                    })\n                    .await;\n                if let Err(e) = result {\n                    err_sender.send(e).await.ok();\n                }\n            }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -12,6 +12,9 @@\n     }\n   },\n   {\n+    \"c\"\n+  }\n+  {\n     \"context\": \"Workspace > Pane > !Editor\",\n     \"bindings\": {\n       \"space f\": \"file_finder::Toggle\"\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n<|start_of_file|>\n// Zed keymap\n//\n// For information on binding keys, see the Zed\n// documentation: https://zed.dev/docs/key-bindings\n<|editable_region_start|>\n//\n// To see the default key bindings run `zed: Open Default Keymap`\n// from the command palette.\n[\n  {\n    \"bindings\": {\n      \"shift-escape\": null\n    }\n  },\n  {\n    \"c<|user_cursor_is_here|>\"\n  }\n  {\n    \"context\": \"Workspace > Pane > !Editor\",\n    \"bindings\": {\n      \"space f\": \"file_finder::Toggle\"\n<|editable_region_end|>\n    }\n  }\n]\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n<|start_of_file|>\n// Zed keymap\n//\n// For information on binding keys, see the Zed\n// documentation: https://zed.dev/docs/key-bindings\n<|editable_region_start|>\n//\n// To see the default key bindings run `zed: Open Default Keymap`\n// from the command palette.\n[\n  {\n    \"bindings\": {\n      \"shift-escape\": null\n    }\n  },\n  {\n    \"context\": \"Workspace > Pane > !Editor\",\n  },\n  {\n    \"context\": \"Workspace > Pane > !Editor\",\n    \"bindings\": {\n      \"space f\": \"file_finder::Toggle\"\n<|editable_region_end|>\n    }\n  }\n]\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/git/project_diff.rs\":\n```diff\n@@ -856,7 +856,7 @@\n                     for (_, buffer, hunk_ranges) in excerpts_to_add {\n                         let buffer_snapshot = buffer.read(cx).snapshot();\n                         let max_point = buffer_snapshot.max_point();\n-                        let new_excerpts = multi_buffer.insert_excerpts(\n+                        let new_excerpts = multi_buffer.push_excerpts(\n                             buffer,\n                             hunk_ranges.into_iter().map(|range| {\n                                 let mut extended_point_range = range.to_point(&buffer_snapshot);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/diagnostics/src/diagnostics.rs\n                            Ordering::Equal => {\n                                to_keep = old_groups.next();\n                                new_groups.next();\n                            }\n                            Ordering::Greater => to_insert = new_groups.next(),\n                        }\n                    }\n                }\n\n                if let Some((language_server_id, group)) = to_insert {\n                    let mut group_state = DiagnosticGroupState {\n<|editable_region_start|>\n                        language_server_id,\n                        primary_diagnostic: group.entries[group.primary_ix].clone(),\n                        primary_excerpt_ix: 0,\n                        excerpts: Default::default(),\n                        blocks: Default::default(),\n                        block_count: 0,\n                    };\n                    let mut pending_range: Option<(Range<Point>, Range<Point>, usize)> = None;\n                    let mut is_first_excerpt_for_group = true;\n                    for (ix, entry) in group.entries.iter().map(Some).chain([None]).enumerate() {\n                        let resolved_entry = entry.map(|e| e.resolve::<Point>(&snapshot));\n                        let expanded_range = resolved_entry.as_ref().map(|entry| {\n                            context_range_for_entry(entry, self.context, &snapshot, cx)\n                        });\n                        if let Some((range, context_range, start_ix)) = &mut pending_range {\n                            if let Some(expanded_range) = expanded_range.clone() {\n                                // If the entries are overlapping or next to each-other, merge them into one excerpt.\n                                if context_range.end.row + 1 >= expanded_range.start.row {\n                                    context_range.end = context_range.end.max(expanded_range.end);\n                                    continue;\n                                }\n                            }\n<|user_cursor_is_here|>\n                            let excerpt_id = excerpts\n                                .push_excerpts(\n                                    buffer.clone(),\n                                    [ExcerptRange {\n                                        context: context_range.clone(),\n                                        primary: Some(range.clone()),\n                                    }],\n                                    cx,\n                                )\n                                .pop()\n                                .unwrap();\n\n                            prev_excerpt_id = excerpt_id;\n                            first_excerpt_id.get_or_insert(prev_excerpt_id);\n                            group_state.excerpts.push(excerpt_id);\n                            let header_position = (excerpt_id, language::Anchor::MIN);\n\n                            if is_first_excerpt_for_group {\n                                is_first_excerpt_for_group = false;\n                                let mut primary =\n                                    group.entries[group.primary_ix].diagnostic.clone();\n                                primary.message =\n                                    primary.message.split('\\n').next().unwrap().to_string();\n                                group_state.block_count += 1;\n                                blocks_to_add.push(BlockProperties {\n                                    placement: BlockPlacement::Above(header_position),\n                                    height: 2,\n                                    style: BlockStyle::Sticky,\n                                    render: diagnostic_header_renderer(primary),\n                                    priority: 0,\n                                });\n<|editable_region_end|>\n                            }\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/diagnostics/src/diagnostics.rs\n                            Ordering::Equal => {\n                                to_keep = old_groups.next();\n                                new_groups.next();\n                            }\n                            Ordering::Greater => to_insert = new_groups.next(),\n                        }\n                    }\n                }\n\n                if let Some((language_server_id, group)) = to_insert {\n                    let mut group_state = DiagnosticGroupState {\n<|editable_region_start|>\n                        language_server_id,\n                        primary_diagnostic: group.entries[group.primary_ix].clone(),\n                        primary_excerpt_ix: 0,\n                        excerpts: Default::default(),\n                        blocks: Default::default(),\n                        block_count: 0,\n                    };\n                    let mut pending_range: Option<(Range<Point>, Range<Point>, usize)> = None;\n                    let mut is_first_excerpt_for_group = true;\n                    for (ix, entry) in group.entries.iter().map(Some).chain([None]).enumerate() {\n                        let resolved_entry = entry.map(|e| e.resolve::<Point>(&snapshot));\n                        let expanded_range = resolved_entry.as_ref().map(|entry| {\n                            context_range_for_entry(entry, self.context, &snapshot, cx)\n                        });\n                        if let Some((range, context_range, start_ix)) = &mut pending_range {\n                            if let Some(expanded_range) = expanded_range.clone() {\n                                // If the entries are overlapping or next to each-other, merge them into one excerpt.\n                                if context_range.end.row + 1 >= expanded_range.start.row {\n                                    context_range.end = context_range.end.max(expanded_range.end);\n                                    continue;\n                                }\n                            }\n\n                            let excerpt_id = excerpts\n                                .push_excerpts(\n                                    buffer.clone(),\n                                    [ExcerptRange {\n                                        context: context_range.clone(),\n                                        primary: Some(range.clone()),\n                                    }],\n                                    cx,\n                                )\n                                .pop()\n                                .unwrap();\n\n                            prev_excerpt_id = excerpt_id;\n                            first_excerpt_id.get_or_insert(prev_excerpt_id);\n                            group_state.excerpts.push(excerpt_id);\n                            let header_position = (excerpt_id, language::Anchor::MIN);\n\n                            if is_first_excerpt_for_group {\n                                is_first_excerpt_for_group = false;\n                                let mut primary =\n                                    group.entries[group.primary_ix].diagnostic.clone();\n                                primary.message =\n                                    primary.message.split('\\n').next().unwrap().to_string();\n                                group_state.block_count += 1;\n                                blocks_to_add.push(BlockProperties {\n                                    placement: BlockPlacement::Above(header_position),\n                                    height: 2,\n                                    style: BlockStyle::Sticky,\n                                    render: diagnostic_header_renderer(primary),\n                                    priority: 0,\n                                });\n<|editable_region_end|>\n                            }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\n```diff\n@@ -194,6 +194,7 @@\n             editor.set_show_inline_completions(Some(false), window, cx);\n             editor.set_vertical_scroll_margin(5, cx);\n             editor.set_use_modal_editing(false);\n+            edit\n             editor\n         });\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/feedback/src/feedback_modal.rs\n                .detach_and_log_err(cx);\n        });\n    }\n\n    pub fn new(\n        system_specs: SystemSpecs,\n        project: Entity<Project>,\n        buffer: Entity<Buffer>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let email_address_editor = cx.new(|cx| {\n            let mut editor = Editor::single_line(window, cx);\n            editor.set_placeholder_text(\"Email address (optional)\", cx);\n\n            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {\n                editor.set_text(email_address, window, cx)\n            }\n\n            editor\n        });\n\n        let feedback_editor = cx.new(|cx| {\n            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);\n            editor.set_placeholder_text(\n                \"You can use markdown to organize your feedback with code and links.\",\n                cx,\n            );\n<|editable_region_start|>\n            editor.set_show_gutter(false, cx);\n            editor.set_show_indent_guides(false, cx);\n            editor.set_show_inline_completions(Some(false), window, cx);\n            editor.set_vertical_scroll_margin(5, cx);\n            editor.set_use_modal_editing(false);\n            edit<|user_cursor_is_here|>\n            editor\n        });\n\n        cx.subscribe(&feedback_editor, |this, editor, event: &EditorEvent, cx| {\n            if matches!(event, EditorEvent::Edited { .. }) {\n                this.character_count = editor\n                    .read(cx)\n                    .buffer()\n                    .read(cx)\n                    .as_singleton()\n                    .expect(\"Feedback editor is never a multi-buffer\")\n                    .read(cx)\n                    .len() as i32;\n                cx.notify();\n            }\n        })\n        .detach();\n\n        Self {\n            system_specs: system_specs.clone(),\n            feedback_editor,\n            email_address_editor,\n            submission_state: None,\n<|editable_region_end|>\n            dismiss_modal: false,\n            character_count: 0,\n        }\n    }\n\n    pub fn submit(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<()>> {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/feedback/src/feedback_modal.rs\n                .detach_and_log_err(cx);\n        });\n    }\n\n    pub fn new(\n        system_specs: SystemSpecs,\n        project: Entity<Project>,\n        buffer: Entity<Buffer>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let email_address_editor = cx.new(|cx| {\n            let mut editor = Editor::single_line(window, cx);\n            editor.set_placeholder_text(\"Email address (optional)\", cx);\n\n            if let Ok(Some(email_address)) = KEY_VALUE_STORE.read_kvp(DATABASE_KEY_NAME) {\n                editor.set_text(email_address, window, cx)\n            }\n\n            editor\n        });\n\n        let feedback_editor = cx.new(|cx| {\n            let mut editor = Editor::for_buffer(buffer, Some(project.clone()), window, cx);\n            editor.set_placeholder_text(\n                \"You can use markdown to organize your feedback with code and links.\",\n                cx,\n            );\n<|editable_region_start|>\n            editor.set_show_gutter(false, cx);\n            editor.set_show_indent_guides(false, cx);\n            editor.set_show_inline_completions(Some(false), window, cx);\n            editor.set_vertical_scroll_margin(5, cx);\n            editor.set_use_modal_editing(false);\n            editor.set_auto_height(true, cx);\n            editor\n        });\n\n        cx.subscribe(&feedback_editor, |this, editor, event: &EditorEvent, cx| {\n            if matches!(event, EditorEvent::Edited { .. }) {\n                this.character_count = editor\n                    .read(cx)\n                    .buffer()\n                    .read(cx)\n                    .as_singleton()\n                    .expect(\"Feedback editor is never a multi-buffer\")\n                    .read(cx)\n                    .len() as i32;\n                cx.notify();\n            }\n        })\n        .detach();\n\n        Self {\n            system_specs: system_specs.clone(),\n            feedback_editor,\n            email_address_editor,\n            submission_state: None,\n<|editable_region_end|>\n            dismiss_modal: false,\n            character_count: 0,\n        }\n    }\n\n    pub fn submit(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<()>> {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/workspace/src/workspace.rs\":\n```diff\n@@ -2210,6 +2210,7 @@\n         self.project\n             .read(cx)\n             .worktree_for_id(worktree_id, cx)\n+            /// TODO: \n             .map(|wt| wt.read(cx).abs_path().as_ref().to_path_buf())\n     }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/workspace/src/workspace.rs\n                            .await,\n                        )\n                    }\n                });\n                tasks.push(task);\n            }\n\n            futures::future::join_all(tasks).await\n        })\n    }\n\n    pub fn open_resolved_path(\n        &mut self,\n        path: ResolvedPath,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Box<dyn ItemHandle>>> {\n        match path {\n<|editable_region_start|>\n            ResolvedPath::ProjectPath { project_path, .. } => {\n                self.open_path(project_path, None, true, window, cx)\n            }\n            ResolvedPath::AbsPath { path, .. } => self.open_abs_path(path, false, window, cx),\n        }\n    }\n\n    pub fn absolute_path_of_worktree(\n        &self,\n        worktree_id: WorktreeId,\n        cx: &mut Context<Self>,\n    ) -> Option<PathBuf> {\n        self.project\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n            /// TODO: <|user_cursor_is_here|>\n            .map(|wt| wt.read(cx).abs_path().as_ref().to_path_buf())\n    }\n\n    fn add_folder_to_project(\n        &mut self,\n        _: &AddFolderToProject,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let project = self.project.read(cx);\n        if project.is_via_collab() {\n            self.show_error(\n                &anyhow!(\"You cannot add folders to someone else's project\"),\n                cx,\n            );\n            return;\n        }\n        let paths = self.prompt_for_open_path(\n            PathPromptOptions {\n<|editable_region_end|>\n                files: false,\n                directories: true,\n                multiple: true,\n            },\n            DirectoryLister::Project(self.project.clone()),\n            window,\n            cx,\n        );\n        cx.spawn_in(window, |this, mut cx| async move {\n            if let Some(paths) = paths.await.log_err().flatten() {\n                let results = this\n                    .update_in(&mut cx, |this, window, cx| {\n                        this.open_paths(paths, OpenVisible::All, None, window, cx)\n                    })?\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/workspace/src/workspace.rs\n                            .await,\n                        )\n                    }\n                });\n                tasks.push(task);\n            }\n\n            futures::future::join_all(tasks).await\n        })\n    }\n\n    pub fn open_resolved_path(\n        &mut self,\n        path: ResolvedPath,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Box<dyn ItemHandle>>> {\n        match path {\n<|editable_region_start|>\n            ResolvedPath::ProjectPath { project_path, .. } => {\n                self.open_path(project_path, None, true, window, cx)\n            }\n            ResolvedPath::AbsPath { path, .. } => self.open_abs_path(path, false, window, cx),\n        }\n    }\n\n    pub fn absolute_path_of_worktree(\n        &self,\n        worktree_id: WorktreeId,\n        cx: &mut Context<Self>,\n    ) -> Option<PathBuf> {\n        self.project\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n            // TODO: \n            .map(|wt| wt.read(cx).abs_path().as_ref().to_path_buf())\n    }\n\n    fn add_folder_to_project(\n        &mut self,\n        _: &AddFolderToProject,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let project = self.project.read(cx);\n        if project.is_via_collab() {\n            self.show_error(\n                &anyhow!(\"You cannot add folders to someone else's project\"),\n                cx,\n            );\n            return;\n        }\n        let paths = self.prompt_for_open_path(\n            PathPromptOptions {\n<|editable_region_end|>\n                files: false,\n                directories: true,\n                multiple: true,\n            },\n            DirectoryLister::Project(self.project.clone()),\n            window,\n            cx,\n        );\n        cx.spawn_in(window, |this, mut cx| async move {\n            if let Some(paths) = paths.await.log_err().flatten() {\n                let results = this\n                    .update_in(&mut cx, |this, window, cx| {\n                        this.open_paths(paths, OpenVisible::All, None, window, cx)\n                    })?\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -944,6 +944,7 @@\n             } else {\n                 $in.name | path split | last\n             }\n+\n             {\n                 name: $name\n                 line_count: ($in.name | open | lines | length)\n\n```\n\nUser edited \"\":\n```diff\n@@ -950,5 +950,4 @@\n                 line_count: ($in.name | open | lines | length)\n             }\n         }\n-        | sort-by line_count\n }\n\n```\n\nUser edited \"\":\n```diff\n@@ -930,7 +930,7 @@\n # TODO - error recovery when encountering a binary file\n # TODO - parameter for\n \n-def file-line-counts [...extension: string, --full-path]: nothing -> list<any> {\n+def file-line-counts [...extension: string, ---path]: nothing -> list<any> {\n     let pattern = if ($extension | is-empty) {\n         \"**/*\"\n     } else {\n\n```\n\nUser edited \"\":\n```diff\n@@ -930,7 +930,7 @@\n # TODO - error recovery when encountering a binary file\n # TODO - parameter for\n \n-def file-line-counts [...extension: string, ---path]: nothing -> list<any> {\n+def file-line-counts [...extension: string, --name-path]: nothing -> list<any> {\n     let pattern = if ($extension | is-empty) {\n         \"**/*\"\n     } else {\n\n```\n\nUser edited \"\":\n```diff\n@@ -930,7 +930,7 @@\n # TODO - error recovery when encountering a binary file\n # TODO - parameter for\n \n-def file-line-counts [...extension: string, --name-path]: nothing -> list<any> {\n+def file-line-counts [...extension: string, --name-only]: nothing -> list<any> {\n     let pattern = if ($extension | is-empty) {\n         \"**/*\"\n     } else {\n\n```\n\nUser edited \"\":\n```diff\n@@ -930,7 +930,7 @@\n # TODO - error recovery when encountering a binary file\n # TODO - parameter for\n \n-def file-line-counts [...extension: string, --name-only]: nothing -> list<any> {\n+def file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {\n     let pattern = if ($extension | is-empty) {\n         \"**/*\"\n     } else {\n\n```\n\nUser edited \"\":\n```diff\n@@ -939,7 +939,7 @@\n \n     ls ...(glob $pattern)\n         | each {\n-            let name = if $full_path {\n+            let name = if $name_o {\n                 $in.name\n             } else {\n                 $in.name | path split | last\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n        }\n        {\n            name: move_one_word_right_or_take_history_hint\n            modifier: alt\n            keycode: char_f\n            mode: emacs\n            event: {\n                until: [\n                    { send: historyhintwordcomplete }\n                    { edit: movewordright }\n                ]\n            }\n        }\n        {\n            name: delete_one_word_forward\n            modifier: alt\n            keycode: delete\n            mode: emacs\n            event: { edit: deleteword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: backspace\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: char_m\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: cut_word_to_right\n            modifier: alt\n            keycode: char_d\n            mode: emacs\n            event: { edit: cutwordright }\n        }\n        {\n            name: upper_case_word\n            modifier: alt\n            keycode: char_u\n            mode: emacs\n            event: { edit: uppercaseword }\n        }\n        {\n            name: lower_case_word\n            modifier: alt\n            keycode: char_l\n            mode: emacs\n            event: { edit: lowercaseword }\n        }\n        {\n            name: capitalize_char\n            modifier: alt\n            keycode: char_c\n            mode: emacs\n<|editable_region_start|>\n            event: { edit: capitalizechar }\n        }\n        # The following bindings with `*system` events require that Nushell has\n        # been compiled with the `system-clipboard` feature.\n        # If you want to use the system clipboard for visual selection or to\n        # paste directly, uncomment the respective lines and replace the version\n        # using the internal clipboard.\n        {\n            name: copy_selection\n            modifier: control_shift\n            keycode: char_c\n            mode: emacs\n            event: { edit: copyselection }\n            # event: { edit: copyselectionsystem }\n        }\n        {\n            name: cut_selection\n            modifier: control_shift\n            keycode: char_x\n            mode: emacs\n            event: { edit: cutselection }\n            # event: { edit: cutselectionsystem }\n        }\n        # {\n        #     name: paste_system\n        #     modifier: control_shift\n        #     keycode: char_v\n        #     mode: emacs\n        #     event: { edit: pastesystem }\n        # }\n        {\n            name: select_all\n            modifier: control_shift\n            keycode: char_a\n            mode: emacs\n            event: { edit: selectall }\n        }\n    ]\n}\n\n# Custom config\n\n$env.config.buffer_editor = \"zed\"\n\ndef \"restart\" []: nothing -> nothing {\n    exec $nu.current-exe\n}\n\n# git\n\ndef git-tags []: nothing -> list<any> {\n    git tag -n --sort=version:refname\n        | from ssv -n\n        | rename tag \"commit description\"\n}\n\ndef zed-git-tags [--no-releases (-r), --no-collab (-c)]: nothing -> list<any> {\n    mut tags = git-tags\n\n    if $no_releases {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n    }\n\n    if $no_collab {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"collab\")}\n    }\n\n    $tags\n}\n\n# TODO - error recovery when encountering a binary file\n# TODO - parameter for\n\ndef file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {\n    let pattern = if ($extension | is-empty) {\n        \"**/*\"\n    } else {\n        $\"**/*.{($extension | str join \",\")}\"\n    }\n\n    ls ...(glob $pattern)\n        | each {\n            let name = if $name_o<|user_cursor_is_here|> {\n                $in.name\n            } else {\n                $in.name | path split | last\n            }\n\n<|editable_region_end|>\n            {\n                name: $name\n                line_count: ($in.name | open | lines | length)\n            }\n        }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n        }\n        {\n            name: move_one_word_right_or_take_history_hint\n            modifier: alt\n            keycode: char_f\n            mode: emacs\n            event: {\n                until: [\n                    { send: historyhintwordcomplete }\n                    { edit: movewordright }\n                ]\n            }\n        }\n        {\n            name: delete_one_word_forward\n            modifier: alt\n            keycode: delete\n            mode: emacs\n            event: { edit: deleteword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: backspace\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: char_m\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: cut_word_to_right\n            modifier: alt\n            keycode: char_d\n            mode: emacs\n            event: { edit: cutwordright }\n        }\n        {\n            name: upper_case_word\n            modifier: alt\n            keycode: char_u\n            mode: emacs\n            event: { edit: uppercaseword }\n        }\n        {\n            name: lower_case_word\n            modifier: alt\n            keycode: char_l\n            mode: emacs\n            event: { edit: lowercaseword }\n        }\n        {\n            name: capitalize_char\n            modifier: alt\n            keycode: char_c\n            mode: emacs\n<|editable_region_start|>\n            event: { edit: capitalizechar }\n        }\n        # The following bindings with `*system` events require that Nushell has\n        # been compiled with the `system-clipboard` feature.\n        # If you want to use the system clipboard for visual selection or to\n        # paste directly, uncomment the respective lines and replace the version\n        # using the internal clipboard.\n        {\n            name: copy_selection\n            modifier: control_shift\n            keycode: char_c\n            mode: emacs\n            event: { edit: copyselection }\n            # event: { edit: copyselectionsystem }\n        }\n        {\n            name: cut_selection\n            modifier: control_shift\n            keycode: char_x\n            mode: emacs\n            event: { edit: cutselection }\n            # event: { edit: cutselectionsystem }\n        }\n        # {\n        #     name: paste_system\n        #     modifier: control_shift\n        #     keycode: char_v\n        #     mode: emacs\n        #     event: { edit: pastesystem }\n        # }\n        {\n            name: select_all\n            modifier: control_shift\n            keycode: char_a\n            mode: emacs\n            event: { edit: selectall }\n        }\n    ]\n}\n\n# Custom config\n\n$env.config.buffer_editor = \"zed\"\n\ndef \"restart\" []: nothing -> nothing {\n    exec $nu.current-exe\n}\n\n# git\n\ndef git-tags []: nothing -> list<any> {\n    git tag -n --sort=version:refname\n        | from ssv -n\n        | rename tag \"commit description\"\n}\n\ndef zed-git-tags [--no-releases (-r), --no-collab (-c)]: nothing -> list<any> {\n    mut tags = git-tags\n\n    if $no_releases {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n    }\n\n    if $no_collab {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"collab\")}\n    }\n\n    $tags\n}\n\n# TODO - error recovery when encountering a binary file\n# TODO - parameter for\n\ndef file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {\n    let pattern = if ($extension | is-empty) {\n        \"**/*\"\n    } else {\n        $\"**/*.{($extension | str join \",\")}\"\n    }\n\n    ls ...(glob $pattern)\n        | each {\n            let name = if $name_only {\n                $in.name\n            } else {\n                $in.name | path split | last\n            }\n\n<|editable_region_end|>\n            {\n                name: $name\n                line_count: ($in.name | open | lines | length)\n            }\n        }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/persistence.rs\":\n```diff\n@@ -36,7 +36,7 @@\n     }\n \n     query! {\n-        pub async fn save_accepted_data_collection(project_path: PathBuf, accepted_data_collection: bool) -> Result<()> {\n+        pub async fn save_accepted_data_collection(project_path: Path, accepted_data_collection: bool) -> Result<()> {\n             INSERT INTO zeta_preferences\n                 (project_path, accepted_data_collection)\n             VALUES\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/persistence.rs\n<|start_of_file|>\nuse anyhow::Result;\nuse collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse workspace::WorkspaceDb;\n\nuse db::sqlez_macros::sql;\nuse db::{define_connection, query};\n\ndefine_connection!(\n    pub static ref DB: ZetaDb<WorkspaceDb> = &[\n        sql! (\n            CREATE TABLE zeta_preferences(\n                project_path BLOB NOT NULL,\n<|editable_region_start|>\n                accepted_data_collection INTEGER\n            ) STRICT;\n        ),\n    ];\n);\n<|user_cursor_is_here|>\nimpl ZetaDb {\n    pub fn get_all_zeta_preferences(&self) -> Result<HashMap<PathBuf, bool>> {\n        Ok(self.get_all_zeta_preferences_query()?.into_iter().collect())\n    }\n\n    query! {\n        fn get_all_zeta_preferences_query() -> Result<Vec<(PathBuf, bool)>> {\n            SELECT project_path, accepted_data_collection FROM zeta_preferences\n        }\n    }\n\n    query! {\n        pub fn get_accepted_data_collection(project_path: &Path) -> Result<Option<bool>> {\n            SELECT accepted_data_collection FROM zeta_preferences\n            WHERE project_path = ?\n        }\n    }\n\n    query! {\n        pub async fn save_accepted_data_collection(project_path: Path, accepted_data_collection: bool) -> Result<()> {\n            INSERT INTO zeta_preferences\n                (project_path, accepted_data_collection)\n            VALUES\n                (?1, ?2)\n            ON CONFLICT DO UPDATE SET\n<|editable_region_end|>\n                project_path = ?1,\n                accepted_data_collection = ?2\n        }\n    }\n\n    query! {\n        pub async fn clear_all_zeta_preferences() -> Result<()> {\n            DELETE FROM zeta_preferences\n        }\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/persistence.rs\n<|start_of_file|>\nuse anyhow::Result;\nuse collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse workspace::WorkspaceDb;\n\nuse db::sqlez_macros::sql;\nuse db::{define_connection, query};\n\ndefine_connection!(\n    pub static ref DB: ZetaDb<WorkspaceDb> = &[\n        sql! (\n            CREATE TABLE zeta_preferences(\n                project_path BLOB NOT NULL,\n<|editable_region_start|>\n                accepted_data_collection INTEGER\n            ) STRICT;\n        ),\n    ];\n);\n\nimpl ZetaDb {\n    pub fn get_all_zeta_preferences(&self) -> Result<HashMap<PathBuf, bool>> {\n        Ok(self.get_all_zeta_preferences_query()?.into_iter().collect())\n    }\n\n    query! {\n        fn get_all_zeta_preferences_query() -> Result<Vec<(PathBuf, bool)>> {\n            SELECT project_path, accepted_data_collection FROM zeta_preferences\n        }\n    }\n\n    query! {\n        pub fn get_accepted_data_collection(project_path: &Path) -> Result<Option<bool>> {\n            SELECT accepted_data_collection FROM zeta_preferences\n            WHERE project_path = ?\n        }\n    }\n\n    query! {\n        pub async fn save_accepted_data_collection(project_path: &Path, accepted_data_collection: bool) -> Result<()> {\n            INSERT INTO zeta_preferences\n                (project_path, accepted_data_collection)\n            VALUES\n                (?1, ?2)\n            ON CONFLICT DO UPDATE SET\n<|editable_region_end|>\n                project_path = ?1,\n                accepted_data_collection = ?2\n        }\n    }\n\n    query! {\n        pub async fn clear_all_zeta_preferences() -> Result<()> {\n            DELETE FROM zeta_preferences\n        }\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -595,7 +595,7 @@\n             \"\n             .unindent(),\n         );\n-        let diff_5 = BufferDiff::build(Some(&base_text, &buffer);\n+        let diff_5 = BufferDiff::build(Some(&base_text), &buffer);\n         let range = diff_5.compare(&diff_4, &buffer).unwrap();\n         assert_eq!(range.to_point(&buffer), Point::new(3, 0)..Point::new(4, 0));\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/git/src/diff.rs\n                SIX.5\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_3 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_3.compare(&diff_2, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(1, 0)..Point::new(2, 0));\n\n        // Edit turns a modification hunk into a deletion.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n                four\n                five\u00ab\u00bb\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_4 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_4.compare(&diff_3, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(3, 4)..Point::new(4, 0));\n\n<|editable_region_start|>\n        // Edit introduces a new insertion hunk.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n                four\u00ab\n                FOUR.5\n                \u00bbfive\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_5 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_5.compare(&diff_4, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(3, 0)..Point::new(4, 0));\n\n        // Edit removes a hunk.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n        <|user_cursor_is_here|>        four\n                FOUR.5\n<|editable_region_end|>\n                five\n                seven\n                eight\n                \u00abnine\u00bb\n            \"\n            .unindent(),\n        );\n        let diff_6 = BufferDiff::build(&base_text, &buffer);\n        let range = diff_6.compare(&diff_5, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(7, 0)..Point::new(8, 0));\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/git/src/diff.rs\n                SIX.5\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_3 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_3.compare(&diff_2, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(1, 0)..Point::new(2, 0));\n\n        // Edit turns a modification hunk into a deletion.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n                four\n                five\u00ab\u00bb\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_4 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_4.compare(&diff_3, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(3, 4)..Point::new(4, 0));\n\n<|editable_region_start|>\n        // Edit introduces a new insertion hunk.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n                four\u00ab\n                FOUR.5\n                \u00bbfive\n                seven\n                eight\n                NINE\n            \"\n            .unindent(),\n        );\n        let diff_5 = BufferDiff::build(Some(&base_text), &buffer);\n        let range = diff_5.compare(&diff_4, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(3, 0)..Point::new(4, 0));\n\n        // Edit removes a hunk.\n        buffer.edit_via_marked_text(\n            &\"\n                one\n                THREE\n                four\n                FOUR.5\n<|editable_region_end|>\n                five\n                seven\n                eight\n                \u00abnine\u00bb\n            \"\n            .unindent(),\n        );\n        let diff_6 = BufferDiff::build(&base_text, &buffer);\n        let range = diff_6.compare(&diff_5, &buffer).unwrap();\n        assert_eq!(range.to_point(&buffer), Point::new(7, 0)..Point::new(8, 0));\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/gpui/src/platform.rs\":\n```diff\n@@ -791,6 +791,7 @@\n     }\n \n     pub fn character_index_for_point(&mut self, point: Point<Pixels>) -> Option<usize> {\n+        self.c\n         self.handler.character_index_for_point(point, window, cx)\n     }\n }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/gpui/src/platform.rs\n            .ok();\n    }\n\n    fn bounds_for_range(&mut self, range_utf16: Range<usize>) -> Option<Bounds<Pixels>> {\n        self.cx\n            .update(|window, cx| self.handler.bounds_for_range(range_utf16, window, cx))\n            .ok()\n            .flatten()\n    }\n\n    #[allow(dead_code)]\n    fn apple_press_and_hold_enabled(&mut self) -> bool {\n        self.handler.apple_press_and_hold_enabled()\n    }\n\n    pub(crate) fn dispatch_input(&mut self, input: &str, window: &mut Window, cx: &mut App) {\n        self.handler.replace_text_in_range(None, input, window, cx);\n    }\n\n    pub fn selected_bounds(&mut self, window: &mut Window, cx: &mut App) -> Option<Bounds<Pixels>> {\n        let selection = self.handler.selected_text_range(true, window, cx)?;\n        self.handler.bounds_for_range(\n            if selection.reversed {\n                selection.range.start..selection.range.start\n            } else {\n                selection.range.end..selection.range.end\n            },\n            window,\n<|editable_region_start|>\n            cx,\n        )\n    }\n\n    pub fn character_index_for_point(&mut self, point: Point<Pixels>) -> Option<usize> {\n        self.c\n        self.handler.character_index_for_point(point, window, cx)\n    }\n}\n\n/// A struct representing a selection in a text buffer, in UTF16 characters.\n/// This is different from a range because the head may be before the tail.\n#[derive(Debug)]\npub struct UTF16Selection {\n    /// The range of text in the document this selection corresponds to\n    /// in UTF16 characters.\n    pub range: Range<usize>,\n    /// Whether the head of this selection is at the start (true), or end (false)\n    /// of the range\n    pu<|user_cursor_is_here|>b reversed: bool,\n}\n\n/// Zed's interface for handling text input from the platform's IME system\n/// This is currently a 1:1 exposure of the NSTextInputClient API:\n///\n/// <https://developer.apple.com/documentation/appkit/nstextinputclient>\npub trait InputHandler: 'static {\n    /// Get the range of the user's currently selected text, if any\n    /// Corresponds to [selectedRange()](https://developer.apple.com/documentation/appkit/nstextinputclient/1438242-selectedrange)\n    ///\n    /// Return value is in terms of UTF-16 characters, from 0 to the length of the document\n    fn selected_text_range(\n        &mut self,\n        ignore_disabled_input: bool,\n        window: &mut Window,\n        cx: &mut App,\n<|editable_region_end|>\n    ) -> Option<UTF16Selection>;\n\n    /// Get the range of the currently marked text, if any\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/gpui/src/platform.rs\n            .ok();\n    }\n\n    fn bounds_for_range(&mut self, range_utf16: Range<usize>) -> Option<Bounds<Pixels>> {\n        self.cx\n            .update(|window, cx| self.handler.bounds_for_range(range_utf16, window, cx))\n            .ok()\n            .flatten()\n    }\n\n    #[allow(dead_code)]\n    fn apple_press_and_hold_enabled(&mut self) -> bool {\n        self.handler.apple_press_and_hold_enabled()\n    }\n\n    pub(crate) fn dispatch_input(&mut self, input: &str, window: &mut Window, cx: &mut App) {\n        self.handler.replace_text_in_range(None, input, window, cx);\n    }\n\n    pub fn selected_bounds(&mut self, window: &mut Window, cx: &mut App) -> Option<Bounds<Pixels>> {\n        let selection = self.handler.selected_text_range(true, window, cx)?;\n        self.handler.bounds_for_range(\n            if selection.reversed {\n                selection.range.start..selection.range.start\n            } else {\n                selection.range.end..selection.range.end\n            },\n            window,\n<|editable_region_start|>\n            cx,\n        )\n    }\n\n    pub fn character_index_for_point(&mut self, point: Point<Pixels>) -> Option<usize> {\n        self.cx\n            .update(|window, cx| self.handler.character_index_for_point(point, window, cx))\n            .ok()\n            .flatten()\n    }\n}\n\n/// A struct representing a selection in a text buffer, in UTF16 characters.\n/// This is different from a range because the head may be before the tail.\n#[derive(Debug)]\npub struct UTF16Selection {\n    /// The range of text in the document this selection corresponds to\n    /// in UTF16 characters.\n    pub range: Range<usize>,\n    /// Whether the head of this selection is at the start (true), or end (false)\n    /// of the range\n    pub reversed: bool,\n}\n\n/// Zed's interface for handling text input from the platform's IME system\n/// This is currently a 1:1 exposure of the NSTextInputClient API:\n///\n/// <https://developer.apple.com/documentation/appkit/nstextinputclient>\npub trait InputHandler: 'static {\n    /// Get the range of the user's currently selected text, if any\n    /// Corresponds to [selectedRange()](https://developer.apple.com/documentation/appkit/nstextinputclient/1438242-selectedrange)\n    ///\n    /// Return value is in terms of UTF-16 characters, from 0 to the length of the document\n    fn selected_text_range(\n        &mut self,\n        ignore_disabled_input: bool,\n        window: &mut Window,\n        cx: &mut App,\n<|editable_region_end|>\n    ) -> Option<UTF16Selection>;\n\n    /// Get the range of the currently marked text, if any\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/gpui/examples/input.rs\":\n```diff\n@@ -372,7 +372,8 @@\n         cx: &mut Context<Self>,\n     ) -> Option<usize> {\n         let last_layout = self.last_layout.as_ref()?;\n-        // 1. Figure out if this click collides with the \n+        // 1. Figure out if this click collides with the lines here\n+        // 2. Once we have tha\n         last_layout.closest_index_for_x(x)\n         let x = point.x - last_layout.bounds.left();\n         let y = point.y - last_layout.bounds.top();\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/gpui/examples/input.rs\n        cx.notify();\n    }\n\n    fn bounds_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n<|editable_region_start|>\n        bounds: Bounds<Pixels>,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) -> Option<Bounds<Pixels>> {\n        let last_layout = self.last_layout.as_ref()?;\n        let range = self.range_from_utf16(&range_utf16);\n        Some(Bounds::from_corners(\n            point(\n                bounds.left() + last_layout.x_for_index(range.start),\n                bounds.top(),\n            ),\n            point(\n                bounds.left() + last_layout.x_for_index(range.end),\n                bounds.bottom(),\n            ),\n        ))\n    }\n\n    fn character_index_for_point(\n        &mut self,\n        point: gpui::Point<Pixels>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<usize> {\n        let last_layout = self.last_layout.as_ref()?;\n        // 1. Figure out if this click collides with the lines here\n        // 2. Once we have tha\n        last_layout.closest_index_for_x(x)\n        let x = point.x - last_layout.bounds.left();\n        let y = point.y - last_layout.bounds.top();\n        dbg!(point);\n        None\n    }\n}\n\nstruct TextElement {\n    input: Entity<TextInput>,\n}\n\nstruct PrepaintState {\n    line: Option<ShapedLine>,\n    cursor: Option<PaintQuad>,\n    selection: Option<PaintQuad>,\n}\n\nimpl IntoElement for TextElement {\n    type Element = Self;\n\n    fn into_element(self) -> Self::Element {\n        self\n    }\n}\n\nimpl Element for TextElement {\n    type RequestLayoutState = ();\n\n    type PrepaintS<|user_cursor_is_here|>tate = PrepaintState;\n\n    fn id(&self) -> Option<ElementId> {\n<|editable_region_end|>\n        None\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/gpui/examples/input.rs\n        cx.notify();\n    }\n\n    fn bounds_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n<|editable_region_start|>\n        bounds: Bounds<Pixels>,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) -> Option<Bounds<Pixels>> {\n        let last_layout = self.last_layout.as_ref()?;\n        let range = self.range_from_utf16(&range_utf16);\n        Some(Bounds::from_corners(\n            point(\n                bounds.left() + last_layout.x_for_index(range.start),\n                bounds.top(),\n            ),\n            point(\n                bounds.left() + last_layout.x_for_index(range.end),\n                bounds.bottom(),\n            ),\n        ))\n    }\n\n    fn character_index_for_point(\n        &mut self,\n        point: gpui::Point<Pixels>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<usize> {\n        let last_layout = self.last_layout.as_ref()?;\n        // 1. Figure out if this click collides with the lines here\n        // 2. Once we have that, we need to find the line it's on\n        last_layout.closest_index_for_x(x)\n        let x = point.x - last_layout.bounds.left();\n        let y = point.y - last_layout.bounds.top();\n        dbg!(point);\n        None\n    }\n}\n\nstruct TextElement {\n    input: Entity<TextInput>,\n}\n\nstruct PrepaintState {\n    line: Option<ShapedLine>,\n    cursor: Option<PaintQuad>,\n    selection: Option<PaintQuad>,\n}\n\nimpl IntoElement for TextElement {\n    type Element = Self;\n\n    fn into_element(self) -> Self::Element {\n        self\n    }\n}\n\nimpl Element for TextElement {\n    type RequestLayoutState = ();\n\n    type PrepaintState = PrepaintState;\n\n    fn id(&self) -> Option<ElementId> {\n<|editable_region_end|>\n        None\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -2897,7 +2897,7 @@\n         snapshot: text::BufferSnapshot,\n         cx: &mut Context<Self>,\n     ) {\n-        eprintln!(\"\")\n+        eprintln!(\"COLE(FAKE) before \")\n         let base_text = self.base_text.as_ref().map(|buffer| buffer.text());\n         let diff_to_buffer = BufferDiff::build(base_text.as_deref(), &snapshot);\n         self.set_state(self.base_text.clone(), diff_to_buffer, &snapshot, cx);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/project/src/buffer_store.rs\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new(buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n<|editable_region_start|>\n    <|user_cursor_is_here|>        base_text: None,\n            diff_to_buffer: BufferDiff::new(&buffer.read(cx).text_snapshot()),\n            staged_text: None,\n            staged_diff: None,\n        }\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        let mut base_text = base_text.to_owned();\n        text::LineEnding::normalize(&mut base_text);\n        let diff_to_buffer = BufferDiff::build(Some(&base_text), &buffer.read(cx).text_snapshot());\n        let base_text = language::Buffer::build_snapshot_sync(base_text.into(), None, None, cx);\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n            base_text: Some(base_text),\n            diff_to_buffer,\n            staged_text: None,\n            staged_diff: None,\n        }\n<|editable_region_end|>\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn recalculate_diff_sync(\n        &mut self,\n        snapshot: text::BufferSnapshot,\n        cx: &mut Context<Self>,\n    ) {\n        eprintln!(\"COLE(FAKE) before {:?}\", self.diff_to_buffe)\n        let base_text = self.base_text.as_ref().map(|buffer| buffer.text());\n        let diff_to_buffer = BufferDiff::build(base_text.as_deref(), &snapshot);\n        self.set_state(self.base_text.clone(), diff_to_buffer, &snapshot, cx);\n    }\n}\n\nimpl OpenBuffer {\n    fn upgrade(&self) -> Option<Entity<Buffer>> {\n        match self {\n            OpenBuffer::Complete { buffer, .. } => buffer.upgrade(),\n            OpenBuffer::Operations(_) => None,\n        }\n    }\n}\n\nfn is_not_found_error(error: &anyhow::Error) -> bool {\n    error\n        .root_cause()\n        .downcast_ref::<io::Error>()\n        .is_some_and(|err| err.kind() == io::ErrorKind::NotFound)\n}\n\nfn serialize_blame_buffer_response(blame: Option<git::blame::Blame>) -> proto::BlameBufferResponse {\n    let Some(blame) = blame else {\n        return proto::BlameBufferResponse {\n            blame_response: None,\n        };\n    };\n\n    let entries = blame\n        .entries\n        .into_iter()\n        .map(|entry| proto::BlameEntry {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/project/src/buffer_store.rs\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new(buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n<|editable_region_start|>\n            base_text: None,\n            diff_to_buffer: BufferDiff::new(&buffer.read(cx).text_snapshot()),\n            staged_text: None,\n            staged_diff: None,\n        }\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n        let mut base_text = base_text.to_owned();\n        text::LineEnding::normalize(&mut base_text);\n        let diff_to_buffer = BufferDiff::build(Some(&base_text), &buffer.read(cx).text_snapshot());\n        let base_text = language::Buffer::build_snapshot_sync(base_text.into(), None, None, cx);\n        BufferChangeSet {\n            buffer_id: buffer.read(cx).remote_id(),\n            base_text: Some(base_text),\n            diff_to_buffer,\n            staged_text: None,\n            staged_diff: None,\n        }\n<|editable_region_end|>\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn recalculate_diff_sync(\n        &mut self,\n        snapshot: text::BufferSnapshot,\n        cx: &mut Context<Self>,\n    ) {\n        eprintln!(\"COLE(FAKE) before {:?}\", self.diff_to_buffe)\n        let base_text = self.base_text.as_ref().map(|buffer| buffer.text());\n        let diff_to_buffer = BufferDiff::build(base_text.as_deref(), &snapshot);\n        self.set_state(self.base_text.clone(), diff_to_buffer, &snapshot, cx);\n    }\n}\n\nimpl OpenBuffer {\n    fn upgrade(&self) -> Option<Entity<Buffer>> {\n        match self {\n            OpenBuffer::Complete { buffer, .. } => buffer.upgrade(),\n            OpenBuffer::Operations(_) => None,\n        }\n    }\n}\n\nfn is_not_found_error(error: &anyhow::Error) -> bool {\n    error\n        .root_cause()\n        .downcast_ref::<io::Error>()\n        .is_some_and(|err| err.kind() == io::ErrorKind::NotFound)\n}\n\nfn serialize_blame_buffer_response(blame: Option<git::blame::Blame>) -> proto::BlameBufferResponse {\n    let Some(blame) = blame else {\n        return proto::BlameBufferResponse {\n            blame_response: None,\n        };\n    };\n\n    let entries = blame\n        .entries\n        .into_iter()\n        .map(|entry| proto::BlameEntry {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -3172,7 +3172,7 @@\n     // `layout_gutter_menu` will render code actions menu if it is on the gutter.\n     // \n     #[allow(clippy::too_many_arguments)]\n-        fn layout_context_menu(\n+        fn layout_gut(\n             &self,\n             line_height: Pixels,\n             text_hitbox: &Hitbox,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/element.rs\n            let mut max_row = next_buffer_row - FILE_HEADER_HEIGHT * 2;\n\n            if next_excerpt_controls_present {\n                max_row -= MULTI_BUFFER_EXCERPT_HEADER_HEIGHT;\n            }\n\n            let offset = scroll_position - max_row as f32;\n\n            if offset > 0.0 {\n                origin.y -= Pixels(offset) * line_height;\n            }\n        }\n\n        let size = size(\n            AvailableSpace::Definite(hitbox.size.width),\n            AvailableSpace::MinContent,\n<|editable_region_start|>\n        );\n\n        header.prepaint_as_root(origin, size, window, cx);\n\n        header\n    }\n    <|user_cursor_is_here|>\n    // Design:\n    // \n    // `layout_cursor_popovers` will layout new edit predictions thing, completions menu, and\n    // signature help, in that order. If there isn't space for signature help, it will be hidden.\n    // completions menu is the only variable size part for now.\n    // \n    // `layout_gutter_menu` will render code actions menu if it is on the gutter.\n    // \n    #[allow(clippy::too_many_arguments)]\n        fn layout_gut(\n            &self,\n            line_height: Pixels,\n            text_hitbox: &Hitbox,\n            content_origin: gpui::Point<Pixels>,\n            start_row: DisplayRow,\n            scroll_pixel_position: gpui::Point<Pixels>,\n            line_layouts: &[LineWithInvisibles],\n            newest_selection_head: DisplayPoint,\n            gutter_overshoot: Pixels,\n            window: &mut Window,\n            cx: &mut App,\n        ) {\n            let Some(context_menu_origin) = self\n                .editor\n                .read(cx)\n                .context_menu_origin(newest_selection_head)\n            else {\n                return;\n            };\n    \n<|editable_region_end|>\n    #[allow(clippy::too_many_arguments)]\n    fn layout_context_menu(\n        &self,\n        line_height: Pixels,\n        text_hitbox: &Hitbox,\n        content_origin: gpui::Point<Pixels>,\n        start_row: DisplayRow,\n        scroll_pixel_position: gpui::Point<Pixels>,\n        line_layouts: &[LineWithInvisibles],\n        newest_selection_head: DisplayPoint,\n        gutter_overshoot: Pixels,\n        window: &mut Window,\n        cx: &mut App,\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/element.rs\n            let mut max_row = next_buffer_row - FILE_HEADER_HEIGHT * 2;\n\n            if next_excerpt_controls_present {\n                max_row -= MULTI_BUFFER_EXCERPT_HEADER_HEIGHT;\n            }\n\n            let offset = scroll_position - max_row as f32;\n\n            if offset > 0.0 {\n                origin.y -= Pixels(offset) * line_height;\n            }\n        }\n\n        let size = size(\n            AvailableSpace::Definite(hitbox.size.width),\n            AvailableSpace::MinContent,\n<|editable_region_start|>\n        );\n\n        header.prepaint_as_root(origin, size, window, cx);\n\n        header\n    }\n    \n    // Design:\n    // \n    // `layout_cursor_popovers` will layout new edit predictions thing, completions menu, and\n    // signature help, in that order. If there isn't space for signature help, it will be hidden.\n    // completions menu is the only variable size part for now.\n    // \n    // `layout_gutter_menu` will render code actions menu if it is on the gutter.\n    // \n    #[allow(clippy::too_many_arguments)]\n    fn layout_gutter_menu(\n        &self,\n        line_height: Pixels,\n        text_hitbox: &Hitbox,\n        content_origin: gpui::Point<Pixels>,\n        start_row: DisplayRow,\n        scroll_pixel_position: gpui::Point<Pixels>,\n        line_layouts: &[LineWithInvisibles],\n        newest_selection_head: DisplayPoint,\n        gutter_overshoot: Pixels,\n        window: &mut Window,\n        cx: &mut App,\n    ) {\n        let Some(context_menu_origin) = self\n            .editor\n            .read(cx)\n            .context_menu_origin(newest_selection_head)\n        else {\n            return;\n        };\n    }\n    \n<|editable_region_end|>\n    #[allow(clippy::too_many_arguments)]\n    fn layout_context_menu(\n        &self,\n        line_height: Pixels,\n        text_hitbox: &Hitbox,\n        content_origin: gpui::Point<Pixels>,\n        start_row: DisplayRow,\n        scroll_pixel_position: gpui::Point<Pixels>,\n        line_layouts: &[LineWithInvisibles],\n        newest_selection_head: DisplayPoint,\n        gutter_overshoot: Pixels,\n        window: &mut Window,\n        cx: &mut App,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"main.go\":\n```diff\n@@ -97,7 +97,7 @@\n \n \trendered := markdown.ToHTML(content, p, nil)\n \n-\tfmt.Println(a ...any)\n+\tfmt.Pri(a ...any)\n \t// Replace fenced code blocks with syntax-highlighted versions\n \trendered = highlightCodeBlocks(rendered)\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```main.go\n\t\tdata := PageData{\n\t\t\tFiles:   files,\n\t\t\tContent: renderedContent,\n\t\t\tCurrent: currentFile,\n\t\t}\n\n\t\ttmpl.ExecuteTemplate(w, \"index.html\", data)\n\t})\n\n\tlog.Println(\"Server starting at http://localhost:8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc listMarkdownFiles(dir string) ([]string, error) {\n\tvar files []string\n\terr := filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && (strings.HasSuffix(path, \".md\") || strings.HasSuffix(path, \".markdown\")) {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t})\n\treturn files, err\n}\n<|editable_region_start|>\n\nfunc renderMarkdown(content []byte) []byte {\n\textensions := parser.CommonExtensions | parser.AutoHeadingIDs | parser.FencedCode\n\tp := parser.NewWithExtensions(extensions)\n\n\trendered := markdown.ToHTML(content, p, nil)\n\n\tfmt.Pri(a ...any)\n\t// Replace fenced code blocks with syntax-highlighted versions\n\trendered = highlightCodeBlocks(rendered)\n\n\treturn rendered\n}\n\nfunc highlightCodeBlocks(content []byte) []byte {\n\t// Simple regex-based approach for demo purposes\n\t// In production, you'd want to use a proper HTML parser\n\tparts := strings.Split(string(content), \"```\")\n<|user_cursor_is_here|>\n\tvar result strings.Builder\n\n\tfor i, part := range parts {\n\t\tif i == 0 {\n\t\t\tresult.WriteString(part)\n<|editable_region_end|>\n\t\t\tcontinue\n\t\t}\n\n\t\tif i%2 == 1 {\n\t\t\t// This is a code block\n\t\t\tlines := strings.SplitN(part, \"\\n\", 2)\n\t\t\tif len(lines) < 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlanguage := strings.TrimSpace(lines[0])\n\t\t\tcode := lines[1]\n\n\t\t\tlexer := lexers.Get(language)\n\t\t\tif lexer == nil {\n\t\t\t\tfmt.Println(\"No lexer\")\n\t\t\t\tlexer = lexers.Fallback\n```"}, {"role": "assistant", "content": "Suggestion:\n```main.go\n\t\tdata := PageData{\n\t\t\tFiles:   files,\n\t\t\tContent: renderedContent,\n\t\t\tCurrent: currentFile,\n\t\t}\n\n\t\ttmpl.ExecuteTemplate(w, \"index.html\", data)\n\t})\n\n\tlog.Println(\"Server starting at http://localhost:8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc listMarkdownFiles(dir string) ([]string, error) {\n\tvar files []string\n\terr := filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && (strings.HasSuffix(path, \".md\") || strings.HasSuffix(path, \".markdown\")) {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t})\n\treturn files, err\n}\n<|editable_region_start|>\n\nfunc renderMarkdown(content []byte) []byte {\n\textensions := parser.CommonExtensions | parser.AutoHeadingIDs | parser.FencedCode\n\tp := parser.NewWithExtensions(extensions)\n\n\trendered := markdown.ToHTML(content, p, nil)\n\n\tfmt.Print(a ...any)\n\t// Replace fenced code blocks with syntax-highlighted versions\n\trendered = highlightCodeBlocks(rendered)\n\n\treturn rendered\n}\n\nfunc highlightCodeBlocks(content []byte) []byte {\n\t// Simple regex-based approach for demo purposes\n\t// In production, you'd want to use a proper HTML parser\n\tparts := strings.Split(string(content), \"```\")\n\n\tvar result strings.Builder\n\n\tfor i, part := range parts {\n\t\tif i == 0 {\n\t\t\tresult.WriteString(part)\n<|editable_region_end|>\n\t\t\tcontinue\n\t\t}\n\n\t\tif i%2 == 1 {\n\t\t\t// This is a code block\n\t\t\tlines := strings.SplitN(part, \"\\n\", 2)\n\t\t\tif len(lines) < 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlanguage := strings.TrimSpace(lines[0])\n\t\t\tcode := lines[1]\n\n\t\t\tlexer := lexers.Get(language)\n\t\t\tif lexer == nil {\n\t\t\t\tfmt.Println(\"No lexer\")\n\t\t\t\tlexer = lexers.Fallback\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1069,7 +1069,7 @@\n     }\n \n     pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {\n-        dbg!(&point);\n+        dbg!(&point, se);\n         if point.column() != self.line_len(point.row()) {\n             return point;\n         }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/display_map.rs\n    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot.chars_at(offset).map(move |ch| {\n            let ret = (ch, offset);\n            offset += ch.len_utf8();\n            ret\n        })\n<|editable_region_start|>\n    }\n\n    pub fn reverse_buffer_chars_at(\n        &self,\n        mut offset: usize,\n    ) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot\n            .reversed_chars_at(offset)\n            .map(move |ch| {\n                offset -= ch.len_utf8();\n                (ch, offset)\n            })\n    }\n\n    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n        if self.clip_at_line_ends {\n            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0\n        }\n        DisplayPoint(clipped)\n    }\n<|user_cursor_is_here|>\n    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))\n    }\n\n    pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {\n        dbg!(&point, se);\n        if point.column() != self.line_len(point.row()) {\n            return point;\n        }\n        let mut point = self.display_point_to_point(point, Bias::Left);\n        point.column = point.column.saturating_sub(1);\n        point = self.buffer_snapshot.clip_point(point, Bias::Left);\n        self.point_to_display_point(point, Bias::Left)\n    }\n\n    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>\n    where\n        T: ToOffset,\n    {\n        self.fold_snapshot.folds_in_range(range)\n    }\n\n    pub fn blocks_in_range(\n        &self,\n        rows: Range<DisplayRow>,\n    ) -> impl Iterator<Item = (DisplayRow, &Block)> {\n        self.block_snapshot\n            .blocks_in_range(rows.start.0..rows.end.0)\n<|editable_region_end|>\n            .map(|(row, block)| (DisplayRow(row), block))\n    }\n\n    pub fn sticky_header_excerpt(&self, row: DisplayRow) -> Option<StickyHeaderExcerpt<'_>> {\n        self.block_snapshot.sticky_header_excerpt(row.0)\n    }\n\n    pub fn block_for_id(&self, id: BlockId) -> Option<Block> {\n        self.block_snapshot.block_for_id(id)\n    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/display_map.rs\n    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot.chars_at(offset).map(move |ch| {\n            let ret = (ch, offset);\n            offset += ch.len_utf8();\n            ret\n        })\n<|editable_region_start|>\n    }\n\n    pub fn reverse_buffer_chars_at(\n        &self,\n        mut offset: usize,\n    ) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot\n            .reversed_chars_at(offset)\n            .map(move |ch| {\n                offset -= ch.len_utf8();\n                (ch, offset)\n            })\n    }\n\n    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n        if self.clip_at_line_ends {\n            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0\n        }\n        DisplayPoint(clipped)\n    }\n\n    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))\n    }\n\n    pub fn clip_at_line_end(&self, point: DisplayPoint) -> DisplayPoint {\n        dbg!(&point, self.display_point_to_point(point, Bias::Left));\n        if point.column() != self.line_len(point.row()) {\n            return point;\n        }\n        let mut point = self.display_point_to_point(point, Bias::Left);\n        point.column = point.column.saturating_sub(1);\n        point = self.buffer_snapshot.clip_point(point, Bias::Left);\n        self.point_to_display_point(point, Bias::Left)\n    }\n\n    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>\n    where\n        T: ToOffset,\n    {\n        self.fold_snapshot.folds_in_range(range)\n    }\n\n    pub fn blocks_in_range(\n        &self,\n        rows: Range<DisplayRow>,\n    ) -> impl Iterator<Item = (DisplayRow, &Block)> {\n        self.block_snapshot\n            .blocks_in_range(rows.start.0..rows.end.0)\n<|editable_region_end|>\n            .map(|(row, block)| (DisplayRow(row), block))\n    }\n\n    pub fn sticky_header_excerpt(&self, row: DisplayRow) -> Option<StickyHeaderExcerpt<'_>> {\n        self.block_snapshot.sticky_header_excerpt(row.0)\n    }\n\n    pub fn block_for_id(&self, id: BlockId) -> Option<Block> {\n        self.block_snapshot.block_for_id(id)\n    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/search/src/buffer_search.rs\":\n```diff\n@@ -703,7 +703,7 @@\n         cx.notify();\n     }\n     \n-    pub fn deploy_replace(&mut self, deploy_)\n+    pub fn deploy_replace(&mut self, _:)\n \n     pub fn deploy(&mut self, deploy: &Deploy, window: &mut Window, cx: &mut Context<Self>) -> bool {\n         if self.show(window, cx) {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/search/src/buffer_search.rs\n            editor_scroll_handle: ScrollHandle::new(),\n            editor_needed_width: px(0.),\n        }\n    }\n\n    pub fn is_dismissed(&self) -> bool {\n        self.dismissed\n    }\n\n    pub fn dismiss(&mut self, _: &Dismiss, window: &mut Window, cx: &mut Context<Self>) {\n        self.dismissed = true;\n        for searchable_item in self.searchable_items_with_matches.keys() {\n            if let Some(searchable_item) =\n                WeakSearchableItemHandle::upgrade(searchable_item.as_ref(), cx)\n            {\n                searchable_item.clear_matches(window, cx);\n            }\n        }\n        if let Some(active_editor) = self.active_searchable_item.as_mut() {\n            self.selection_search_enabled = false;\n            self.replace_enabled = false;\n<|editable_region_start|>\n            active_editor.search_bar_visibility_changed(false, window, cx);\n            active_editor.toggle_filtered_search_ranges(false, window, cx);\n            let handle = active_editor.item_focus_handle(cx);\n            self.focus(&handle, window, cx);\n        }\n        cx.emit(Event::UpdateLocation);\n        cx.emit(ToolbarItemEvent::ChangeLocation(\n            ToolbarItemLocation::Hidden,\n        ));\n        cx.notify();\n    }\n    \n    pub fn deploy_replace(&mut self, _:)\n\n    pub fn deploy(&mut self, deploy: &Deploy, window: &mut<|user_cursor_is_here|> Window, cx: &mut Context<Self>) -> bool {\n        if self.show(window, cx) {\n            if let Some(active_item) = self.active_searchable_item.as_mut() {\n                active_item.toggle_filtered_search_ranges(\n<|editable_region_end|>\n                    deploy.selection_search_enabled,\n                    window,\n                    cx,\n                );\n            }\n            self.search_suggested(window, cx);\n            self.smartcase(window, cx);\n            self.replace_enabled = deploy.replace_enabled;\n            self.selection_search_enabled = deploy.selection_search_enabled;\n            if deploy.focus {\n                let mut handle = self.query_editor.focus_handle(cx).clone();\n                let mut select_query = true;\n                if deploy.replace_enabled && handle.is_focused(window) {\n                    handle = self.replacement_editor.focus_handle(cx).clone();\n                    select_query = false;\n                };\n\n                if select_query {\n                    self.select_query(window, cx);\n                }\n\n                window.focus(&handle);\n            }\n            return true;\n        }\n\n        cx.propagate();\n        false\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/search/src/buffer_search.rs\n            editor_scroll_handle: ScrollHandle::new(),\n            editor_needed_width: px(0.),\n        }\n    }\n\n    pub fn is_dismissed(&self) -> bool {\n        self.dismissed\n    }\n\n    pub fn dismiss(&mut self, _: &Dismiss, window: &mut Window, cx: &mut Context<Self>) {\n        self.dismissed = true;\n        for searchable_item in self.searchable_items_with_matches.keys() {\n            if let Some(searchable_item) =\n                WeakSearchableItemHandle::upgrade(searchable_item.as_ref(), cx)\n            {\n                searchable_item.clear_matches(window, cx);\n            }\n        }\n        if let Some(active_editor) = self.active_searchable_item.as_mut() {\n            self.selection_search_enabled = false;\n            self.replace_enabled = false;\n<|editable_region_start|>\n            active_editor.search_bar_visibility_changed(false, window, cx);\n            active_editor.toggle_filtered_search_ranges(false, window, cx);\n            let handle = active_editor.item_focus_handle(cx);\n            self.focus(&handle, window, cx);\n        }\n        cx.emit(Event::UpdateLocation);\n        cx.emit(ToolbarItemEvent::ChangeLocation(\n            ToolbarItemLocation::Hidden,\n        ));\n        cx.notify();\n    }\n    \n    pub fn deploy_replace(&mut self, _: &DeployReplace, window: &mut Window, cx: &mut Context<Self>) -> bool {\n        \n    }\n\n    pub fn deploy(&mut self, deploy: &Deploy, window: &mut Window, cx: &mut Context<Self>) -> bool {\n        if self.show(window, cx) {\n            if let Some(active_item) = self.active_searchable_item.as_mut() {\n                active_item.toggle_filtered_search_ranges(\n<|editable_region_end|>\n                    deploy.selection_search_enabled,\n                    window,\n                    cx,\n                );\n            }\n            self.search_suggested(window, cx);\n            self.smartcase(window, cx);\n            self.replace_enabled = deploy.replace_enabled;\n            self.selection_search_enabled = deploy.selection_search_enabled;\n            if deploy.focus {\n                let mut handle = self.query_editor.focus_handle(cx).clone();\n                let mut select_query = true;\n                if deploy.replace_enabled && handle.is_focused(window) {\n                    handle = self.replacement_editor.focus_handle(cx).clone();\n                    select_query = false;\n                };\n\n                if select_query {\n                    self.select_query(window, cx);\n                }\n\n                window.focus(&handle);\n            }\n            return true;\n        }\n\n        cx.propagate();\n        false\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zed/src/zed.rs\":\n```diff\n@@ -245,6 +245,7 @@\n \n     cx.observe_flag::<feature_flags::ZedPro, _>({\n         move |is_enabled, cx| {\n+            C\n             CommandPaletteFilter::update_global(cx, |filter, _cx| {\n                 if is_enabled {\n                     filter.show_action_types(zed_pro_actions.iter());\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/zed/src/zed.rs\n        auto_update_ui::notify_of_any_new_update(window, cx);\n\n        let handle = cx.entity().downgrade();\n        window.on_window_should_close(cx, move |window, cx| {\n<|editable_region_start|>\n            handle\n                .update(cx, |workspace, cx| {\n                    // We'll handle closing asynchronously\n                    workspace.close_window(&Default::default(), window, cx);\n                    false\n                })\n                .unwrap_or(true)\n        });\n\n        initialize_panels(prompt_builder.clone(), window, cx);\n        register_actions(app_state.clone(), workspace, window, cx);\n\n        workspace.focus_handle(cx).focus(window);\n    })\n    .detach();\n\n    feature_gate_zed_pro_actions(cx);\n}\n\nfn feature_gate_zed_pro_actions(cx: &mut App) {\n    let zed_pro_actions = [TypeId::of::<OpenAccountSettings>()];\n\n    CommandPaletteFilter::update_global(cx, |filter, _cx| {\n        filter.hide_action_types(&zed_pro_actions);\n    });\n\n    cx.observe_flag::<feature_flags::ZedPro, _>({\n        move |is_enabled, cx| {\n            C\n            CommandPaletteFilter::update_global(cx, |filter, _cx| {\n                if is_enabled {\n                    filter.show_action_types(zed_pro_actions.iter());\n                } else {\n                    filter.hide_action_types(&zed_pro_actions);\n                }\n            });\n        }\n    })\n    <|user_cursor_is_here|>.detach();\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\nfn initialize_file_watcher(window: &mut Window, cx: &mut Context<Workspace>) {\n    if let Err(e) = fs::fs_watcher::global(|_| {}) {\n        let message = format!(\n            db::indoc! {r#\"\n            inotify_init returned {}\n\n            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux\n            \"#},\n            e\n        );\n        let prompt = window.prompt(\n            PromptLevel::Critical,\n            \"Could not start inotify\",\n            Some(&message),\n            &[\"Troubleshoot and Quit\"],\n            cx,\n        );\n<|editable_region_end|>\n        cx.spawn(|_, cx| async move {\n            if prompt.await == Ok(0) {\n                cx.update(|cx| {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/zed/src/zed.rs\n        auto_update_ui::notify_of_any_new_update(window, cx);\n\n        let handle = cx.entity().downgrade();\n        window.on_window_should_close(cx, move |window, cx| {\n<|editable_region_start|>\n            handle\n                .update(cx, |workspace, cx| {\n                    // We'll handle closing asynchronously\n                    workspace.close_window(&Default::default(), window, cx);\n                    false\n                })\n                .unwrap_or(true)\n        });\n\n        initialize_panels(prompt_builder.clone(), window, cx);\n        register_actions(app_state.clone(), workspace, window, cx);\n\n        workspace.focus_handle(cx).focus(window);\n    })\n    .detach();\n\n    feature_gate_zed_pro_actions(cx);\n}\n\nfn feature_gate_zed_pro_actions(cx: &mut App) {\n    let zed_pro_actions = [TypeId::of::<OpenAccountSettings>()];\n\n    CommandPaletteFilter::update_global(cx, |filter, _cx| {\n        filter.hide_action_types(&zed_pro_actions);\n    });\n\n    cx.observe_flag::<feature_flags::ZedPro, _>({\n        move |is_enabled, cx| {\n            CommandPalette\n            CommandPaletteFilter::update_global(cx, |filter, _cx| {\n                if is_enabled {\n                    filter.show_action_types(zed_pro_actions.iter());\n                } else {\n                    filter.hide_action_types(&zed_pro_actions);\n                }\n            });\n        }\n    })\n    .detach();\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\nfn initialize_file_watcher(window: &mut Window, cx: &mut Context<Workspace>) {\n    if let Err(e) = fs::fs_watcher::global(|_| {}) {\n        let message = format!(\n            db::indoc! {r#\"\n            inotify_init returned {}\n\n            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux\n            \"#},\n            e\n        );\n        let prompt = window.prompt(\n            PromptLevel::Critical,\n            \"Could not start inotify\",\n            Some(&message),\n            &[\"Troubleshoot and Quit\"],\n            cx,\n        );\n<|editable_region_end|>\n        cx.spawn(|_, cx| async move {\n            if prompt.await == Ok(0) {\n                cx.update(|cx| {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -614,7 +614,7 @@\n     pub fn highlight_edits_in_range(\n         &self,\n         current_snapshot: &BufferSnapshot,\n-        range: Range<usize>,\n+        range: Range<A>,\n         edits: &[(Range<Anchor>, String)],\n         include_deletions: bool,\n         cx: &App,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/language/src/buffer.rs\n/// A runnable is a set of data about a region that could be resolved into a task\npub struct Runnable {\n    pub tags: SmallVec<[RunnableTag; 1]>,\n    pub language: Arc<Language>,\n    pub buffer: BufferId,\n}\n\n#[derive(Clone)]\npub struct EditPreview {\n    old_snapshot: text::BufferSnapshot,\n    applied_edits_snapshot: text::BufferSnapshot,\n    syntax_snapshot: SyntaxSnapshot,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct HighlightedEdits {\n    pub text: SharedString,\n    pub highlights: Vec<(Range<usize>, HighlightStyle)>,\n}\n\nimpl EditPreview {\n    pub fn highlight_edits(\n            &self,\n            current_snapshot: &BufferSnapshot,\n            edits: &[(Range<Anchor>, String)],\n            include_deletions: bool,\n<|editable_region_start|>\n            cx: &App,\n        ) -> HighlightedEdits {\n    }\n    \n    pub fn highlight_edits_in_range(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        range: Range<A>,\n        edits: &[(Range<Anchor>, String)],\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let Some(visible_range_in_preview_snapshot) = self.compute_visible_range(edits) else {\n            return HighlightedEdits::default();\n        };\n\n        let mut text = String::new();\n        let mut highlights = Vec::new();\n\n        let mut offset_in_preview_snapshot = visible_range_in_preview_snapshot.start;\n\n        let insertion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..Default::default()\n        };\n        let deletion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().deleted_background),\n            ..Default::default()\n        };\n\n        for (range, edit_text) in edits {\n            let edit_new_end_in_preview_snapshot = range\n                .end\n                .bias_right(&self.old_snapshot)\n             <|user_cursor_is_here|>   .to_offset(&self.applied_edits_snapshot);\n            let edit_start_in_preview_snapshot = edit_new_end_in_preview_snapshot - edit_text.len();\n<|editable_region_end|>\n\n            let unchanged_range_in_preview_snapshot =\n                offset_in_preview_snapshot..edit_start_in_preview_snapshot;\n            if !unchanged_range_in_preview_snapshot.is_empty() {\n                Self::highlight_text(\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/language/src/buffer.rs\n/// A runnable is a set of data about a region that could be resolved into a task\npub struct Runnable {\n    pub tags: SmallVec<[RunnableTag; 1]>,\n    pub language: Arc<Language>,\n    pub buffer: BufferId,\n}\n\n#[derive(Clone)]\npub struct EditPreview {\n    old_snapshot: text::BufferSnapshot,\n    applied_edits_snapshot: text::BufferSnapshot,\n    syntax_snapshot: SyntaxSnapshot,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct HighlightedEdits {\n    pub text: SharedString,\n    pub highlights: Vec<(Range<usize>, HighlightStyle)>,\n}\n\nimpl EditPreview {\n    pub fn highlight_edits(\n            &self,\n            current_snapshot: &BufferSnapshot,\n            edits: &[(Range<Anchor>, String)],\n            include_deletions: bool,\n<|editable_region_start|>\n            cx: &App,\n        ) -> HighlightedEdits {\n    }\n    \n    pub fn highlight_edits_in_range(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        range: Range<Anchor>,\n        edits: &[(Range<Anchor>, String)],\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let Some(visible_range_in_preview_snapshot) = self.compute_visible_range(edits) else {\n            return HighlightedEdits::default();\n        };\n\n        let mut text = String::new();\n        let mut highlights = Vec::new();\n\n        let mut offset_in_preview_snapshot = visible_range_in_preview_snapshot.start;\n\n        let insertion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..Default::default()\n        };\n        let deletion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().deleted_background),\n            ..Default::default()\n        };\n\n        for (range, edit_text) in edits {\n            let edit_new_end_in_preview_snapshot = range\n                .end\n                .bias_right(&self.old_snapshot)\n                .to_offset(&self.applied_edits_snapshot);\n            let edit_start_in_preview_snapshot = edit_new_end_in_preview_snapshot - edit_text.len();\n<|editable_region_end|>\n\n            let unchanged_range_in_preview_snapshot =\n                offset_in_preview_snapshot..edit_start_in_preview_snapshot;\n            if !unchanged_range_in_preview_snapshot.is_empty() {\n                Self::highlight_text(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/terminal_view/src/terminal_panel.rs\":\n```diff\n@@ -1144,7 +1144,7 @@\n                             terminal_panel\n                                 .workspace\n                                 .update(cx, |workspace, cx| {\n-                                    workspace.activate_pane_in_direction(, window, cx)\n+                                    workspace.activate_pane_in_direction(Spl, window, cx)\n                                 })\n                                 .ok();\n                         }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/terminal_view/src/terminal_panel.rs\n                    .item_of_type::<BufferSearchBar>()\n            },\n            cx,\n        );\n        BufferSearchBar::register(&mut registrar);\n        let registrar = registrar.into_div();\n        self.workspace\n            .update(cx, |workspace, cx| {\n                registrar.size_full().child(self.center.render(\n                    workspace.project(),\n                    &HashMap::default(),\n                    None,\n<|editable_region_start|>\n                    &self.active_pane,\n                    workspace.zoomed_item(),\n                    workspace.app_state(),\n                    window,\n                    cx,\n                ))\n            })\n            .ok()\n            .map(|div| {\n                div.on_action({\n                    cx.listener(|terminal_panel, action: &ActivatePaneLeft, window, cx| {\n                        if let Some(pane) = terminal_panel.center.find_pane_in_direction(\n                            &terminal_panel.active_pane,\n                            action.0,\n                            cx,\n                        ) {\n                            window.focus(&pane.focus_handle(cx));\n                        } else {\n                            terminal_panel\n                                .workspace\n                                .update(cx, |workspace, cx| {\n                                    workspace.activate_pane_in_direction(Spl, window, cx)\n                                })\n                                .ok();\n                        }\n                    })\n                })\n                .on_action(\n                    cx.listener(|terminal_panel, _action: &ActivateNextPane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n                        if let Some(ix) = panes\n                            .iter()\n                            .position(|pane| **pane == terminal_panel.active_pane)\n                        {\n                            let next_ix = (ix + 1) % panes.len();\n                            window.focus(&panes[next_ix].focus_handle(cx));\n                        }\n                    }),\n                )\n                .on_action(cx.listener(\n                    |terminal_panel, _action: &ActivatePreviousPane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n                        if let Some(ix) = panes\n                            .iter()\n                            .position(|pane| **pane == terminal_panel.active_pane)\n                        {\n                            let prev_ix = cmp::min(ix.wrapping_sub(1), panes.len() - 1);\n                            window.focus(&panes[prev_ix].focus_handle(cx));\n                        }\n                    },\n                ))\n    <|user_cursor_is_here|>            .on_action(\n                    cx.listener(|terminal_panel, action: &ActivatePane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n<|editable_region_end|>\n                        if let Some(&pane) = panes.get(action.0) {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/terminal_view/src/terminal_panel.rs\n                    .item_of_type::<BufferSearchBar>()\n            },\n            cx,\n        );\n        BufferSearchBar::register(&mut registrar);\n        let registrar = registrar.into_div();\n        self.workspace\n            .update(cx, |workspace, cx| {\n                registrar.size_full().child(self.center.render(\n                    workspace.project(),\n                    &HashMap::default(),\n                    None,\n<|editable_region_start|>\n                    &self.active_pane,\n                    workspace.zoomed_item(),\n                    workspace.app_state(),\n                    window,\n                    cx,\n                ))\n            })\n            .ok()\n            .map(|div| {\n                div.on_action({\n                    cx.listener(|terminal_panel, action: &ActivatePaneLeft, window, cx| {\n                        if let Some(pane) = terminal_panel.center.find_pane_in_direction(\n                            &terminal_panel.active_pane,\n                            action.0,\n                            cx,\n                        ) {\n                            window.focus(&pane.focus_handle(cx));\n                        } else {\n                            terminal_panel\n                                .workspace\n                                .update(cx, |workspace, cx| {\n                                    workspace.activate_pane_in_direction(SplitDirection::Left, window, cx)\n                                })\n                                .ok();\n                        }\n                    })\n                })\n                .on_action(\n                    cx.listener(|terminal_panel, _action: &ActivateNextPane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n                        if let Some(ix) = panes\n                            .iter()\n                            .position(|pane| **pane == terminal_panel.active_pane)\n                        {\n                            let next_ix = (ix + 1) % panes.len();\n                            window.focus(&panes[next_ix].focus_handle(cx));\n                        }\n                    }),\n                )\n                .on_action(cx.listener(\n                    |terminal_panel, _action: &ActivatePreviousPane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n                        if let Some(ix) = panes\n                            .iter()\n                            .position(|pane| **pane == terminal_panel.active_pane)\n                        {\n                            let prev_ix = cmp::min(ix.wrapping_sub(1), panes.len() - 1);\n                            window.focus(&panes[prev_ix].focus_handle(cx));\n                        }\n                    },\n                ))\n                .on_action(\n                    cx.listener(|terminal_panel, action: &ActivatePane, window, cx| {\n                        let panes = terminal_panel.center.panes();\n<|editable_region_end|>\n                        if let Some(&pane) = panes.get(action.0) {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/extension_host/src/wasm_host/wit/since_v0_2_0.rs\":\n```diff\n@@ -109,7 +109,7 @@\n             detail: value.detail,\n             kind: value.kind.map(Into::into),\n             insert_text_format: value.insert_text_format.map(Into::into),\n-            # filter_text: value.filter_text,\n+            /filter_text: value.filter_text,\n         }\n     }\n }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/extension_host/src/wasm_host/wit/since_v0_2_0.rs\n            code: value.code,\n            spans: value.spans.into_iter().map(Into::into).collect(),\n            filter_range: value.filter_range.into(),\n        }\n    }\n}\n\nimpl From<CodeLabelSpan> for extension::CodeLabelSpan {\n<|editable_region_start|>\n    fn from(value: CodeLabelSpan) -> Self {\n        match value {\n            CodeLabelSpan::CodeRange(range) => Self::CodeRange(range.into()),\n            CodeLabelSpan::Literal(literal) => Self::Literal(literal.into()),\n        }\n    }\n}\n\nimpl From<CodeLabelSpanLiteral> for extension::CodeLabelSpanLiteral {\n    fn from(value: CodeLabelSpanLiteral) -> Self {\n        Self {\n            text: value.text,\n            highlight_name: value.highlight_name,\n        }\n    }\n}\n\nimpl From<extension::Completion> for Completion {\n    fn from(value: extension::Completion) -> Self {\n        Self {\n            label: value.label,\n            label_details: value.label_details.map(Into::into),\n            detail: value.detail,\n            kind: value.kind.map(Into::into),\n            insert_text_format: value.insert_text_format.map(Into::into),\n            /<|user_cursor_is_here|>filter_text: value.filter_text,\n        }\n    }\n}\n\nimpl From<extension::CompletionLabelDetails> for CompletionLabelDetails {\n    fn from(value: extension::CompletionLabelDetails) -> Self {\n        Self {\n            detail: value.detail,\n            description: value.description,\n        }\n    }\n}\n\n<|editable_region_end|>\nimpl From<extension::CompletionKind> for CompletionKind {\n    fn from(value: extension::CompletionKind) -> Self {\n        match value {\n            extension::CompletionKind::Text => Self::Text,\n            extension::CompletionKind::Method => Self::Method,\n            extension::CompletionKind::Function => Self::Function,\n            extension::CompletionKind::Constructor => Self::Constructor,\n            extension::CompletionKind::Field => Self::Field,\n            extension::CompletionKind::Variable => Self::Variable,\n            extension::CompletionKind::Class => Self::Class,\n            extension::CompletionKind::Interface => Self::Interface,\n            extension::CompletionKind::Module => Self::Module,\n            extension::CompletionKind::Property => Self::Property,\n            extension::CompletionKind::Unit => Self::Unit,\n            extension::CompletionKind::Value => Self::Value,\n            extension::CompletionKind::Enum => Self::Enum,\n            extension::CompletionKind::Keyword => Self::Keyword,\n            extension::CompletionKind::Snippet => Self::Snippet,\n            extension::CompletionKind::Color => Self::Color,\n            extension::CompletionKind::File => Self::File,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/extension_host/src/wasm_host/wit/since_v0_2_0.rs\n            code: value.code,\n            spans: value.spans.into_iter().map(Into::into).collect(),\n            filter_range: value.filter_range.into(),\n        }\n    }\n}\n\nimpl From<CodeLabelSpan> for extension::CodeLabelSpan {\n<|editable_region_start|>\n    fn from(value: CodeLabelSpan) -> Self {\n        match value {\n            CodeLabelSpan::CodeRange(range) => Self::CodeRange(range.into()),\n            CodeLabelSpan::Literal(literal) => Self::Literal(literal.into()),\n        }\n    }\n}\n\nimpl From<CodeLabelSpanLiteral> for extension::CodeLabelSpanLiteral {\n    fn from(value: CodeLabelSpanLiteral) -> Self {\n        Self {\n            text: value.text,\n            highlight_name: value.highlight_name,\n        }\n    }\n}\n\nimpl From<extension::Completion> for Completion {\n    fn from(value: extension::Completion) -> Self {\n        Self {\n            label: value.label,\n            label_details: value.label_details.map(Into::into),\n            detail: value.detail,\n            kind: value.kind.map(Into::into),\n            insert_text_format: value.insert_text_format.map(Into::into),\n            // filter_text: value.filter_text,\n        }\n    }\n}\n\nimpl From<extension::CompletionLabelDetails> for CompletionLabelDetails {\n    fn from(value: extension::CompletionLabelDetails) -> Self {\n        Self {\n            detail: value.detail,\n            description: value.description,\n        }\n    }\n}\n\n<|editable_region_end|>\nimpl From<extension::CompletionKind> for CompletionKind {\n    fn from(value: extension::CompletionKind) -> Self {\n        match value {\n            extension::CompletionKind::Text => Self::Text,\n            extension::CompletionKind::Method => Self::Method,\n            extension::CompletionKind::Function => Self::Function,\n            extension::CompletionKind::Constructor => Self::Constructor,\n            extension::CompletionKind::Field => Self::Field,\n            extension::CompletionKind::Variable => Self::Variable,\n            extension::CompletionKind::Class => Self::Class,\n            extension::CompletionKind::Interface => Self::Interface,\n            extension::CompletionKind::Module => Self::Module,\n            extension::CompletionKind::Property => Self::Property,\n            extension::CompletionKind::Unit => Self::Unit,\n            extension::CompletionKind::Value => Self::Value,\n            extension::CompletionKind::Enum => Self::Enum,\n            extension::CompletionKind::Keyword => Self::Keyword,\n            extension::CompletionKind::Snippet => Self::Snippet,\n            extension::CompletionKind::Color => Self::Color,\n            extension::CompletionKind::File => Self::File,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -620,6 +620,8 @@\n             cx,\n         )\n     }\n+    \n+    pub\n \n     fn highlight_edits_in_range(\n         &self,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/language/src/buffer.rs\n#[derive(Clone)]\npub struct EditPreview {\n    old_snapshot: text::BufferSnapshot,\n    applied_edits_snapshot: text::BufferSnapshot,\n    syntax_snapshot: SyntaxSnapshot,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct HighlightedEdits {\n    pub text: SharedString,\n    pub highlights: Vec<(Range<usize>, HighlightStyle)>,\n}\n\nimpl EditPreview {\n    pub fn highlight_edits(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        edits: &[(Range<Anchor>, String)],\n<|editable_region_start|>\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let Some(visible_range_in_preview_snapshot) = self.compute_visible_range(edits) else {\n            return HighlightedEdits::default();\n        };\n        highlight_edits_in_range(\n            current_snapshot,\n            visible_range_in_preview_snapshot,\n            edits,\n            include_deletions,\n            cx,\n        )\n    }\n    \n    pub<|user_cursor_is_here|>\n\n    fn highlight_edits_in_range(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        visible_range_in_preview_snapshot: Range<usize>,\n        edits: &[(Range<Anchor>, String)],\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let mut text = String::new();\n        let mut highlights = Vec::new();\n\n        let mut offset_in_preview_snapshot = visible_range_in_preview_snapshot.start;\n\n        let insertion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..Default::default()\n        };\n        let deletion_highlight_style = HighlightStyle {\n<|editable_region_end|>\n            background_color: Some(cx.theme().status().deleted_background),\n            ..Default::default()\n        };\n\n        for (range, edit_text) in edits {\n            let edit_new_end_in_preview_snapshot = range\n                .end\n                .bias_right(&self.old_snapshot)\n                .to_offset(&self.applied_edits_snapshot);\n            let edit_start_in_preview_snapshot = edit_new_end_in_preview_snapshot - edit_text.len();\n\n            if visible_range_in_preview_snapshot.end < edit_start_in_preview_snapshot {\n                break;\n            }\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/language/src/buffer.rs\n#[derive(Clone)]\npub struct EditPreview {\n    old_snapshot: text::BufferSnapshot,\n    applied_edits_snapshot: text::BufferSnapshot,\n    syntax_snapshot: SyntaxSnapshot,\n}\n\n#[derive(Default, Clone, Debug)]\npub struct HighlightedEdits {\n    pub text: SharedString,\n    pub highlights: Vec<(Range<usize>, HighlightStyle)>,\n}\n\nimpl EditPreview {\n    pub fn highlight_edits(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        edits: &[(Range<Anchor>, String)],\n<|editable_region_start|>\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let Some(visible_range_in_preview_snapshot) = self.compute_visible_range(edits) else {\n            return HighlightedEdits::default();\n        };\n        highlight_edits_in_range(\n            current_snapshot,\n            visible_range_in_preview_snapshot,\n            edits,\n            include_deletions,\n            cx,\n        )\n    }\n    \n    pub fn \n    \n    fn highlight_edits_in_range(\n        &self,\n        current_snapshot: &BufferSnapshot,\n        visible_range_in_preview_snapshot: Range<usize>,\n        edits: &[(Range<Anchor>, String)],\n        include_deletions: bool,\n        cx: &App,\n    ) -> HighlightedEdits {\n        let mut text = String::new();\n        let mut highlights = Vec::new();\n\n        let mut offset_in_preview_snapshot = visible_range_in_preview_snapshot.start;\n\n        let insertion_highlight_style = HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..Default::default()\n        };\n        let deletion_highlight_style = HighlightStyle {\n<|editable_region_end|>\n            background_color: Some(cx.theme().status().deleted_background),\n            ..Default::default()\n        };\n\n        for (range, edit_text) in edits {\n            let edit_new_end_in_preview_snapshot = range\n                .end\n                .bias_right(&self.old_snapshot)\n                .to_offset(&self.applied_edits_snapshot);\n            let edit_start_in_preview_snapshot = edit_new_end_in_preview_snapshot - edit_text.len();\n\n            if visible_range_in_preview_snapshot.end < edit_start_in_preview_snapshot {\n                break;\n            }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/call/src/cross_platform/room.rs\":\n```diff\n@@ -531,6 +531,7 @@\n     pub fn local_participant(&self) -> &LocalParticipant {\n         &self.local_participant\n     }\n+    \n \n     pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {\n         &self.remote_participants\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/call/src/cross_platform/room.rs\n                for reshared_project in response.reshared_projects {\n                    if let Some(project) = projects.get(&reshared_project.id) {\n                        project.update(cx, |project, cx| {\n                            project.reshared(reshared_project, cx).log_err();\n                        });\n                    }\n                }\n\n                for rejoined_project in response.rejoined_projects {\n                    if let Some(project) = projects.get(&rejoined_project.id) {\n                        project.update(cx, |project, cx| {\n                            project.rejoined(rejoined_project, message_id, cx).log_err();\n                        });\n                    }\n                }\n\n                anyhow::Ok(())\n            })?\n        })\n    }\n\n<|editable_region_start|>\n    pub fn id(&self) -> u64 {\n        self.id\n    }\n\n    pub fn status(&self) -> RoomStatus {\n        self.status\n    }\n\n    pub fn local_participant(&self) -> &LocalParticipant {\n        &self.local_participant\n    }\n    <|user_cursor_is_here|>\n\n    pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {\n        &self.remote_participants\n    }\n\n    pub fn remote_participant_for_peer_id(&self, peer_id: PeerId) -> Option<&RemoteParticipant> {\n        self.remote_participants\n            .values()\n            .find(|p| p.peer_id == peer_id)\n    }\n<|editable_region_end|>\n\n    pub fn role_for_user(&self, user_id: u64) -> Option<proto::ChannelRole> {\n        self.remote_participants\n            .get(&user_id)\n            .map(|participant| participant.role)\n    }\n\n    pub fn contains_guests(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Guest\n            || self\n                .remote_participants\n                .values()\n                .any(|p| p.role == proto::ChannelRole::Guest)\n    }\n\n    pub fn local_participant_is_admin(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Admin\n    }\n\n    pub fn local_participant_is_guest(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Guest\n    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/call/src/cross_platform/room.rs\n                for reshared_project in response.reshared_projects {\n                    if let Some(project) = projects.get(&reshared_project.id) {\n                        project.update(cx, |project, cx| {\n                            project.reshared(reshared_project, cx).log_err();\n                        });\n                    }\n                }\n\n                for rejoined_project in response.rejoined_projects {\n                    if let Some(project) = projects.get(&rejoined_project.id) {\n                        project.update(cx, |project, cx| {\n                            project.rejoined(rejoined_project, message_id, cx).log_err();\n                        });\n                    }\n                }\n\n                anyhow::Ok(())\n            })?\n        })\n    }\n\n<|editable_region_start|>\n    pub fn id(&self) -> u64 {\n        self.id\n    }\n\n    pub fn status(&self) -> RoomStatus {\n        self.status\n    }\n\n    pub fn local_participant(&self) -> &LocalParticipant {\n        &self.local_participant\n    }\n    \n    pub fn local_participant_mut(&mut self) -> &mut LocalParticipant {\n        &mut self.local_participant\n    }\n\n    pub fn remote_participants(&self) -> &BTreeMap<u64, RemoteParticipant> {\n        &self.remote_participants\n    }\n\n    pub fn remote_participant_for_peer_id(&self, peer_id: PeerId) -> Option<&RemoteParticipant> {\n        self.remote_participants\n            .values()\n            .find(|p| p.peer_id == peer_id)\n    }\n<|editable_region_end|>\n\n    pub fn role_for_user(&self, user_id: u64) -> Option<proto::ChannelRole> {\n        self.remote_participants\n            .get(&user_id)\n            .map(|participant| participant.role)\n    }\n\n    pub fn contains_guests(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Guest\n            || self\n                .remote_participants\n                .values()\n                .any(|p| p.role == proto::ChannelRole::Guest)\n    }\n\n    pub fn local_participant_is_admin(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Admin\n    }\n\n    pub fn local_participant_is_guest(&self) -> bool {\n        self.local_participant.role == proto::ChannelRole::Guest\n    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"observation_request/TURMField.py\":\n```diff\n@@ -84,6 +84,8 @@\n         widget = TURMField.model_field_to_input(\n             model_field, measurement_unit, *args, **kwargs\n         )\n+        \n+        \n         return TURMField(label=label_name, widget=widget)\n \n     def add_attrs(self, attr):\n\n```\n\nUser edited \"observation_request/TURMField.py\":\n```diff\n@@ -84,8 +84,6 @@\n         widget = TURMField.model_field_to_input(\n             model_field, measurement_unit, *args, **kwargs\n         )\n-        \n-        \n         return TURMField(label=label_name, widget=widget)\n \n     def add_attrs(self, attr):\n\n```\n\nUser edited \"observation_request/TURMField.py\":\n```diff\n@@ -78,12 +78,12 @@\n     def init_from_model(\n         cls, model_field, label_name: str = None, measurement_unit=None, *args, **kwargs\n     ):\n-        print(label_name)\n         if label_name is None:\n             label_name = str(model_field.name).replace(\"_\", \" \")\n         widget = TURMField.model_field_to_input(\n             model_field, measurement_unit, *args, **kwargs\n         )\n+        \n         return TURMField(label=label_name, widget=widget)\n \n     def add_attrs(self, attr):\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```TURMFrontend/observation_request/TURMField.py\n                    *args,\n                    **kwargs,\n                )\n            case models.ForeignKey:\n                return TURMRadioInput(\n                    name=model_field.name,\n                    choices=[\n                        (str(name), str(name))\n                        for name in model_field.remote_field.model.objects.all()\n                    ],\n                    *args,\n                    **kwargs,\n                )\n<|editable_region_start|>\n            case models.DateTimeField:\n                return TURMDateTimeInput(name=model_field.name, *args, **kwargs)\n            case models.DateField:\n                return TURMDateInput(name=model_field.name, *args, **kwargs)\n            case models.CharField:\n                return TURMCharInput(\n                    name=model_field.name, placeholder=\"\", *args, **kwargs\n                )\n            case _:\n                raise NotImplementedError(f\"{type(model_field)} is not supported yet.\")\n\n    @classmethod\n    def init_from_model(\n        cls, model_field, label_name: str = None, measurement_unit=None, *args, **kwargs\n    ):\n        if label_name is None:\n            label_name = str(model_field.name).replace(\"_\", \" \")\n        widget = TURMField.model_field_to_input(\n            model_field, measurement_unit, *args, **kwargs\n        )\n        <|user_cursor_is_here|>\n<|editable_region_end|>\n        return TURMField(label=label_name, widget=widget)\n\n    def add_attrs(self, attr):\n        self.widget.add_attrs(attr)\n        return self\n\n    def add_dependencies(self, add_dependencies):\n        self.widget.add_dependencies(add_dependencies)\n        return self\n\n    def add_dependency_generator(self, dependency_generator):\n        self.widget.add_dependency_generator(dependency_generator)\n        return self\n\n    def add_tooltip(self, tooltip):\n        if isinstance(self.widget, _TURMChoiceInput):\n            self.widget.add_tooltip(tooltip)\n        return self\n\n    def add_on_click(self, func_call_generator):\n        self.widget.add_on_click(func_call_generator)\n        return self\n\n\nclass TURMSelectField(TURMField):\n    \"\"\"\n    Provides functionality for a row of checkboxes\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        choices: list[tuple[str, str]],\n```"}, {"role": "assistant", "content": "Suggestion:\n```TURMFrontend/observation_request/TURMField.py\n                    *args,\n                    **kwargs,\n                )\n            case models.ForeignKey:\n                return TURMRadioInput(\n                    name=model_field.name,\n                    choices=[\n                        (str(name), str(name))\n                        for name in model_field.remote_field.model.objects.all()\n                    ],\n                    *args,\n                    **kwargs,\n                )\n<|editable_region_start|>\n            case models.DateTimeField:\n                return TURMDateTimeInput(name=model_field.name, *args, **kwargs)\n            case models.DateField:\n                return TURMDateInput(name=model_field.name, *args, **kwargs)\n            case models.CharField:\n                return TURMCharInput(\n                    name=model_field.name, placeholder=\"\", *args, **kwargs\n                )\n            case _:\n                raise NotImplementedError(f\"{type(model_field)} is not supported yet.\")\n\n    @classmethod\n    def init_from_model(\n        cls, model_field, label_name: str = None, measurement_unit=None, *args, **kwargs\n    ):\n        if label_name is None:\n            label_name = str(model_field.name).replace(\"_\", \" \")\n        widget = TURMField.model_field_to_input(\n            model_field, measurement_unit, *args, **kwargs\n        )\n        \n<|editable_region_end|>\n        return TURMField(label=label_name, widget=widget)\n\n    def add_attrs(self, attr):\n        self.widget.add_attrs(attr)\n        return self\n\n    def add_dependencies(self, add_dependencies):\n        self.widget.add_dependencies(add_dependencies)\n        return self\n\n    def add_dependency_generator(self, dependency_generator):\n        self.widget.add_dependency_generator(dependency_generator)\n        return self\n\n    def add_tooltip(self, tooltip):\n        if isinstance(self.widget, _TURMChoiceInput):\n            self.widget.add_tooltip(tooltip)\n        return self\n\n    def add_on_click(self, func_call_generator):\n        self.widget.add_on_click(func_call_generator)\n        return self\n\n\nclass TURMSelectField(TURMField):\n    \"\"\"\n    Provides functionality for a row of checkboxes\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        choices: list[tuple[str, str]],\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"app/controllers/polls/questions_controller.rb\":\n```diff\n@@ -4,7 +4,7 @@\n   def create\n     @question = @poll.questions.build\n \n-    if @question.save \n+    if @question.save && @question.recalculate_choice_positions\n       redirect_to @question\n     else\n       redirect_back fallback_location: polls_path,\n\n```\n\nUser edited \"app/controllers/polls/questions_controller.rb\":\n```diff\n@@ -4,7 +4,7 @@\n   def create\n     @question = @poll.questions.build\n \n-    if @question.save && @question.recalculate_choice_positions\n+    if @question.save\n       redirect_to @question\n     else\n       redirect_back fallback_location: polls_path,\n\n```\n\nUser edited \"app/controllers/polls/questions_controller.rb\":\n```diff\n@@ -4,7 +4,7 @@\n   def create\n     @question = @poll.questions.build\n \n-    if @question.save\n+    if @question.save &&\n       redirect_to @question\n     else\n       redirect_back fallback_location: polls_path,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```app/controllers/polls/questions_controller.rb\n<|start_of_file|>\n<|editable_region_start|>\nclass Polls::QuestionsController < AuthenticatedController\n  include PollScoped\n\n  def create\n    @question = @poll.questions.build\n<|user_cursor_is_here|>\n    if @question.save &&\n      redirect_to @question\n    else\n      redirect_back fallback_location: polls_path,\n        alert: @question.formatted_errors\n    end\n  end\n<|editable_region_end|>\nend\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```app/controllers/polls/questions_controller.rb\n<|start_of_file|>\n<|editable_region_start|>\nclass Polls::QuestionsController < AuthenticatedController\n  include PollScoped\n\n  def create\n    @question = @poll.questions.build\n\n    if @question.save && @question.formatted_errors.empty?\n      redirect_to @question\n    else\n      redirect_back fallback_location: polls_path,\n        alert: @question.formatted_errors\n    end\n  end\n<|editable_region_end|>\nend\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"app/views/choices/_legend.html.erb\":\n```diff\n@@ -11,7 +11,7 @@\n       data-drag-and-drop-target=\"item\"\n       data-id=\"<%= choice.id %>\"\n     >\n-      <div class=[counter-reset:question-position]\"w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n+      <div class=[counter-reset:choice-position]\"w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n         <%= render \"choices/choice\", choice:, question:, choices:, display:, label:, line_clamp: \"line-clamp-2\" %>\n       </div>\n     </li>\n\n```\n\nUser edited \"app/views/choices/_legend.html.erb\":\n```diff\n@@ -11,7 +11,7 @@\n       data-drag-and-drop-target=\"item\"\n       data-id=\"<%= choice.id %>\"\n     >\n-      <div class=[counter-reset:choice-position]\"w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n+      <div class=[counter-reset:question-position]\"w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n         <%= render \"choices/choice\", choice:, question:, choices:, display:, label:, line_clamp: \"line-clamp-2\" %>\n       </div>\n     </li>\n\n```\n\nUser edited \"app/views/choices/_legend.html.erb\":\n```diff\n@@ -11,7 +11,7 @@\n       data-drag-and-drop-target=\"item\"\n       data-id=\"<%= choice.id %>\"\n     >\n-      <div class=[counter-reset:question-position]\"w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n+      <div class=\" w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n         <%= render \"choices/choice\", choice:, question:, choices:, display:, label:, line_clamp: \"line-clamp-2\" %>\n       </div>\n     </li>\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```app/views/choices/_legend.html.erb\n<|start_of_file|>\n<|editable_region_start|>\n<ul\n  class=\"size-full flex flex-col justify-center space-y-[0.25em] @container-[size]\"\n  data-controller=\"drag-and-drop xhr\"\n  data-action=\"drag-and-drop:drop->xhr#fetch\"\n  data-xhr-url-param=\"<%= question_choice_repositionings_path(question) %>\"\n>\n  <% choices = question.choices %>\n  <% choices.each do |choice| %>\n    <li\n      class=\"<%= legend_text_size(question, choice) %> group flex items-center transition-all space-x-[0.25em] w-full <%= segment_opacity(choice) %>\"\n      data-drag-and-drop-target=\"item\"\n      data-id=\"<%= choice.id %>\"\n <|user_cursor_is_here|>   >\n      <div class=\" w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n        <%= render \"choices/choice\", choice:, question:, choices:, display:, label:, line_clamp: \"line-clamp-2\" %>\n      </div>\n    </li>\n  <% end %>\n</ul>\n<|editable_region_end|>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```app/views/choices/_legend.html.erb\n<|start_of_file|>\n<|editable_region_start|>\n<ul\n  class=\"size-full flex flex-col justify-center space-y-[0.25em] @container-[size]\"\n  data-controller=\"drag-and-drop xhr\"\n  data-action=\"drag-and-drop:drop->xhr#fetch\"\n  data-xhr-url-param=\"<%= question_choice_repositionings_path(question) %>\"\n>\n  <% choices = question.choices %>\n  <% choices.each do |choice| %>\n    <li\n      class=\"<%= legend_text_size(question, choice) %> group flex items-center transition-all space-x-[0.25em] w-full <%= segment_opacity(choice) %>\"\n      data-drag-and-drop-target=\"item\"\n      data-id=\"<%= choice.id %>\"\n    >\n      <div class=\"[counter-reset:question-position] w-full grid grid-cols-[1fr_auto] items-center auto-rows-[minmax(0,min-content)] gap-x-[0.25em] gap-y-[0.5em]\">\n        <%= render \"choices/choice\", choice:, question:, choices:, display:, label:, line_clamp: \"line-clamp-2\" %>\n      </div>\n    </li>\n  <% end %>\n</ul>\n<|editable_region_end|>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"untitled\":\n```diff\n@@ -1,3 +1,3 @@\n              [min,         mean,       50,      90,         95, 99,       max]\n-Baseten:    243.004ms, 386.077ms, 253.333ms, 662.649ms, 1.181s, 1.645s, 1.645s\n+Baseten:    325.296ms, 550.871ms, 520.54ms, 823.066ms, 854.478ms, 866.256ms, 866.256ms\n Fireworks:  163.139ms, 447.84ms, 223.762ms, 1.111s, 2.075s, 3.026s, 3.06s\n\\ No newline at end of file\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -1,3 +1,3 @@\n              [min,         mean,       50,      90,         95, 99,       max]\n-Baseten:    325.296ms, 550.871ms, 520.54ms, 823.066ms, 854.478ms, 866.256ms, 866.256ms\n+Baseten:    243.004ms, 386.077ms, 253.333ms, 662.649ms, 1.181s, 1.645s, 1.645s\n Fireworks:  163.139ms, 447.84ms, 223.762ms, 1.111s, 2.075s, 3.026s, 3.06s\n\\ No newline at end of file\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -1,3 +1,3 @@\n              [min,         mean,       50,      90,         95, 99,       max]\n-Baseten:    243.004ms, 386.077ms, 253.333ms, 662.649ms, 1.181s, 1.645s, 1.645s\n+Baseten:    325.296ms, 550.871ms, 520.54ms, 823.066ms, 854.478ms, 866.256ms, 866.256ms\n Fireworks:  163.139ms, 447.84ms, 223.762ms, 1.111s, 2.075s, 3.026s, 3.06s\n\\ No newline at end of file\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/collab/src/llm.rs\n<|start_of_file|>\nmod authorization;\npub mod db;\nmod token;\n\nuse crate::api::events::SnowflakeRow;\nuse crate::api::CloudflareIpCountryHeader;\nuse crate::build_kinesis_client;\nuse crate::{db::UserId, executor::Executor, Cents, Config, Error, Result};\nuse anyhow::{anyhow, Context as _};\nuse authorization::authorize_access_to_language_model;\nuse axum::routing::get;\nuse axum::{\n    body::Body,\n    http::{self, HeaderName, HeaderValue, Request, StatusCode},\n    middleware::{self, Next},\n    response::{IntoResponse, Response},\n    routing::post,\n    Extension, Json, Router, TypedHeader,\n};\nuse chrono::{DateTime, Duration, Utc};\nuse collections::HashMap;\nuse db::TokenUsage;\nuse db::{usage_measure::UsageMeasure, ActiveUserCount, LlmDatabase};\nuse futures::{Stream, StreamExt as _};\nuse reqwest_client::ReqwestClient;\n<|editable_region_start|>\nuse rpc::{\n    proto::Plan, LanguageModelProvider, PerformCompletionParams, EXPIRED_LLM_TOKEN_HEADER_NAME,\n};\nuse rpc::{ListModelsResponse, MAX_LLM_MONTHLY_SPEND_REACHED_HEADER_NAME};\nuse serde_json::json;\nuse std::{\n    pin::Pin,\n    sync::Arc,\n    task::{Context, Poll},\n};\nuse strum::IntoEnumIterator;\nuse tokio::sync::RwLock;\nuse util::ResultExt;\n\npub use token::*;\n\nconst ACTIVE_USER_COUNT_CACHE_DURATION: Duration = Duration::seconds(30);\n\npub stru<|user_cursor_is_here|>ct LlmState {\n    pub config: Config,\n    pub executor: Executor,\n    pub db: Arc<LlmDatabase>,\n    pub http_client: ReqwestClient,\n    pub kinesis_client: Option<aws_sdk_kinesis::Client>,\n<|editable_region_end|>\n    active_user_count_by_model:\n        RwLock<HashMap<(LanguageModelProvider, String), (DateTime<Utc>, ActiveUserCount)>>,\n}\n\nimpl LlmState {\n    pub async fn new(config: Config, executor: Executor) -> Result<Arc<Self>> {\n        let database_url = config\n            .llm_database_url\n            .as_ref()\n            .ok_or_else(|| anyhow!(\"missing LLM_DATABASE_URL\"))?;\n        let max_connections = config\n            .llm_database_max_connections\n            .ok_or_else(|| anyhow!(\"missing LLM_DATABASE_MAX_CONNECTIONS\"))?;\n\n        let mut db_options = db::ConnectOptions::new(database_url);\n        db_options.max_connections(max_connections);\n        let mut db = LlmDatabase::new(db_options, executor.clone()).await?;\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/collab/src/llm.rs\n<|start_of_file|>\nmod authorization;\npub mod db;\nmod token;\n\nuse crate::api::events::SnowflakeRow;\nuse crate::api::CloudflareIpCountryHeader;\nuse crate::build_kinesis_client;\nuse crate::{db::UserId, executor::Executor, Cents, Config, Error, Result};\nuse anyhow::{anyhow, Context as _};\nuse authorization::authorize_access_to_language_model;\nuse axum::routing::get;\nuse axum::{\n    body::Body,\n    http::{self, HeaderName, HeaderValue, Request, StatusCode},\n    middleware::{self, Next},\n    response::{IntoResponse, Response},\n    routing::post,\n    Extension, Json, Router, TypedHeader,\n};\nuse chrono::{DateTime, Duration, Utc};\nuse collections::HashMap;\nuse db::TokenUsage;\nuse db::{usage_measure::UsageMeasure, ActiveUserCount, LlmDatabase};\nuse futures::{Stream, StreamExt as _};\nuse reqwest_client::ReqwestClient;\n<|editable_region_start|>\nuse rpc::{\n    proto::Plan, LanguageModelProvider, PerformCompletionParams, EXPIRED_LLM_TOKEN_HEADER_NAME,\n};\nuse rpc::{ListModelsResponse, MAX_LLM_MONTHLY_SPEND_REACHED_HEADER_NAME};\nuse serde_json::json;\nuse std::{\n    pin::Pin,\n    sync::Arc,\n    task::{Context, Poll},\n};\nuse strum::IntoEnumIterator;\nuse tokio::sync::RwLock;\nuse util::ResultExt;\n\npub use token::*;\n\nconst ACTIVE_USER_COUNT_CACHE_DURATION: Duration = Duration::seconds(30);\n\npub struct LlmState {\n    pub config: Config,\n    pub executor: Executor,\n    pub db: Arc<LlmDatabase>,\n    pub http_client: ReqwestClient,\n    pub kinesis_client: Option<aws_sdk_kinesis::Client>,\n<|editable_region_end|>\n    active_user_count_by_model:\n        RwLock<HashMap<(LanguageModelProvider, String), (DateTime<Utc>, ActiveUserCount)>>,\n}\n\nimpl LlmState {\n    pub async fn new(config: Config, executor: Executor) -> Result<Arc<Self>> {\n        let database_url = config\n            .llm_database_url\n            .as_ref()\n            .ok_or_else(|| anyhow!(\"missing LLM_DATABASE_URL\"))?;\n        let max_connections = config\n            .llm_database_max_connections\n            .ok_or_else(|| anyhow!(\"missing LLM_DATABASE_MAX_CONNECTIONS\"))?;\n\n        let mut db_options = db::ConnectOptions::new(database_url);\n        db_options.max_connections(max_connections);\n        let mut db = LlmDatabase::new(db_options, executor.clone()).await?;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/welcome/src/welcome.rs\":\n```diff\n@@ -350,7 +350,7 @@\n     pub fn new(workspace: &Workspace, cx: &mut Context<Workspace>) -> Entity<Self> {\n         let this = cx.new(|cx| {\n             cx.on_release(|this: &mut Self, _| {\n-                telemetry::event!(\"Welcome Metric Telemetry Toggled\");\n+                telemetry::event!(\"Welcome Page Closed\");\n                 this.telemetry\n                     .report_event(\"Welcome Page Closed\".to_string());\n             })\n\n```\n\nUser edited \"crates/welcome/src/welcome.rs\":\n```diff\n@@ -351,8 +351,6 @@\n         let this = cx.new(|cx| {\n             cx.on_release(|this: &mut Self, _| {\n                 telemetry::event!(\"Welcome Page Closed\");\n-                this.telemetry\n-                    .report_event(\"Welcome Page Closed\".to_string());\n             })\n             .detach();\n \n\n```\n\nUser edited \"crates/welcome/src/welcome.rs\":\n```diff\n@@ -349,7 +349,7 @@\n impl WelcomePage {\n     pub fn new(workspace: &Workspace, cx: &mut Context<Workspace>) -> Entity<Self> {\n         let this = cx.new(|cx| {\n-            cx.on_release(|this: &mut Self, _| {\n+            cx.on_release(|_: &mut Self, _| {\n                 telemetry::event!(\"Welcome Page Closed\");\n             })\n             .detach();\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/welcome/src/welcome.rs\n                                CheckboxWithLabel::new(\n                                    \"enable-telemetry\",\n                                    Label::new(\"Send Telemetry\"),\n                                    if TelemetrySettings::get_global(cx).metrics {\n                                        ui::ToggleState::Selected\n                                    } else {\n                                        ui::ToggleState::Unselected\n                                    },\n                                    cx.listener(move |this, selection, _window, cx| {\n                                        telemetry::event!(\"Welcome Metric Telemetry Toggled\");\n                                        this.update_settings::<TelemetrySettings>(selection, cx, {\n                                            move |settings, value| {\n                                                settings.metrics = Some(value);\n                                                telemetry::event!(\n                                                    \"Settings Changed\",\n                                                    setting = \"metric telemetry\",\n                                                    value\n                                                );\n<|editable_region_start|>\n                                            }\n                                        });\n                                    }),\n                                )\n                                .fill()\n                        <|user_cursor_is_here|>        .elevation(ElevationIndex::ElevatedSurface),\n                            ),\n                    ),\n            )\n    }\n}\n\nimpl WelcomePage {\n    pub fn new(workspace: &Workspace, cx: &mut Context<Workspace>) -> Entity<Self> {\n        let this = cx.new(|cx| {\n            cx.on_release(|_: &mut Self, _| {\n                telemetry::event!(\"Welcome Page Closed\");\n<|editable_region_end|>\n            })\n            .detach();\n\n            WelcomePage {\n                focus_handle: cx.focus_handle(),\n                workspace: workspace.weak_handle(),\n                telemetry: workspace.client().telemetry().clone(),\n                _settings_subscription: cx\n                    .observe_global::<SettingsStore>(move |_, cx| cx.notify()),\n            }\n        });\n\n        this\n    }\n\n    fn section_label(&self, cx: &mut App) -> Div {\n        div()\n            .pl_1()\n            .font_buffer(cx)\n            .text_color(Color::Muted.color(cx))\n    }\n\n    fn update_settings<T: Settings>(\n        &mut self,\n        selection: &ToggleState,\n        cx: &mut Context<Self>,\n        callback: impl 'static + Send + Fn(&mut T::FileContent, bool),\n    ) {\n        if let Some(workspace) = self.workspace.upgrade() {\n            let fs = workspace.read(cx).app_state().fs.clone();\n            let selection = *selection;\n            settings::update_settings_file::<T>(fs, cx, move |settings, _| {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/welcome/src/welcome.rs\n                                CheckboxWithLabel::new(\n                                    \"enable-telemetry\",\n                                    Label::new(\"Send Telemetry\"),\n                                    if TelemetrySettings::get_global(cx).metrics {\n                                        ui::ToggleState::Selected\n                                    } else {\n                                        ui::ToggleState::Unselected\n                                    },\n                                    cx.listener(move |this, selection, _window, cx| {\n                                        telemetry::event!(\"Welcome Metric Telemetry Toggled\");\n                                        this.update_settings::<TelemetrySettings>(selection, cx, {\n                                            move |settings, value| {\n                                                settings.metrics = Some(value);\n                                                telemetry::event!(\n                                                    \"Settings Changed\",\n                                                    setting = \"metric telemetry\",\n                                                    value\n                                                );\n<|editable_region_start|>\n                                            }\n                                        });\n                                    }),\n                                )\n                                .fill()\n                                .elevation(ElevationIndex::ElevatedSurface),\n                            ),\n                    ),\n            )\n    }\n}\n\nimpl WelcomePage {\n    pub fn new(workspace: &Workspace, cx: &mut Context<Workspace>) -> Entity<Self> {\n        let this = cx.new(|cx| {\n            cx.on_release(|_: &mut Self, _| {\n                telemetry::event!(\"Welcome Page Closed\");\n<|editable_region_end|>\n            })\n            .detach();\n\n            WelcomePage {\n                focus_handle: cx.focus_handle(),\n                workspace: workspace.weak_handle(),\n                telemetry: workspace.client().telemetry().clone(),\n                _settings_subscription: cx\n                    .observe_global::<SettingsStore>(move |_, cx| cx.notify()),\n            }\n        });\n\n        this\n    }\n\n    fn section_label(&self, cx: &mut App) -> Div {\n        div()\n            .pl_1()\n            .font_buffer(cx)\n            .text_color(Color::Muted.color(cx))\n    }\n\n    fn update_settings<T: Settings>(\n        &mut self,\n        selection: &ToggleState,\n        cx: &mut Context<Self>,\n        callback: impl 'static + Send + Fn(&mut T::FileContent, bool),\n    ) {\n        if let Some(workspace) = self.workspace.upgrade() {\n            let fs = workspace.read(cx).app_state().fs.clone();\n            let selection = *selection;\n            settings::update_settings_file::<T>(fs, cx, move |settings, _| {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"schema/schema_test.go\":\n```diff\n@@ -158,7 +158,7 @@\n \t\t\"|=|\",\n \t} {\n \t\tinput, a, b, c, d, e := processString(string)\n-\t\tstartKey, endKey, startValue, endValue, startComment = splitL\n+\t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input, a, b, c, d, e)\n \n \t}\n \n\n```\n\nUser edited \"schema/schema_test.go\":\n```diff\n@@ -158,7 +158,7 @@\n \t\t\"|=|\",\n \t} {\n \t\tinput, a, b, c, d, e := processString(string)\n-\t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input, a, b, c, d, e)\n+\t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input)\n \n \t}\n \n\n```\n\nUser edited \"schema/schema_test.go\":\n```diff\n@@ -159,6 +159,7 @@\n \t} {\n \t\tinput, a, b, c, d, e := processString(string)\n \t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input)\n+\t\tif s\n \n \t}\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```conl/schema/schema_test.go\n\t\t\terrs := metaSchema.Validate([]byte(parts[0]))\n\t\t\tif errs != nil {\n\t\t\t\tfor _, err := range errs {\n\t\t\t\t\tt.Log(err.Error())\n\t\t\t\t}\n\t\t\t\tt.Fatal(\"schema validation failed\")\n\t\t\t}\n\n\t\t\tschema, err := schema.Parse([]byte(parts[0]))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"couldn't parse schema: %v\", err)\n\t\t\t}\n\t\t\texpected := collectErrors(parts[1])\n\t\t\terrors := schema.Validate([]byte(parts[1]))\n\t\t\tactual := []string{}\n\t\t\tfor _, err := range errors {\n\t\t\t\tactual = append(actual, err.Error())\n\t\t\t}\n\t\t\tif !slices.Equal(expected, actual) {\n\t\t\t\tt.Logf(\"expected:\")\n\t\t\t\tfor _, err := range expected {\n\t\t\t\t\tt.Log(err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"actual:\")\n\t\t\t\tfor _, err := range actual {\n\t\t\t\t\tt.Log(err)\n\t\t\t\t}\n\t\t\t\tt.FailNow()\n<|editable_region_start|>\n\t\t\t}\n\t\t})\n\t}\n}\nfunc processString(input string) (string, int, int, int, int, int) {\n\tvar result strings.Builder\n\tvar indexes []int\n\tcurrentIndex := 0\n\n\tfor _, char := range input {\n\t\tif char == '|' {\n\t\t\tindexes = append(indexes, currentIndex)\n\t\t} else {\n\t\t\tresult.WriteRune(char)\n\t\t\tcurrentIndex++\n\t\t}\n\t}\n\tfor len(indexes) < 5 {\n\t\tindexes = append(indexes, indexes[len(indexes)-1])\n\t}\n\n\treturn result.String(), indexes[0], indexes[1], indexes[2], indexes[3], indexes[4]\n}\n<|user_cursor_is_here|>\nfunc TestSplitLine(t *testing.T) {\n<|editable_region_end|>\n\n\tfor string := range []string{\n\t\t\"|a| = |a| |;a\",\n\t\t\"|=|\",\n\t} {\n\t\tinput, a, b, c, d, e := processString(string)\n\t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input)\n\t\tif s\n\n\t}\n\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```conl/schema/schema_test.go\n\t\t\terrs := metaSchema.Validate([]byte(parts[0]))\n\t\t\tif errs != nil {\n\t\t\t\tfor _, err := range errs {\n\t\t\t\t\tt.Log(err.Error())\n\t\t\t\t}\n\t\t\t\tt.Fatal(\"schema validation failed\")\n\t\t\t}\n\n\t\t\tschema, err := schema.Parse([]byte(parts[0]))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"couldn't parse schema: %v\", err)\n\t\t\t}\n\t\t\texpected := collectErrors(parts[1])\n\t\t\terrors := schema.Validate([]byte(parts[1]))\n\t\t\tactual := []string{}\n\t\t\tfor _, err := range errors {\n\t\t\t\tactual = append(actual, err.Error())\n\t\t\t}\n\t\t\tif !slices.Equal(expected, actual) {\n\t\t\t\tt.Logf(\"expected:\")\n\t\t\t\tfor _, err := range expected {\n\t\t\t\t\tt.Log(err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"actual:\")\n\t\t\t\tfor _, err := range actual {\n\t\t\t\t\tt.Log(err)\n\t\t\t\t}\n\t\t\t\tt.FailNow()\n<|editable_region_start|>\n\t\t\t}\n\t\t})\n\t}\n}\nfunc processString(input string) (string, int, int, int, int, int) {\n\tvar result strings.Builder\n\tvar indexes []int\n\tcurrentIndex := 0\n\n\tfor _, char := range input {\n\t\tif char == '|' {\n\t\t\tindexes = append(indexes, currentIndex)\n\t\t} else {\n\t\t\tresult.WriteRune(char)\n\t\t\tcurrentIndex++\n\t\t}\n\t}\n\tfor len(indexes) < 5 {\n\t\tindexes = append(indexes, indexes[len(indexes)-1])\n\t}\n\n\treturn result.String(), indexes[0], indexes[1], indexes[2], indexes[3], indexes[4]\n}\n\nfunc splitLine(input string) (int, int, int, int, int) {\n\tvar startKey, endKey, startValue, endValue, startComment int\n\tvar currentIndex int\n\tfor i := 0; i < len(input); i++ {\n\t\tif input[i] == '|' {\n\t\t\tswitch currentIndex {\n\t\t\tcase 0:\n\t\t\t\tstartKey = i\n\t\t\tcase 1:\n\t\t\t\tendKey = i\n\t\t\tcase 2:\n\t\t\t\tstartValue = i\n\t\t\tcase 3:\n\t\t\t\tendValue = i \n\t\t\tcase 4:\n\t\t\t\tstartComment = i\n\t\t\t}\n\t\t\tcurrentIndex++\n\t\t}\n\t}\n\treturn startKey, endKey, startValue, endValue, startComment\n}\n\nfunc TestSplitLine(t *testing.T) {\n<|editable_region_end|>\n\n\tfor string := range []string{\n\t\t\"|a| = |a| |;a\",\n\t\t\"|=|\",\n\t} {\n\t\tinput, a, b, c, d, e := processString(string)\n\t\tstartKey, endKey, startValue, endValue, startComment := splitLine(input)\n\t\tif s\n\n\t}\n\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/debugger_ui/Cargo.toml\":\n```diff\n@@ -14,6 +14,7 @@\n     \"editor/test-support\",\n     \"gpui/test-support\",\n     \"project/test-support\",\n+    \"settings/test-support\",\n     \"util/test-support\",\n     \"workspace/test-support\",\n ]\n\n```\n\nUser edited \"crates/dap_adapters/Cargo.toml\":\n```diff\n@@ -9,6 +9,7 @@\n test-support = [\n     \"dap/test-support\",\n     \"gpui/test-support\",\n+    \n     \"task/test-support\",\n     \"util/test-support\",\n ]\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/dap_adapters/Cargo.toml\n<|start_of_file|>\n[package]\nname = \"dap_adapters\"\nversion = \"0.1.0\"\nedition =  \"2021\"\npublish =  false\nlicense = \"GPL-3.0-or-later\"\n\n<|editable_region_start|>\n[features]\ntest-support = [\n    \"dap/test-support\",\n    \"gpui/test-support\",\n    \n    \"task/test-support\",\n    \"util/test-support\",\n]\n\n[lints]\nworkspace = true\n\n[lib]\npath = \"src/dap_adapters.rs\"\ndoctest = false\n\n[dependencies]\nanyhow.workspace = true\nasync-trait.workspace = true\ndap.workspace = true\ngpui.workspace = true\nlanguage.workspace = true\npaths.workspace = true\nregex.workspace = true\nserde.workspace = true\nserde_json.workspace = true\nsysinfo.workspace = true\ntask.workspace = true\nutil.workspace = true\n\n[dev-dependencies]\ndap = { workspace = true, features = [\"test-support\"] }\ngpui = { workspace = true, features = [\"test-support\"] }\ntask = { <|user_cursor_is_here|>workspace = true, features = [\"test-support\"] }\nutil = { workspace = true, features = [\"test-support\"] }\n\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/dap_adapters/Cargo.toml\n<|start_of_file|>\n[package]\nname = \"dap_adapters\"\nversion = \"0.1.0\"\nedition =  \"2021\"\npublish =  false\nlicense = \"GPL-3.0-or-later\"\n\n<|editable_region_start|>\n[features]\ntest-support = [\n    \"dap/test-support\",\n    \"gpui/test-support\",\n    \"settings/test-support\",\n    \n    \"task/test-support\",\n    \"util/test-support\",\n]\n\n[lints]\nworkspace = true\n\n[lib]\npath = \"src/dap_adapters.rs\"\ndoctest = false\n\n[dependencies]\nanyhow.workspace = true\nasync-trait.workspace = true\ndap.workspace = true\ngpui.workspace = true\nlanguage.workspace = true\npaths.workspace = true\nregex.workspace = true\nserde.workspace = true\nserde_json.workspace = true\nsysinfo.workspace = true\ntask.workspace = true\nutil.workspace = true\n\n[dev-dependencies]\ndap = { workspace = true, features = [\"test-support\"] }\ngpui = { workspace = true, features = [\"test-support\"] }\nsettings = { workspace = true, features = [\"test-support\"] }\ntask = { workspace = true, features = [\"test-support\"] }\nutil = { workspace = true, features = [\"test-support\"] }\n\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1059,7 +1059,7 @@\n     pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n         let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n         if dbg!(self.clip_at_line_ends) {\n-            clipped = self.clip_at_line_end(DisplayPoint(clipped)).0\n+            clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0\n         }\n         DisplayPoint(clipped)\n     }\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1059,7 +1059,7 @@\n     pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n         let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n         if dbg!(self.clip_at_line_ends) {\n-            clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0\n+            clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0)\n         }\n         DisplayPoint(clipped)\n     }\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1059,6 +1059,7 @@\n     pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n         let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n         if dbg!(self.clip_at_line_ends) {\n+            dbg!(cli)\n             clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0)\n         }\n         DisplayPoint(clipped)\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed-git/crates/editor/src/display_map.rs\n            if let Some(invisible) = s.chars().next().filter(|&c| is_invisible(c)) {\n                replacement(invisible).unwrap_or(s).to_owned().into()\n            } else if s == \"\\n\" {\n                \" \".into()\n            } else {\n                s.to_owned().into()\n            }\n        })\n    }\n\n    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot.chars_at(offset).map(move |ch| {\n            let ret = (ch, offset);\n            offset += ch.len_utf8();\n            ret\n        })\n    }\n\n    pub fn reverse_buffer_chars_at(\n        &self,\n        mut offset: usize,\n    ) -> impl Iterator<Item = (char, usize)> + '_ {\n<|editable_region_start|>\n        self.buffer_snapshot\n            .reversed_chars_at(offset)\n            .map(move |ch| {\n                offset -= ch.len_utf8();\n                (ch, offset)\n            })\n    }\n\n    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n        if dbg!(self.clip_at_line_ends) {\n            dbg!(cli<|user_cursor_is_here|>)\n            clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0)\n        }\n        DisplayPoint(clipped)\n    }\n\n    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))\n    }\n\n    pub fn clip_at_line_end(&self, display_point: DisplayPoint) -> DisplayPoint {\n        let mut point = self.display_point_to_point(display_point, Bias::Left);\n\n<|editable_region_end|>\n        if point.column != self.buffer_snapshot.line_len(MultiBufferRow(point.row)) {\n            return display_point;\n        }\n        point.column = point.column.saturating_sub(1);\n        point = self.buffer_snapshot.clip_point(point, Bias::Left);\n        self.point_to_display_point(point, Bias::Left)\n    }\n\n    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>\n    where\n        T: ToOffset,\n    {\n        self.fold_snapshot.folds_in_range(range)\n    }\n\n    pub fn blocks_in_range(\n        &self,\n        rows: Range<DisplayRow>,\n    ) -> impl Iterator<Item = (DisplayRow, &Block)> {\n        self.block_snapshot\n            .blocks_in_range(rows.start.0..rows.end.0)\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed-git/crates/editor/src/display_map.rs\n            if let Some(invisible) = s.chars().next().filter(|&c| is_invisible(c)) {\n                replacement(invisible).unwrap_or(s).to_owned().into()\n            } else if s == \"\\n\" {\n                \" \".into()\n            } else {\n                s.to_owned().into()\n            }\n        })\n    }\n\n    pub fn buffer_chars_at(&self, mut offset: usize) -> impl Iterator<Item = (char, usize)> + '_ {\n        self.buffer_snapshot.chars_at(offset).map(move |ch| {\n            let ret = (ch, offset);\n            offset += ch.len_utf8();\n            ret\n        })\n    }\n\n    pub fn reverse_buffer_chars_at(\n        &self,\n        mut offset: usize,\n    ) -> impl Iterator<Item = (char, usize)> + '_ {\n<|editable_region_start|>\n        self.buffer_snapshot\n            .reversed_chars_at(offset)\n            .map(move |ch| {\n                offset -= ch.len_utf8();\n                (ch, offset)\n            })\n    }\n\n    pub fn clip_point(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        let mut clipped = self.block_snapshot.clip_point(point.0, bias);\n        if dbg!(self.clip_at_line_ends) {\n            dbg!(clipped);\n            clipped = dbg!(self.clip_at_line_end(DisplayPoint(clipped)).0);\n        }\n        DisplayPoint(clipped)\n    }\n\n    pub fn clip_ignoring_line_ends(&self, point: DisplayPoint, bias: Bias) -> DisplayPoint {\n        DisplayPoint(self.block_snapshot.clip_point(point.0, bias))\n    }\n\n    pub fn clip_at_line_end(&self, display_point: DisplayPoint) -> DisplayPoint {\n        let mut point = self.display_point_to_point(display_point, Bias::Left);\n\n<|editable_region_end|>\n        if point.column != self.buffer_snapshot.line_len(MultiBufferRow(point.row)) {\n            return display_point;\n        }\n        point.column = point.column.saturating_sub(1);\n        point = self.buffer_snapshot.clip_point(point, Bias::Left);\n        self.point_to_display_point(point, Bias::Left)\n    }\n\n    pub fn folds_in_range<T>(&self, range: Range<T>) -> impl Iterator<Item = &Fold>\n    where\n        T: ToOffset,\n    {\n        self.fold_snapshot.folds_in_range(range)\n    }\n\n    pub fn blocks_in_range(\n        &self,\n        rows: Range<DisplayRow>,\n    ) -> impl Iterator<Item = (DisplayRow, &Block)> {\n        self.block_snapshot\n            .blocks_in_range(rows.start.0..rows.end.0)\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -749,7 +749,7 @@\n             }\n \n             if !edit_text.is_empty() {\n-                println!(\"LINE: \", &self.applied_edits_snapshot.)\n+                println!(\"LINE: \", &self.applied_edits_snapshot)\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -749,6 +749,8 @@\n             }\n \n             if !edit_text.is_empty() {\n+                let range= \n+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                 println!(\"LINE: \", &self.applied_edits_snapshot)\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -750,7 +750,7 @@\n \n             if !edit_text.is_empty() {\n                 let range= \n-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshotl\n                 println!(\"LINE: \", &self.applied_edits_snapshot)\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -749,8 +749,8 @@\n             }\n \n             if !edit_text.is_empty() {\n-                let range= \n-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshotl\n+                let range=\n+                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n                 println!(\"LINE: \", &self.applied_edits_snapshot)\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -751,7 +751,7 @@\n             if !edit_text.is_empty() {\n                 let range=\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: \", &self.applied_edits_snapshot)\n+                println!(\"LINE: \", range.to_po)\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -751,7 +751,7 @@\n             if !edit_text.is_empty() {\n                 let range=\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: \", range.to_po)\n+                println!(\"LINE: \", range.to_point(snapshot))\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -751,7 +751,7 @@\n             if !edit_text.is_empty() {\n                 let range=\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: \", range.to_point(snapshot))\n+                println!(\"LINE: \", range.to_point(&self.applied_edits_snapshot))\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -749,9 +749,8 @@\n             }\n \n             if !edit_text.is_empty() {\n-                let range=\n-                    edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: \", range.to_point(&self.applied_edits_snapshot))\n+                let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n+                println!(\"LINE: \", range.to_point(&self.applied_edits_snapshot));\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -750,7 +750,7 @@\n \n             if !edit_text.is_empty() {\n                 let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: \", range.to_point(&self.applied_edits_snapshot));\n+                println!(\"LINE: {:?}\", range.to_point(&self.applied_edits_snapshot));\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -750,7 +750,6 @@\n \n             if !edit_text.is_empty() {\n                 let range = edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot;\n-                println!(\"LINE: {:?}\", range.to_point(&self.applied_edits_snapshot));\n                 highlighted_text.add_text_from_buffer_range(\n                     edit_start_in_preview_snapshot..edit_new_end_in_preview_snapshot,\n                     &self.applied_edits_snapshot,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -591,6 +591,7 @@\n pub struct HighlightedText {\n     pub text: SharedString,\n     pub highlights: Vec<(Range<usize>, HighlightStyle)>,\n+    pub first_touched_line\n }\n \n #[derive(Default, Debug)]\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/language/src/buffer.rs\n    pub fn from_buffer_range<T: ToOffset>(\n        range: Range<T>,\n        snapshot: &text::BufferSnapshot,\n        syntax_snapshot: &SyntaxSnapshot,\n        override_style: Option<HighlightStyle>,\n        syntax_theme: &SyntaxTheme,\n    ) -> Self {\n        let mut highlighted_text = HighlightedTextBuilder::default();\n        highlighted_text.add_text_from_buffer_range(\n            range,\n            snapshot,\n            syntax_snapshot,\n            override_style,\n            syntax_theme,\n        );\n        highlighted_text.build()\n    }\n\n    pub fn to_styled_text(&self, default_style: &TextStyle) -> StyledText {\n        gpui::StyledText::new(self.text.clone())\n            .with_highlights(default_style, self.highlights.iter().cloned())\n    }\n}\n\n<|editable_region_start|>\nimpl HighlightedTextBuilder {\n    pub fn build(self) -> HighlightedText {\n        HighlightedText {\n            text: self.text.into(),\n            highlights: self.highlights,\n            first_touched_line: self.first_touched_line,\n        }\n    }\n    \n    p<|user_cursor_is_here|>\n\n    pub fn add_text_from_buffer_range<T: ToOffset>(\n        &mut self,\n        range: Range<T>,\n        snapshot: &text::BufferSnapshot,\n        syntax_snapshot: &SyntaxSnapshot,\n        override_style: Option<HighlightStyle>,\n        syntax_theme: &SyntaxTheme,\n    ) {\n        let range = range.to_offset(snapshot);\n        for chunk in Self::highlighted_chunks(range, snapshot, syntax_snapshot) {\n<|editable_region_end|>\n            let start = self.text.len();\n            self.text.push_str(chunk.text);\n            let end = self.text.len();\n\n            if let Some(mut highlight_style) = chunk\n                .syntax_highlight_id\n                .and_then(|id| id.style(syntax_theme))\n            {\n                if let Some(override_style) = override_style {\n                    highlight_style.highlight(override_style);\n                }\n                self.highlights.push((start..end, highlight_style));\n            } else if let Some(override_style) = override_style {\n                self.highlights.push((start..end, override_style));\n            }\n        }\n    }\n\n    fn highlighted_chunks<'a>(\n        range: Range<usize>,\n        snapshot: &'a text::BufferSnapshot,\n        syntax_snapshot: &'a SyntaxSnapshot,\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/language/src/buffer.rs\n    pub fn from_buffer_range<T: ToOffset>(\n        range: Range<T>,\n        snapshot: &text::BufferSnapshot,\n        syntax_snapshot: &SyntaxSnapshot,\n        override_style: Option<HighlightStyle>,\n        syntax_theme: &SyntaxTheme,\n    ) -> Self {\n        let mut highlighted_text = HighlightedTextBuilder::default();\n        highlighted_text.add_text_from_buffer_range(\n            range,\n            snapshot,\n            syntax_snapshot,\n            override_style,\n            syntax_theme,\n        );\n        highlighted_text.build()\n    }\n\n    pub fn to_styled_text(&self, default_style: &TextStyle) -> StyledText {\n        gpui::StyledText::new(self.text.clone())\n            .with_highlights(default_style, self.highlights.iter().cloned())\n    }\n}\n\n<|editable_region_start|>\nimpl HighlightedTextBuilder {\n    pub fn build(self) -> HighlightedText {\n        HighlightedText {\n            text: self.text.into(),\n            highlights: self.highlights,\n            first_touched_line: self.first_touched_line,\n        }\n    }\n    \n    pub fn new() -> Self {\n        Self {\n            text: String::new(),\n            highlights: Vec::new(),\n            first_touched_line: None,\n        }\n    }\n    \n    pub fn add_text_from_buffer_range<T: ToOffset>(\n        &mut self,\n        range: Range<T>,\n        snapshot: &text::BufferSnapshot,\n        syntax_snapshot: &SyntaxSnapshot,\n        override_style: Option<HighlightStyle>,\n        syntax_theme: &SyntaxTheme,\n    ) {\n        let range = range.to_offset(snapshot);\n        for chunk in Self::highlighted_chunks(range, snapshot, syntax_snapshot) {\n<|editable_region_end|>\n            let start = self.text.len();\n            self.text.push_str(chunk.text);\n            let end = self.text.len();\n\n            if let Some(mut highlight_style) = chunk\n                .syntax_highlight_id\n                .and_then(|id| id.style(syntax_theme))\n            {\n                if let Some(override_style) = override_style {\n                    highlight_style.highlight(override_style);\n                }\n                self.highlights.push((start..end, highlight_style));\n            } else if let Some(override_style) = override_style {\n                self.highlights.push((start..end, override_style));\n            }\n        }\n    }\n\n    fn highlighted_chunks<'a>(\n        range: Range<usize>,\n        snapshot: &'a text::BufferSnapshot,\n        syntax_snapshot: &'a SyntaxSnapshot,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -1,4 +1,4 @@\n-Re\n+Reformat legal terms\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \"\":\n```diff\n@@ -1,4 +1,4 @@\n-Reformat legal terms\n+Reformat legal terms.md\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \"\":\n```diff\n@@ -1,4 +1,6 @@\n-Reformat legal terms.md\n+Reformat Zed Terms of Use with Prettier\n+\n+No-\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n<|start_of_file|>\nReformat Zed Terms of Use with Prettier\n\n<|editable_region_start|>\nNo-<|user_cursor_is_here|>\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch terms_prettier\n# Changes to be committed:\n#\tmodified:   legal/terms.md\n#\n# Untracked files:\n#\t.env\n#\t.github/DISCUSSION_TEMPLATE/\n<|editable_region_end|>\n#\ttriage-party.txt\n#\n# ------------------------ >8 ------------------------\n# Do not modify or remove the line above.\n# Everything below it will be ignored.\ndiff --git a/legal/terms.md b/legal/terms.md\nindex cd610f617b..e85d5a28b5 100644\n--- a/legal/terms.md\n+++ b/legal/terms.md\n@@ -3,7 +3,7 @@ title: Zed Terms of Use\n slug: terms\n ---\n \n-PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE USING THE SERVICE OR SOFTWARE OFFERED BY ZED INDUSTRIES, INC. (\"ZED\", OR \"WE\"). BY ACCESSING OR USING THE SOLUTION (AS DEFINED BELOW) IN ANY MANNER, YOU (\"YOU\" OR \"CUSTOMER\") AGREE TO BE BOUND BY THESE TERMS (THE \"AGREEMENT\") TO THE EXCLUSION OF ALL OTHER TERMS. YOU REPRESENT AND WARRANT THAT YOU HAVE THE AUTHORITY TO ENTER INTO THIS AGREEMENT; IF YOU ARE ENTERING INTO THIS AGREEMENT ON BEHALF OF AN ORGANIZATION OR ENTITY, REFERENCES TO \"CUSTOMER\" AND \"YOU\" IN THIS AGREEMENT, REFER TO THAT ORGANIZATION OR ENTITY. IF YOU DO NOT AGREE TO ALL OF THE FOLLOWING, YOU MAY NOT USE OR ACCESS THE SOLUTION IN ANY MANNER.  IF THE TERMS OF THIS AGREEMENT ARE CONSIDERED AN OFFER, ACCEPTANCE IS EXPRESSLY LIMITED TO SUCH TERMS.\n+PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE USING THE SERVICE OR SOFTWARE OFFERED BY ZED INDUSTRIES, INC. (\"ZED\", OR \"WE\"). BY ACCESSING OR USING THE SOLUTION (AS DEFINED BELOW) IN ANY MANNER, YOU (\"YOU\" OR \"CUSTOMER\") AGREE TO BE BOUND BY THESE TERMS (THE \"AGREEMENT\") TO THE EXCLUSION OF ALL OTHER TERMS. YOU REPRESENT AND WARRANT THAT YOU HAVE THE AUTHORITY TO ENTER INTO THIS AGREEMENT; IF YOU ARE ENTERING INTO THIS AGREEMENT ON BEHALF OF AN ORGANIZATION OR ENTITY, REFERENCES TO \"CUSTOMER\" AND \"YOU\" IN THIS AGREEMENT, REFER TO THAT ORGANIZATION OR ENTITY. IF YOU DO NOT AGREE TO ALL OF THE FOLLOWING, YOU MAY NOT USE OR ACCESS THE SOLUTION IN ANY MANNER. IF THE TERMS OF THIS AGREEMENT ARE CONSIDERED AN OFFER, ACCEPTANCE IS EXPRESSLY LIMITED TO SUCH TERMS.\n \n ## 1. ACCESS TO AND USE OF THE SOLUTION\n \n@@ -94,7 +94,7 @@ Zed does not represent or warrant that the operation of the Zed Service or Edito\n \n ## 8. LIMITATIONS OF LIABILITY\n \n-IN NO EVENT SHALL ZED BE LIABLE FOR ANY LOST DATA, LOST PROFITS, BUSINESS INTERRUPTION, REPLACEMENT SERVICE OR OTHER SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR INDIRECT DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THEORY OF LIABILITY.  ZED'S LIABILITY FOR ALL CLAIMS ARISING UNDER THIS AGREEMENT, WHETHER IN CONTRACT, TORT OR OTHERWISE, SHALL NOT EXCEED ONE THOUSAND US DOLLARS ($1,000).\n+IN NO EVENT SHALL ZED BE LIABLE FOR ANY LOST DATA, LOST PROFITS, BUSINESS INTERRUPTION, REPLACEMENT SERVICE OR OTHER SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR INDIRECT DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THEORY OF LIABILITY. ZED'S LIABILITY FOR ALL CLAIMS ARISING UNDER THIS AGREEMENT, WHETHER IN CONTRACT, TORT OR OTHERWISE, SHALL NOT EXCEED ONE THOUSAND US DOLLARS ($1,000).\n \n ## 9. Third Party Services\n \n@@ -112,11 +112,11 @@ You shall comply with all applicable laws and regulations in its use of the Solu\n \n ### 10.3. Assignment\n \n-Neither party may transfer and assign its rights and obligations under this Agreement without the prior written consent of the other party.  Notwithstanding the foregoing, Zed may transfer and assign its rights under this Agreement without consent from the other party in connection with a change in control, acquisition or sale of all or substantially all of its assets.\n+Neither party may transfer and assign its rights and obligations under this Agreement without the prior written consent of the other party. Notwithstanding the foregoing, Zed may transfer and assign its rights under this Agreement without consent from the other party in connection with a change in control, acquisition or sale of all or substantially all of its assets.\n \n ### 10.4. Force Majeure\n \n-Neither party shall be responsible for failure or delay in performance by events out of their reasonable control, including but not limited to, acts of God, Internet outage, terrorism, war, fires, earthquakes and other disasters (each a \"Force Majeure\").  Notwithstanding the foregoing: if a Force Majeure continues for more than thirty (30) days, either party may to terminate this agreement by written notice to the other party.\n+Neither party shall be responsible for failure or delay in performance by events out of their reasonable control, including but not limited to, acts of God, Internet outage, terrorism, war, fires, earthquakes and other disasters (each a \"Force Majeure\"). Notwithstanding the foregoing: if a Force Majeure continues for more than thirty (30) days, either party may to terminate this agreement by written notice to the other party.\n \n ### 10.5. Notice\n \n@@ -124,11 +124,11 @@ All notices between the parties shall be in writing and shall be deemed to have\n \n ### 10.6. No Agency\n \n-Both parties agree that no agency, partnership, joint venture, or employment is created as a result of this Agreement.  You do not have any authority of any kind to bind Zed.\n+Both parties agree that no agency, partnership, joint venture, or employment is created as a result of this Agreement. You do not have any authority of any kind to bind Zed.\n \n ### 10.7. Governing Law\n \n-This Agreement shall be governed exclusively by, and construed exclusively in accordance with, the laws of the United States and the State of California, without regard to its conflict of laws provisions.  The federal courts of the United States in the Northern District of California and the state courts of the State of California shall have exclusive jurisdiction to adjudicate any dispute arising out of or relating to this Agreement.  Each party hereby consents to the jurisdiction of such courts and waives any right it may otherwise have to challenge the appropriateness of such forums, whether on the basis of the doctrine of forum non conveniens or otherwise.  The United Nations Convention on Contracts for the International Sale of Goods shall not apply to this Agreement or any Purchase Order issued under this Agreement.\n+This Agreement shall be governed exclusively by, and construed exclusively in accordance with, the laws of the United States and the State of California, without regard to its conflict of laws provisions. The federal courts of the United States in the Northern District of California and the state courts of the State of California shall have exclusive jurisdiction to adjudicate any dispute arising out of or relating to this Agreement. Each party hereby consents to the jurisdiction of such courts and waives any right it may otherwise have to challenge the appropriateness of such forums, whether on the basis of the doctrine of forum non conveniens or otherwise. The United Nations Convention on Contracts for the International Sale of Goods shall not apply to this Agreement or any Purchase Order issued under this Agreement.\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n<|start_of_file|>\nReformat Zed Terms of Use with Prettier\n\n<|editable_region_start|>\nNo-op whitespace changes\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch terms_prettier\n# Changes to be committed:\n#\tmodified:   legal/terms.md\n#\n# Untracked files:\n#\t.env\n#\t.github/DISCUSSION_TEMPLATE/\n<|editable_region_end|>\n#\ttriage-party.txt\n#\n# ------------------------ >8 ------------------------\n# Do not modify or remove the line above.\n# Everything below it will be ignored.\ndiff --git a/legal/terms.md b/legal/terms.md\nindex cd610f617b..e85d5a28b5 100644\n--- a/legal/terms.md\n+++ b/legal/terms.md\n@@ -3,7 +3,7 @@ title: Zed Terms of Use\n slug: terms\n ---\n \n-PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE USING THE SERVICE OR SOFTWARE OFFERED BY ZED INDUSTRIES, INC. (\"ZED\", OR \"WE\"). BY ACCESSING OR USING THE SOLUTION (AS DEFINED BELOW) IN ANY MANNER, YOU (\"YOU\" OR \"CUSTOMER\") AGREE TO BE BOUND BY THESE TERMS (THE \"AGREEMENT\") TO THE EXCLUSION OF ALL OTHER TERMS. YOU REPRESENT AND WARRANT THAT YOU HAVE THE AUTHORITY TO ENTER INTO THIS AGREEMENT; IF YOU ARE ENTERING INTO THIS AGREEMENT ON BEHALF OF AN ORGANIZATION OR ENTITY, REFERENCES TO \"CUSTOMER\" AND \"YOU\" IN THIS AGREEMENT, REFER TO THAT ORGANIZATION OR ENTITY. IF YOU DO NOT AGREE TO ALL OF THE FOLLOWING, YOU MAY NOT USE OR ACCESS THE SOLUTION IN ANY MANNER.  IF THE TERMS OF THIS AGREEMENT ARE CONSIDERED AN OFFER, ACCEPTANCE IS EXPRESSLY LIMITED TO SUCH TERMS.\n+PLEASE READ THESE TERMS AND CONDITIONS CAREFULLY BEFORE USING THE SERVICE OR SOFTWARE OFFERED BY ZED INDUSTRIES, INC. (\"ZED\", OR \"WE\"). BY ACCESSING OR USING THE SOLUTION (AS DEFINED BELOW) IN ANY MANNER, YOU (\"YOU\" OR \"CUSTOMER\") AGREE TO BE BOUND BY THESE TERMS (THE \"AGREEMENT\") TO THE EXCLUSION OF ALL OTHER TERMS. YOU REPRESENT AND WARRANT THAT YOU HAVE THE AUTHORITY TO ENTER INTO THIS AGREEMENT; IF YOU ARE ENTERING INTO THIS AGREEMENT ON BEHALF OF AN ORGANIZATION OR ENTITY, REFERENCES TO \"CUSTOMER\" AND \"YOU\" IN THIS AGREEMENT, REFER TO THAT ORGANIZATION OR ENTITY. IF YOU DO NOT AGREE TO ALL OF THE FOLLOWING, YOU MAY NOT USE OR ACCESS THE SOLUTION IN ANY MANNER. IF THE TERMS OF THIS AGREEMENT ARE CONSIDERED AN OFFER, ACCEPTANCE IS EXPRESSLY LIMITED TO SUCH TERMS.\n \n ## 1. ACCESS TO AND USE OF THE SOLUTION\n \n@@ -94,7 +94,7 @@ Zed does not represent or warrant that the operation of the Zed Service or Edito\n \n ## 8. LIMITATIONS OF LIABILITY\n \n-IN NO EVENT SHALL ZED BE LIABLE FOR ANY LOST DATA, LOST PROFITS, BUSINESS INTERRUPTION, REPLACEMENT SERVICE OR OTHER SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR INDIRECT DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THEORY OF LIABILITY.  ZED'S LIABILITY FOR ALL CLAIMS ARISING UNDER THIS AGREEMENT, WHETHER IN CONTRACT, TORT OR OTHERWISE, SHALL NOT EXCEED ONE THOUSAND US DOLLARS ($1,000).\n+IN NO EVENT SHALL ZED BE LIABLE FOR ANY LOST DATA, LOST PROFITS, BUSINESS INTERRUPTION, REPLACEMENT SERVICE OR OTHER SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR INDIRECT DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THEORY OF LIABILITY. ZED'S LIABILITY FOR ALL CLAIMS ARISING UNDER THIS AGREEMENT, WHETHER IN CONTRACT, TORT OR OTHERWISE, SHALL NOT EXCEED ONE THOUSAND US DOLLARS ($1,000).\n \n ## 9. Third Party Services\n \n@@ -112,11 +112,11 @@ You shall comply with all applicable laws and regulations in its use of the Solu\n \n ### 10.3. Assignment\n \n-Neither party may transfer and assign its rights and obligations under this Agreement without the prior written consent of the other party.  Notwithstanding the foregoing, Zed may transfer and assign its rights under this Agreement without consent from the other party in connection with a change in control, acquisition or sale of all or substantially all of its assets.\n+Neither party may transfer and assign its rights and obligations under this Agreement without the prior written consent of the other party. Notwithstanding the foregoing, Zed may transfer and assign its rights under this Agreement without consent from the other party in connection with a change in control, acquisition or sale of all or substantially all of its assets.\n \n ### 10.4. Force Majeure\n \n-Neither party shall be responsible for failure or delay in performance by events out of their reasonable control, including but not limited to, acts of God, Internet outage, terrorism, war, fires, earthquakes and other disasters (each a \"Force Majeure\").  Notwithstanding the foregoing: if a Force Majeure continues for more than thirty (30) days, either party may to terminate this agreement by written notice to the other party.\n+Neither party shall be responsible for failure or delay in performance by events out of their reasonable control, including but not limited to, acts of God, Internet outage, terrorism, war, fires, earthquakes and other disasters (each a \"Force Majeure\"). Notwithstanding the foregoing: if a Force Majeure continues for more than thirty (30) days, either party may to terminate this agreement by written notice to the other party.\n \n ### 10.5. Notice\n \n@@ -124,11 +124,11 @@ All notices between the parties shall be in writing and shall be deemed to have\n \n ### 10.6. No Agency\n \n-Both parties agree that no agency, partnership, joint venture, or employment is created as a result of this Agreement.  You do not have any authority of any kind to bind Zed.\n+Both parties agree that no agency, partnership, joint venture, or employment is created as a result of this Agreement. You do not have any authority of any kind to bind Zed.\n \n ### 10.7. Governing Law\n \n-This Agreement shall be governed exclusively by, and construed exclusively in accordance with, the laws of the United States and the State of California, without regard to its conflict of laws provisions.  The federal courts of the United States in the Northern District of California and the state courts of the State of California shall have exclusive jurisdiction to adjudicate any dispute arising out of or relating to this Agreement.  Each party hereby consents to the jurisdiction of such courts and waives any right it may otherwise have to challenge the appropriateness of such forums, whether on the basis of the doctrine of forum non conveniens or otherwise.  The United Nations Convention on Contracts for the International Sale of Goods shall not apply to this Agreement or any Purchase Order issued under this Agreement.\n+This Agreement shall be governed exclusively by, and construed exclusively in accordance with, the laws of the United States and the State of California, without regard to its conflict of laws provisions. The federal courts of the United States in the Northern District of California and the state courts of the State of California shall have exclusive jurisdiction to adjudicate any dispute arising out of or relating to this Agreement. Each party hereby consents to the jurisdiction of such courts and waives any right it may otherwise have to challenge the appropriateness of such forums, whether on the basis of the doctrine of forum non conveniens or otherwise. The United Nations Convention on Contracts for the International Sale of Goods shall not apply to this Agreement or any Purchase Order issued under this Agreement.\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -458,7 +458,9 @@\n     }\n }\n \n-enum Modifier\n+enum Modifier {\n+    \n+}\n \n impl Modifiers {\n     pub fn iter(&self) -> impl Iterator<Item = &'static str> {\n\n```\n\n\n\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -459,7 +459,11 @@\n }\n \n enum Modifier {\n-    \n+    Control,\n+    Alt,\n+    Shift,\n+    Platform,\n+    Function,\n }\n \n impl Modifiers {\n\n```\n\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -467,7 +467,7 @@\n }\n \n impl Modifiers {\n-    pub fn iter(&self) -> impl Iterator<Item = &'static str> {\n+    pub fn iter(&self) -> impl Iterator<Item = Modifier> {\n         let modifiers = [\n             (self.control, \"ctrl\"),\n             (self.alt, \"alt\"),\n\n```\n\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -469,11 +469,11 @@\n impl Modifiers {\n     pub fn iter(&self) -> impl Iterator<Item = Modifier> {\n         let modifiers = [\n-            (self.control, \"ctrl\"),\n-            (self.alt, \"alt\"),\n-            (self.shift, \"shift\"),\n-            (self.platform, \"platform\"),\n-            (self.function, \"fn\"),\n+            (self.control, Modifier::Control),\n+            (self.alt, Modifier::Alt),\n+            (self.shift, Modifier::Shift),\n+            (self.platform, Modifier::Platform),\n+            (self.function, Modifier::Function),\n         ];\n \n         modifiers\n\n```\n\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -479,6 +479,6 @@\n         modifiers\n             .into_iter()\n             .filter(|(enabled, _)| *enabled)\n-            .map(|(_, name)| name)\n+            .map(|(_, modifier)| modifier)\n     }\n }\n\n```\n\nUser edited \"crates/gpui/src/platform/keystroke.rs\":\n```diff\n@@ -467,6 +467,7 @@\n }\n \n impl Modifiers {\n+    //\n     pub fn iter(&self) -> impl Iterator<Item = Modifier> {\n         let modifiers = [\n             (self.control, Modifier::Control),\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/gpui/src/platform/keystroke.rs\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with just shift.\n    pub fn shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with command + shift.\n    pub fn command_shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            platform: true,\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with command + shift.\n    pub fn control_shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            control: true,\n            ..Default::default()\n        }\n    }\n\n    /// Checks if this [`Modifiers`] is a subset of another [`Modifiers`].\n    pub fn is_subset_of(&self, other: &Modifiers) -> bool {\n        (other.control || !self.control)\n            && (other.alt || !self.alt)\n            && (other.shift || !self.shift)\n            && (other.platform || !self.platform)\n            && (other.function || !self.function)\n    }\n}\n\nenum Modifier {\n    Control,\n    Alt,\n    Shift,\n    Platform,\n    Function,\n<|editable_region_start|>\n}\n\nimpl Modifiers {\n    //<|user_cursor_is_here|>\n    pub fn iter(&self) -> impl Iterator<Item = Modifier> {\n        let modifiers = [\n            (self.control, Modifier::Control),\n            (self.alt, Modifier::Alt),\n            (self.shift, Modifier::Shift),\n            (self.platform, Modifier::Platform),\n            (self.function, Modifier::Function),\n<|editable_region_end|>\n        ];\n\n        modifiers\n            .into_iter()\n            .filter(|(enabled, _)| *enabled)\n            .map(|(_, modifier)| modifier)\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/gpui/src/platform/keystroke.rs\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with just shift.\n    pub fn shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with command + shift.\n    pub fn command_shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            platform: true,\n            ..Default::default()\n        }\n    }\n\n    /// Returns [`Modifiers`] with command + shift.\n    pub fn control_shift() -> Modifiers {\n        Modifiers {\n            shift: true,\n            control: true,\n            ..Default::default()\n        }\n    }\n\n    /// Checks if this [`Modifiers`] is a subset of another [`Modifiers`].\n    pub fn is_subset_of(&self, other: &Modifiers) -> bool {\n        (other.control || !self.control)\n            && (other.alt || !self.alt)\n            && (other.shift || !self.shift)\n            && (other.platform || !self.platform)\n            && (other.function || !self.function)\n    }\n}\n\nenum Modifier {\n    Control,\n    Alt,\n    Shift,\n    Platform,\n    Function,\n<|editable_region_start|>\n}\n\nimpl Modifiers {\n    /// Returns an iterator over the active modifier keys.\n    pub fn iter(&self) -> impl Iterator<Item = Modifier> {\n        let modifiers = [\n            (self.control, Modifier::Control),\n            (self.alt, Modifier::Alt),\n            (self.shift, Modifier::Shift),\n            (self.platform, Modifier::Platform),\n            (self.function, Modifier::Function),\n<|editable_region_end|>\n        ];\n\n        modifiers\n            .into_iter()\n            .filter(|(enabled, _)| *enabled)\n            .map(|(_, modifier)| modifier)\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/theme/src/fallback_themes.rs\":\n```diff\n@@ -4,7 +4,7 @@\n \n use crate::{\n     default_color_scales, AccentColors, Appearance, PlayerColors, StatusColors, SyntaxTheme,\n-    SystemColors, Theme, ThemeColors, ThemeFamily, ThemeStyles,\n+    SystemColors, Theme, ThemeColors, ThemeContent, ThemeFamily, ThemeStyles,\n };\n \n /// The default theme family for Zed.\n\n```\n\nUser edited \"crates/theme/src/fallback_themes.rs\":\n```diff\n@@ -21,7 +21,7 @@\n     }\n }\n \n-pub(crate) fn dark_theme_defaults(content: &ThemeContent) {\n+pub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n     //\n }\n \n\n```\n\nUser edited \"crates/theme/src/fallback_themes.rs\":\n```diff\n@@ -22,6 +22,7 @@\n }\n \n pub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n+    \n     //\n }\n \n\n```\n\nUser edited \"crates/theme/src/fallback_themes.rs\":\n```diff\n@@ -22,7 +22,7 @@\n }\n \n pub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n-    \n+    let status = &mut content.s\n     //\n }\n \n\n```\n\nUser edited \"crates/theme/src/fallback_themes.rs\":\n```diff\n@@ -22,7 +22,7 @@\n }\n \n pub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n-    let status = &mut content.s\n+    let status = &mut content.st\n     //\n }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/theme/src/fallback_themes.rs\n<|start_of_file|>\nuse std::sync::Arc;\n\nuse gpui::{hsla, FontStyle, FontWeight, HighlightStyle, Hsla, WindowBackgroundAppearance};\n\nuse crate::{\n    default_color_scales, AccentColors, Appearance, PlayerColors, StatusColors, SyntaxTheme,\n    SystemColors, Theme, ThemeColors, ThemeContent, ThemeFamily, ThemeStyles,\n};\n\n/// The default theme family for Zed.\n///\n/// This is used to construct the default theme fallback values, as well as to\n/// have a theme available at compile time for tests.\npub fn zed_default_themes() -> ThemeFamily {\n    ThemeFamily {\n        id: \"zed-default\".to_string(),\n        name: \"Zed Default\".into(),\n        author: \"\".into(),\n        themes: vec![zed_default_dark()],\n<|editable_region_start|>\n        scales: default_color_scales(),\n    }\n}\n\npub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n    let status = &mut content.st<|user_cursor_is_here|>\n    //\n}\n\npub(crate) fn zed_default_dark() -> Theme {\n    let bg = hsla(215. / 360., 12. / 100., 15. / 100., 1.);\n    let editor = hsla(220. / 360., 12. / 100., 18. / 100., 1.);\n    let elevated_surface = hsla(225. / 360., 12. / 100., 17. / 100., 1.);\n\n    let blue = hsla(207.8 / 360., 81. / 100., 66. / 100., 1.0);\n    let gray = hsla(218.8 / 360., 10. / 100., 40. / 100., 1.0);\n    let green = hsla(95. / 360., 38. / 100., 62. / 100., 1.0);\n    let orange = hsla(29. / 360., 54. / 100., 61. / 100., 1.0);\n    let purple = hsla(286. / 360., 51. / 100., 64. / 100., 1.0);\n    let red = hsla(355. / 360., 65. / 100., 65. / 100., 1.0);\n    let teal = hsla(187. / 360., 47. / 100., 55. / 100., 1.0);\n    let yellow = hsla(39. / 360., 67. / 100., 69. / 100., 1.0);\n<|editable_region_end|>\n\n    const ADDED_COLOR: Hsla = Hsla {\n        h: 142. / 360.,\n        s: 0.68,\n        l: 0.45,\n        a: 1.0,\n    };\n    const MODIFIED_COLOR: Hsla = Hsla {\n        h: 48. / 360.,\n        s: 0.76,\n        l: 0.47,\n        a: 1.0,\n    };\n    const REMOVED_COLOR: Hsla = Hsla {\n        h: 355. / 360.,\n        s: 0.65,\n        l: 0.65,\n        a: 1.0,\n    };\n\n    Theme {\n        id: \"one_dark\".to_string(),\n        name: \"One Dark\".into(),\n        appearance: Appearance::Dark,\n        styles: ThemeStyles {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/theme/src/fallback_themes.rs\n<|start_of_file|>\nuse std::sync::Arc;\n\nuse gpui::{hsla, FontStyle, FontWeight, HighlightStyle, Hsla, WindowBackgroundAppearance};\n\nuse crate::{\n    default_color_scales, AccentColors, Appearance, PlayerColors, StatusColors, SyntaxTheme,\n    SystemColors, Theme, ThemeColors, ThemeContent, ThemeFamily, ThemeStyles,\n};\n\n/// The default theme family for Zed.\n///\n/// This is used to construct the default theme fallback values, as well as to\n/// have a theme available at compile time for tests.\npub fn zed_default_themes() -> ThemeFamily {\n    ThemeFamily {\n        id: \"zed-default\".to_string(),\n        name: \"Zed Default\".into(),\n        author: \"\".into(),\n        themes: vec![zed_default_dark()],\n<|editable_region_start|>\n        scales: default_color_scales(),\n    }\n}\n\npub(crate) fn dark_theme_defaults(content: &mut ThemeContent) {\n    let status = &mut content.status;\n    status.background = hsla(215. / 360., 12. / 100., 15. / 100., 1.);\n    status.foreground = hsla(220. / 360., 12. / 100., 18. / 100., 1.);\n    status.border = hsla(225. / 360., 12. / 100., 17. / 100., 1.);\n\n    //\n}\n\npub(crate) fn zed_default_dark() -> Theme {\n    let bg = hsla(215. / 360., 12. / 100., 15. / 100., 1.);\n    let editor = hsla(220. / 360., 12. / 100., 18. / 100., 1.);\n    let elevated_surface = hsla(225. / 360., 12. / 100., 17. / 100., 1.);\n\n    let blue = hsla(207.8 / 360., 81. / 100., 66. / 100., 1.0);\n    let gray = hsla(218.8 / 360., 10. / 100., 40. / 100., 1.0);\n    let green = hsla(95. / 360., 38. / 100., 62. / 100., 1.0);\n    let orange = hsla(29. / 360., 54. / 100., 61. / 100., 1.0);\n    let purple = hsla(286. / 360., 51. / 100., 64. / 100., 1.0);\n    let red = hsla(355. / 360., 65. / 100., 65. / 100., 1.0);\n    let teal = hsla(187. / 360., 47. / 100., 55. / 100., 1.0);\n    let yellow = hsla(39. / 360., 67. / 100., 69. / 100., 1.0);\n<|editable_region_end|>\n\n    const ADDED_COLOR: Hsla = Hsla {\n        h: 142. / 360.,\n        s: 0.68,\n        l: 0.45,\n        a: 1.0,\n    };\n    const MODIFIED_COLOR: Hsla = Hsla {\n        h: 48. / 360.,\n        s: 0.76,\n        l: 0.47,\n        a: 1.0,\n    };\n    const REMOVED_COLOR: Hsla = Hsla {\n        h: 355. / 360.,\n        s: 0.65,\n        l: 0.65,\n        a: 1.0,\n    };\n\n    Theme {\n        id: \"one_dark\".to_string(),\n        name: \"One Dark\".into(),\n        appearance: Appearance::Dark,\n        styles: ThemeStyles {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -471,7 +471,6 @@\n     for ch in map.buffer_snapshot.chars_at(offset) {\n         if let Some(prev_ch) = prev_ch {\n             if is_boundary(prev_ch, ch) {\n-                dbg!()\n                 if return_point_before_boundary {\n                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);\n                 } else {\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -470,7 +470,7 @@\n \n     for ch in map.buffer_snapshot.chars_at(offset) {\n         if let Some(prev_ch) = prev_ch {\n-            if is_boundary(prev_ch, ch) {\n+            if dbg!(is_boundary(prev_ch, ch) {\n                 if return_point_before_boundary {\n                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);\n                 } else {\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -470,7 +470,7 @@\n \n     for ch in map.buffer_snapshot.chars_at(offset) {\n         if let Some(prev_ch) = prev_ch {\n-            if dbg!(is_boundary(prev_ch, ch) {\n+            if dbg!(is_boundary(prev_ch, ch)) {\n                 if return_point_before_boundary {\n                     return map.clip_point(prev_offset.to_display_point(map), Bias::Right);\n                 } else {\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -482,9 +482,6 @@\n         offset += ch.len_utf8();\n         prev_ch = Some(ch);\n \n-        if find_range == FindRange::SingleLine && ch == '\\n' {\n-            break;\n-        }\n     }\n     map.clip_point(offset.to_display_point(map), Bias::Right)\n }\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -469,6 +469,9 @@\n     let mut prev_ch = None;\n \n     for ch in map.buffer_snapshot.chars_at(offset) {\n+        if find_range == FindRange::SingleLine && ch == '\\n' {\n+                    break;\n+                }\n         if let Some(prev_ch) = prev_ch {\n             if dbg!(is_boundary(prev_ch, ch)) {\n                 if return_point_before_boundary {\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -471,7 +471,7 @@\n     for ch in map.buffer_snapshot.chars_at(offset) {\n         if find_range == FindRange::SingleLine && ch == '\\n' {\n                     break;\n-                }\n+        }\n         if let Some(prev_ch) = prev_ch {\n             if dbg!(is_boundary(prev_ch, ch)) {\n                 if return_point_before_boundary {\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -470,7 +470,8 @@\n \n     for ch in map.buffer_snapshot.chars_at(offset) {\n         if find_range == FindRange::SingleLine && ch == '\\n' {\n-                    break;\n+            if\n+            break;\n         }\n         if let Some(prev_ch) = prev_ch {\n             if dbg!(is_boundary(prev_ch, ch)) {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed-git/crates/editor/src/movement.rs\npub fn find_preceding_boundary_display_point(\n    map: &DisplaySnapshot,\n    from: DisplayPoint,\n<|editable_region_start|>\n    find_range: FindRange,\n    is_boundary: impl FnMut(char, char) -> bool,\n) -> DisplayPoint {\n    let result = find_preceding_boundary_point(\n        &map.buffer_snapshot,\n        from.to_point(map),\n        find_range,\n        is_boundary,\n    );\n    map.clip_point(result.to_display_point(map), Bias::Left)\n}\n\n/// Scans for a boundary following the given start point until a boundary is found, indicated by the\n/// given predicate returning true. The predicate is called with the character to the left and right\n/// of the candidate boundary location, and will be called with `\\n` characters indicating the start\n/// or end of a line. The function supports optionally returning the point just before the boundary\n/// is found via return_point_before_boundary.\npub fn find_boundary_point(\n    map: &DisplaySnapshot,\n    from: DisplayPoint,\n    find_range: FindRange,\n    mut is_boundary: impl FnMut(char, char) -> bool,\n    return_point_before_boundary: bool,\n) -> DisplayPoint {\n    let mut offset = from.to_offset(map, Bias::Right);\n    let mut prev_offset = offset;\n    let mut prev_ch = None;\n\n    for ch in map.buffer_snapshot.chars_at(offset) {\n        if find_range == FindRange::SingleLine && ch == '\\n' {\n            if<|user_cursor_is_here|>\n            break;\n        }\n        if let Some(prev_ch) = prev_ch {\n            if dbg!(is_boundary(prev_ch, ch)) {\n                if return_point_before_boundary {\n                    return map.clip_point(prev_offset.to_display_point(map), Bias::Right);\n                } else {\n                    break;\n                }\n            }\n        }\n        prev_offset = offset;\n        offset += ch.len_utf8();\n        prev_ch = Some(ch);\n\n    }\n    map.clip_point(offset.to_display_point(map), Bias::Right)\n}\n\npub fn find_preceding_boundary_trail(\n    map: &DisplaySnapshot,\n    head: DisplayPoint,\n    mut is_boundary: impl FnMut(char, char) -> bool,\n) -> (Option<DisplayPoint>, DisplayPoint) {\n    let mut offset = head.to_offset(map, Bias::Left);\n    let mut trail_offset = None;\n<|editable_region_end|>\n\n    let mut prev_ch = map.buffer_snapshot.chars_at(offset).next();\n    let mut forward = map.buffer_snapshot.reversed_chars_at(offset).peekable();\n\n    // Skip newlines\n    while let Some(&ch) = forward.peek() {\n        if ch == '\\n' {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed-git/crates/editor/src/movement.rs\npub fn find_preceding_boundary_display_point(\n    map: &DisplaySnapshot,\n    from: DisplayPoint,\n<|editable_region_start|>\n    find_range: FindRange,\n    is_boundary: impl FnMut(char, char) -> bool,\n) -> DisplayPoint {\n    let result = find_preceding_boundary_point(\n        &map.buffer_snapshot,\n        from.to_point(map),\n        find_range,\n        is_boundary,\n    );\n    map.clip_point(result.to_display_point(map), Bias::Left)\n}\n\n/// Scans for a boundary following the given start point until a boundary is found, indicated by the\n/// given predicate returning true. The predicate is called with the character to the left and right\n/// of the candidate boundary location, and will be called with `\\n` characters indicating the start\n/// or end of a line. The function supports optionally returning the point just before the boundary\n/// is found via return_point_before_boundary.\npub fn find_boundary_point(\n    map: &DisplaySnapshot,\n    from: DisplayPoint,\n    find_range: FindRange,\n    mut is_boundary: impl FnMut(char, char) -> bool,\n    return_point_before_boundary: bool,\n) -> DisplayPoint {\n    let mut offset = from.to_offset(map, Bias::Right);\n    let mut prev_offset = offset;\n    let mut prev_ch = None;\n\n    for ch in map.buffer_snapshot.chars_at(offset) {\n        if find_range == FindRange::SingleLine && ch == '\\n' {\n            if dbg!(is_boundary(prev_ch, ch)) {\n            }\n            break;\n        }\n        if let Some(prev_ch) = prev_ch {\n            if dbg!(is_boundary(prev_ch, ch)) {\n                if return_point_before_boundary {\n                    return map.clip_point(prev_offset.to_display_point(map), Bias::Right);\n                } else {\n                    break;\n                }\n            }\n        }\n        prev_offset = offset;\n        offset += ch.len_utf8();\n        prev_ch = Some(ch);\n\n    }\n    map.clip_point(offset.to_display_point(map), Bias::Right)\n}\n\npub fn find_preceding_boundary_trail(\n    map: &DisplaySnapshot,\n    head: DisplayPoint,\n    mut is_boundary: impl FnMut(char, char) -> bool,\n) -> (Option<DisplayPoint>, DisplayPoint) {\n    let mut offset = head.to_offset(map, Bias::Left);\n    let mut trail_offset = None;\n<|editable_region_end|>\n\n    let mut prev_ch = map.buffer_snapshot.chars_at(offset).next();\n    let mut forward = map.buffer_snapshot.reversed_chars_at(offset).peekable();\n\n    // Skip newlines\n    while let Some(&ch) = forward.peek() {\n        if ch == '\\n' {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/main.rs\":\n```diff\n@@ -15,7 +15,7 @@\n         }\n     }\n     \n-    fn\n+    f\n }\n \n pub fn main() {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```example/src/main.rs\n<|start_of_file|>\nstruct User {\n    id: u32,\n    name: String,\n    age: u32,\n<|editable_region_start|>\n    email: String,\n}\n\nimpl User {\n    fn new(id: u32, name: String, age: u32, email: String) -> User {\n        User {\n            id,\n            name,\n            age,\n            email,\n        }\n    }\n    \n    f<|user_cursor_is_here|>\n}\n\npub fn main() {\n    let user = User::new(\"John\".to_string(), 30, \"john@example.com\".to_string());\n    println!(\n        \"User Name: {}, Age: {}, Email: {}\",\n        user.name, user.age, user.email\n<|editable_region_end|>\n    );\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```example/src/main.rs\n<|start_of_file|>\nstruct User {\n    id: u32,\n    name: String,\n    age: u32,\n<|editable_region_start|>\n    email: String,\n}\n\nimpl User {\n    fn new(id: u32, name: String, age: u32, email: String) -> User {\n        User {\n            id,\n            name,\n            age,\n            email,\n        }\n    }    \n}\n\npub fn main() {\n    let user = User::new(\"John\".to_string(), 30, \"john@example.com\".to_string());\n    println!(\n        \"User Name: {}, Age: {}, Email: {}\",\n        user.name, user.age, user.email\n<|editable_region_end|>\n    );\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1232,7 +1232,7 @@\n             let mut end = None;\n \n             for row in (buffer_row.0 + 1)..=max_point.row {\n-                let line_indent = self.line_indent_for_buffer_row(MultiBufferRow(row));\n+                let Some(line_indent) = self.line_indent_for_buffer_row(MultiBufferRow(row));\n                 if !line_indent.is_line_blank()\n                     && line_indent.raw_len() <= start_line_indent.raw_len()\n                 {\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1232,7 +1232,9 @@\n             let mut end = None;\n \n             for row in (buffer_row.0 + 1)..=max_point.row {\n-                let Some(line_indent) = self.line_indent_for_buffer_row(MultiBufferRow(row));\n+                let Some(line_indent) = self.line_indent_for_buffer_row(MultiBufferRow(row)) else {\n+                    continue;\n+                };\n                 if !line_indent.is_line_blank()\n                     && line_indent.raw_len() <= start_line_indent.raw_len()\n                 {\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1227,7 +1227,7 @@\n         } else if self.starts_indent(MultiBufferRow(start.row))\n             && !self.is_line_folded(MultiBufferRow(start.row))\n         {\n-            let start_line_indent = self.line_indent_for_buffer_row(buffer_row);\n+            let start_line_indent = self.line_indent_for_buffer_row(buffer_row);i\n             let max_point = self.buffer_snapshot.max_point();\n             let mut end = None;\n \n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1227,7 +1227,7 @@\n         } else if self.starts_indent(MultiBufferRow(start.row))\n             && !self.is_line_folded(MultiBufferRow(start.row))\n         {\n-            let start_line_indent = self.line_indent_for_buffer_row(buffer_row);i\n+            let start_line_indent = self.line_indent_for_buffer_row(buffer_row)?;\n             let max_point = self.buffer_snapshot.max_point();\n             let mut end = None;\n \n\n```\n\n\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4239,15 +4239,10 @@\n         let mut cursor = self.cursor::<Point>();\n         let point = Point::new(row.0, 0);\n         cursor.seek(&point);\n-        let region = dbg!(cursor.region()?);\n-        {\n-            let mut cursor = cursor.clone();\n-            cursor.next();\n-            eprintln!(\"next: {:?}\", cursor.region());\n-        }\n+        let region = cursor.region()?;\n         let overshoot = point.min(region.range.end) - region.range.start;\n         let buffer_point = region.buffer_range.start + overshoot;\n-        if dbg!(buffer_point.row) > dbg!(region.buffer_range.end.row) {\n+        if buffer_point.row > region.buffer_range.end.row {\n             return None;\n         }\n         let line_start = Point::new(buffer_point.row, 0).max(region.buffer_range.start);\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4169,7 +4169,7 @@\n         result\n     }\n \n-    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> IndentSize {\n+    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option>IndentSize {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             let mut size = buffer.indent_size_for_line(range.start.row);\n             size.len = size\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4169,7 +4169,7 @@\n         result\n     }\n \n-    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option>IndentSize {\n+    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option<IndentSize {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             let mut size = buffer.indent_size_for_line(range.start.row);\n             size.len = size\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4169,7 +4169,7 @@\n         result\n     }\n \n-    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option<IndentSize {\n+    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option<IndentSize> {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             let mut size = buffer.indent_size_for_line(range.start.row);\n             size.len = size\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4182,7 +4182,7 @@\n         }\n     }\n \n-    pub fn line_indent_for_row(&self, row: MultiBufferRow) -> LineIndent {\n+    pub fn line_indent_for_row(&self, row: MultiBufferRow) -> Option<LineIndent> {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             LineIndent::from_iter(buffer.text_for_range(range).flat_map(|s| s.chars()))\n         } else {\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4169,7 +4169,7 @@\n         result\n     }\n \n-    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> Option<IndentSize> {\n+    pub fn indent_size_for_line(&self, row: MultiBufferRow) -> IndentSize {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             let mut size = buffer.indent_size_for_line(range.start.row);\n             size.len = size\n@@ -4182,7 +4182,7 @@\n         }\n     }\n \n-    pub fn line_indent_for_row(&self, row: MultiBufferRow) -> Option<LineIndent> {\n+    pub fn line_indent_for_row(&self, row: MultiBufferRow) -> LineIndent {\n         if let Some((buffer, range)) = self.buffer_line_for_row(row) {\n             LineIndent::from_iter(buffer.text_for_range(range).flat_map(|s| s.chars()))\n         } else {\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -1142,6 +1142,7 @@\n     }\n \n     pub fn line_indent_for_buffer_row(&self, buffer_row: MultiBufferRow) -> LineIndent {\n+        s\n         let (buffer, range) = self\n             .buffer_snapshot\n             .buffer_line_for_row(buffer_row)\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/display_map.rs\n            || self.fold_snapshot.is_line_folded(buffer_row)\n    }\n\n    pub fn is_block_line(&self, display_row: DisplayRow) -> bool {\n        self.block_snapshot.is_block_line(BlockRow(display_row.0))\n    }\n\n    pub fn soft_wrap_indent(&self, display_row: DisplayRow) -> Option<u32> {\n        let wrap_row = self\n            .block_snapshot\n            .to_wrap_point(BlockPoint::new(display_row.0, 0), Bias::Left)\n            .row();\n        self.wrap_snapshot.soft_wrap_indent(wrap_row)\n    }\n\n    pub fn text(&self) -> String {\n        self.text_chunks(DisplayRow(0)).collect()\n    }\n\n    pub fn line(&self, display_row: DisplayRow) -> String {\n        let mut result = String::new();\n        for chunk in self.text_chunks(display_row) {\n            if let Some(ix) = chunk.find('\\n') {\n                result.push_str(&chunk[0..ix]);\n                break;\n            } else {\n<|editable_region_start|>\n                result.push_str(chunk);\n            }\n        }\n        result\n    }\n\n    pub fn line_indent_for_buffer_row(&self, buffer_row: MultiBufferRow) -> LineIndent {\n        s<|user_cursor_is_here|>\n        let (buffer, range) = self\n            .buffer_snapshot\n            .buffer_line_for_row(buffer_row)\n            .unwrap();\n\n        buffer.line_indent_for_row(range.start.row)\n    }\n\n    pub fn line_len(&self, row: DisplayRow) -> u32 {\n        self.block_snapshot.line_len(BlockRow(row.0))\n    }\n\n<|editable_region_end|>\n    pub fn longest_row(&self) -> DisplayRow {\n        DisplayRow(self.block_snapshot.longest_row())\n    }\n\n    pub fn longest_row_in_range(&self, range: Range<DisplayRow>) -> DisplayRow {\n        let block_range = BlockRow(range.start.0)..BlockRow(range.end.0);\n        let longest_row = self.block_snapshot.longest_row_in_range(block_range);\n        DisplayRow(longest_row.0)\n    }\n\n    pub fn starts_indent(&self, buffer_row: MultiBufferRow) -> bool {\n        let max_row = self.buffer_snapshot.max_row();\n        if buffer_row >= max_row {\n            return false;\n        }\n\n        let line_indent = self.line_indent_for_buffer_row(buffer_row);\n        if line_indent.is_line_blank() {\n            return false;\n        }\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/display_map.rs\n            || self.fold_snapshot.is_line_folded(buffer_row)\n    }\n\n    pub fn is_block_line(&self, display_row: DisplayRow) -> bool {\n        self.block_snapshot.is_block_line(BlockRow(display_row.0))\n    }\n\n    pub fn soft_wrap_indent(&self, display_row: DisplayRow) -> Option<u32> {\n        let wrap_row = self\n            .block_snapshot\n            .to_wrap_point(BlockPoint::new(display_row.0, 0), Bias::Left)\n            .row();\n        self.wrap_snapshot.soft_wrap_indent(wrap_row)\n    }\n\n    pub fn text(&self) -> String {\n        self.text_chunks(DisplayRow(0)).collect()\n    }\n\n    pub fn line(&self, display_row: DisplayRow) -> String {\n        let mut result = String::new();\n        for chunk in self.text_chunks(display_row) {\n            if let Some(ix) = chunk.find('\\n') {\n                result.push_str(&chunk[0..ix]);\n                break;\n            } else {\n<|editable_region_start|>\n                result.push_str(chunk);\n            }\n        }\n        result\n    }\n\n    pub fn line_indent_for_buffer_row(&self, buffer_row: MultiBufferRow) -> LineIndent {\n        self.buffer_snapshot.line_indent_for_row(buffer_row)\n    }\n\n    pub fn line_len(&self, row: DisplayRow) -> u32 {\n        self.block_snapshot.line_len(BlockRow(row.0))\n    }\n\n<|editable_region_end|>\n    pub fn longest_row(&self) -> DisplayRow {\n        DisplayRow(self.block_snapshot.longest_row())\n    }\n\n    pub fn longest_row_in_range(&self, range: Range<DisplayRow>) -> DisplayRow {\n        let block_range = BlockRow(range.start.0)..BlockRow(range.end.0);\n        let longest_row = self.block_snapshot.longest_row_in_range(block_range);\n        DisplayRow(longest_row.0)\n    }\n\n    pub fn starts_indent(&self, buffer_row: MultiBufferRow) -> bool {\n        let max_row = self.buffer_snapshot.max_row();\n        if buffer_row >= max_row {\n            return false;\n        }\n\n        let line_indent = self.line_indent_for_buffer_row(buffer_row);\n        if line_indent.is_line_blank() {\n            return false;\n        }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/story/src/table_story.rs\":\n```diff\n@@ -395,6 +395,7 @@\n         let col = self.columns.get(col_ix).unwrap();\n \n         match col.id.as_ref() {\n+            \n             \"id\" => stock.id.to_string().into_any_element(),\n             \"name\" => stock.name.clone().into_any_element(),\n             \"symbol\" => stock.symbol.clone().into_any_element(),\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/story/src/table_story.rs\n        _window: &Window,\n        _cx: &App,\n    ) -> PopupMenu {\n        menu.menu(\n            format!(\"Selected Row: {}\", row_ix),\n            Box::new(OpenDetail(row_ix)),\n        )\n        .separator()\n        .menu(\"Size Large\", Box::new(ChangeSize(Size::Large)))\n        .menu(\"Size Medium\", Box::new(ChangeSize(Size::Medium)))\n        .menu(\"Size Small\", Box::new(ChangeSize(Size::Small)))\n<|editable_region_start|>\n        .menu(\"Size XSmall\", Box::new(ChangeSize(Size::XSmall)))\n    }\n\n    /// NOTE: Performance metrics\n    ///\n    /// last render 561 cells total: 232.745\u00b5s, avg: 414ns\n    /// frame duration: 8.825083ms\n    ///\n    /// This is means render the full table cells takes 232.745\u00b5s. Then 232.745\u00b5s / 8.82ms = 2.6% of the frame duration.\n    ///\n    /// If we improve the td rendering, we can reduce the time to render the full table cells.\n    fn render_td(\n        &self,\n        row_ix: usize,\n        col_ix: usize,\n        _: &mut Window,\n        cx: &mut Context<Table<Self>>,\n    ) -> impl IntoElement {\n        let stock = self.stocks.get(row_ix).unwrap();\n        let col = self.columns.get(col_ix).unwrap();\n\n        match col.id.as_ref() {\n            <|user_cursor_is_here|>\n            \"id\" => stock.id.to_string().into_any_element(),\n            \"name\" => stock.name.clone().into_any_element(),\n            \"symbol\" => stock.symbol.clone().into_any_element(),\n            \"price\" => self.render_value_cell(stock.price, cx),\n            \"change\" => self.render_value_cell(stock.change, cx),\n            \"change_percent\" => self.render_value_cell(stock.change_percent, cx),\n            \"volume\" => self.render_value_cell(stock.volume, cx),\n            \"turnover\" => self.render_value_cell(stock.turnover, cx),\n            \"market_cap\" => self.render_value_cell(stock.market_cap, cx),\n            \"ttm\" => self.render_value_cell(stock.ttm, cx),\n            \"five_mins_ranking\" => self.render_value_cell(stock.five_mins_ranking, cx),\n            \"th60_days_ranking\" => stock.th60_days_ranking.to_string().into_any_element(),\n            \"year_change_percent\" => (stock.year_change_percent * 100.0)\n                .to_string()\n                .into_any_element(),\n            \"bid\" => self.render_value_cell(stock.bid, cx),\n            \"bid_volume\" => self.render_value_cell(stock.bid_volume, cx),\n            \"ask\" => self.render_value_cell(stock.ask, cx),\n<|editable_region_end|>\n            \"ask_volume\" => self.render_value_cell(stock.ask_volume, cx),\n            \"open\" => stock.open.to_string().into_any_element(),\n            \"prev_close\" => stock.prev_close.to_string().into_any_element(),\n            \"high\" => self.render_value_cell(stock.high, cx),\n            \"low\" => self.render_value_cell(stock.low, cx),\n            \"turnover_rate\" => (stock.turnover_rate * 100.0).to_string().into_any_element(),\n            \"rise_rate\" => (stock.rise_rate * 100.0).to_string().into_any_element(),\n            \"amplitude\" => (stock.amplitude * 100.0).to_string().into_any_element(),\n            \"pe_status\" => stock.pe_status.to_string().into_any_element(),\n            \"pb_status\" => stock.pb_status.to_string().into_any_element(),\n            \"volume_ratio\" => self.render_value_cell(stock.volume_ratio, cx),\n            \"bid_ask_ratio\" => self.render_value_cell(stock.bid_ask_ratio, cx),\n            \"latest_pre_close\" => stock.latest_pre_close.to_string().into_any_element(),\n            \"latest_post_close\" => stock.latest_post_close.to_string().into_any_element(),\n            \"pre_market_cap\" => stock.pre_market_cap.to_string().into_any_element(),\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/story/src/table_story.rs\n        _window: &Window,\n        _cx: &App,\n    ) -> PopupMenu {\n        menu.menu(\n            format!(\"Selected Row: {}\", row_ix),\n            Box::new(OpenDetail(row_ix)),\n        )\n        .separator()\n        .menu(\"Size Large\", Box::new(ChangeSize(Size::Large)))\n        .menu(\"Size Medium\", Box::new(ChangeSize(Size::Medium)))\n        .menu(\"Size Small\", Box::new(ChangeSize(Size::Small)))\n<|editable_region_start|>\n        .menu(\"Size XSmall\", Box::new(ChangeSize(Size::XSmall)))\n    }\n\n    /// NOTE: Performance metrics\n    ///\n    /// last render 561 cells total: 232.745\u00b5s, avg: 414ns\n    /// frame duration: 8.825083ms\n    ///\n    /// This is means render the full table cells takes 232.745\u00b5s. Then 232.745\u00b5s / 8.82ms = 2.6% of the frame duration.\n    ///\n    /// If we improve the td rendering, we can reduce the time to render the full table cells.\n    fn render_td(\n        &self,\n        row_ix: usize,\n        col_ix: usize,\n        _: &mut Window,\n        cx: &mut Context<Table<Self>>,\n    ) -> impl IntoElement {\n        let stock = self.stocks.get(row_ix).unwrap();\n        let col = self.columns.get(col_ix).unwrap();\n\n        match col.id.as_ref() {\n            \n            \"id\" => stock.id.to_string().into_any_element(),\n            \"name\" => stock.name.clone().into_any_element(),\n            \"symbol\" => stock.symbol.clone().into_any_element(),\n            \"price\" => self.render_value_cell(stock.price, cx),\n            \"change\" => self.render_value_cell(stock.change, cx),\n            \"change_percent\" => self.render_value_cell(stock.change_percent, cx),\n            \"volume\" => self.render_value_cell(stock.volume, cx),\n            \"turnover\" => self.render_value_cell(stock.turnover, cx),\n            \"market_cap\" => self.render_value_cell(stock.market_cap, cx),\n            \"ttm\" => self.render_value_cell(stock.ttm, cx),\n            \"five_mins_ranking\" => self.render_value_cell(stock.five_mins_ranking, cx),\n            \"th60_days_ranking\" => stock.th60_days_ranking.to_string().into_any_element(),\n            \"year_change_percent\" => (stock.year_change_percent * 100.0)\n                .to_string()\n                .into_any_element(),\n            \"bid\" => self.render_value_cell(stock.bid, cx),\n            \"bid_volume\" => self.render_value_cell(stock.bid_volume, cx),\n            \"ask\" => self.render_value_cell(stock.ask, cx),\n<|editable_region_end|>\n            \"ask_volume\" => self.render_value_cell(stock.ask_volume, cx),\n            \"open\" => stock.open.to_string().into_any_element(),\n            \"prev_close\" => stock.prev_close.to_string().into_any_element(),\n            \"high\" => self.render_value_cell(stock.high, cx),\n            \"low\" => self.render_value_cell(stock.low, cx),\n            \"turnover_rate\" => (stock.turnover_rate * 100.0).to_string().into_any_element(),\n            \"rise_rate\" => (stock.rise_rate * 100.0).to_string().into_any_element(),\n            \"amplitude\" => (stock.amplitude * 100.0).to_string().into_any_element(),\n            \"pe_status\" => stock.pe_status.to_string().into_any_element(),\n            \"pb_status\" => stock.pb_status.to_string().into_any_element(),\n            \"volume_ratio\" => self.render_value_cell(stock.volume_ratio, cx),\n            \"bid_ask_ratio\" => self.render_value_cell(stock.bid_ask_ratio, cx),\n            \"latest_pre_close\" => stock.latest_pre_close.to_string().into_any_element(),\n            \"latest_post_close\" => stock.latest_post_close.to_string().into_any_element(),\n            \"pre_market_cap\" => stock.pre_market_cap.to_string().into_any_element(),\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/git/src/repository.rs\":\n```diff\n@@ -265,7 +265,7 @@\n             .to_path_buf();\n \n         if !paths.is_empty() {\n-            let output = new_std_command(&self.git_binary_path)\n+            let cmd = new_std_command(&self.git_binary_path)\n                 .current_dir(&working_directory)\n                 .args([\"update-index\", \"--add\", \"--remove\", \"--\"])\n                 .args(paths.iter().map(|p| p.as_ref()))\n\n```\n\nUser edited \"crates/git/src/repository.rs\":\n```diff\n@@ -265,7 +265,7 @@\n             .to_path_buf();\n \n         if !paths.is_empty() {\n-            let cmd = new_std_command(&self.git_binary_path)\n+            let  = new_std_command(&self.git_binary_path)\n                 .current_dir(&working_directory)\n                 .args([\"update-index\", \"--add\", \"--remove\", \"--\"])\n                 .args(paths.iter().map(|p| p.as_ref()))\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/git/src/repository.rs\n        Ok(())\n    }\n\n    fn blame(&self, path: &Path, content: Rope) -> Result<crate::blame::Blame> {\n        let working_directory = self\n            .repository\n            .lock()\n            .workdir()\n            .with_context(|| format!(\"failed to get git working directory for file {:?}\", path))?\n            .to_path_buf();\n\n        const REMOTE_NAME: &str = \"origin\";\n        let remote_url = self.remote_url(REMOTE_NAME);\n\n        crate::blame::Blame::for_path(\n            &self.git_binary_path,\n            &working_directory,\n            path,\n            &content,\n            remote_url,\n            self.hosting_provider_registry.clone(),\n        )\n    }\n\n    fn stage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n        let working_directory = self\n            .repository\n            .lock()\n<|editable_region_start|>\n            .workdir()\n            .context(\"failed to read git work directory\")?\n            .to_path_buf();\n\n        if !paths.is_empty() {\n            let <|user_cursor_is_here|> = new_std_command(&self.git_binary_path)\n                .current_dir(&working_directory)\n                .args([\"update-index\", \"--add\", \"--remove\", \"--\"])\n                .args(paths.iter().map(|p| p.as_ref()))\n                .status()?;\n            if !output.status.success() {\n                return Err(anyhow!(\"Failed to stage paths: {cmd}\"));\n            }\n        }\n        Ok(())\n    }\n\n    fn unstage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n        let working_directory = self\n            .repository\n            .lock()\n            .workdir()\n            .context(\"failed to read git work directory\")?\n            .to_path_buf();\n\n        if !paths.is_empty() {\n            let cmd = new_std_command(&self.git_binary_path)\n                .current_dir(&working_directory)\n                .args([\"reset\", \"--quiet\", \"--\"])\n<|editable_region_end|>\n                .args(paths.iter().map(|p| p.as_ref()))\n                .status()?;\n            if !cmd.success() {\n                return Err(anyhow!(\"Failed to unstage paths: {cmd}\"));\n            }\n        }\n        Ok(())\n    }\n\n    fn commit(&self, name_and_email: Option<(&str, &str)>) -> Result<()> {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/git/src/repository.rs\n        Ok(())\n    }\n\n    fn blame(&self, path: &Path, content: Rope) -> Result<crate::blame::Blame> {\n        let working_directory = self\n            .repository\n            .lock()\n            .workdir()\n            .with_context(|| format!(\"failed to get git working directory for file {:?}\", path))?\n            .to_path_buf();\n\n        const REMOTE_NAME: &str = \"origin\";\n        let remote_url = self.remote_url(REMOTE_NAME);\n\n        crate::blame::Blame::for_path(\n            &self.git_binary_path,\n            &working_directory,\n            path,\n            &content,\n            remote_url,\n            self.hosting_provider_registry.clone(),\n        )\n    }\n\n    fn stage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n        let working_directory = self\n            .repository\n            .lock()\n<|editable_region_start|>\n            .workdir()\n            .context(\"failed to read git work directory\")?\n            .to_path_buf();\n\n        if !paths.is_empty() {\n            let status = new_std_command(&self.git_binary_path)\n                .current_dir(&working_directory)\n                .args([\"update-index\", \"--add\", \"--remove\", \"--\"])\n                .args(paths.iter().map(|p| p.as_ref()))\n                .status()?;\n            if !status.success() {\n                return Err(anyhow!(\"Failed to stage paths: {cmd}\"));\n            }\n        }\n        Ok(())\n    }\n\n    fn unstage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n        let working_directory = self\n            .repository\n            .lock()\n            .workdir()\n            .context(\"failed to read git work directory\")?\n            .to_path_buf();\n\n        if !paths.is_empty() {\n            let cmd = new_std_command(&self.git_binary_path)\n                .current_dir(&working_directory)\n                .args([\"reset\", \"--quiet\", \"--\"])\n<|editable_region_end|>\n                .args(paths.iter().map(|p| p.as_ref()))\n                .status()?;\n            if !cmd.success() {\n                return Err(anyhow!(\"Failed to unstage paths: {cmd}\"));\n            }\n        }\n        Ok(())\n    }\n\n    fn commit(&self, name_and_email: Option<(&str, &str)>) -> Result<()> {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/canvas.rs\":\n```diff\n@@ -82,7 +82,7 @@\n         }\n     }\n     \n-    pub fn dete\n+    pub fn detec\n \n     #[allow(dead_code)]\n     pub(crate) fn blit_from_canvas(&mut self, src: &Canvas) {\n\n```\n\nUser edited \"src/canvas.rs\":\n```diff\n@@ -82,7 +82,25 @@\n         }\n     }\n     \n-    pub fn detec\n+    pub fn detect_edges(&mut self, threshold: u8) {\n+        let width = self.size.x() as usize;\n+        let height = self.size.y() as usize;\n+        let stride = self.stride;\n+        let format = self.formattazione;\n+\n+        let mut edges = vec![0; width * height];\n+\n+        for y in 0..height {\n+            for x in 0..width {\n+                let pixel = self.get_pixel(x, y);\n+                let neighbors = self.get_neighbors(x, y);\n+                let edge = neighbors.iter().any(|&n| n > threshold);\n+                edges[y * width + x] = edge as u8;\n+            }\n+        }\n+\n+        self.pixels = edges;\n+    }\n \n     #[allow(dead_code)]\n     pub(crate) fn blit_from_canvas(&mut self, src: &Canvas) {\n\n```\n\nUser edited \"src/canvas.rs\":\n```diff\n@@ -90,6 +90,7 @@\n \n         let mut edges = vec![0; width * height];\n \n+        for\n         for y in 0..height {\n             for x in 0..width {\n                 let pixel = self.get_pixel(x, y);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```font-kit/src/canvas.rs\n    /// Creates a new blank canvas with the given pixel size, stride (number of bytes between\n    /// successive rows), and format.\n    ///\n    /// The canvas is initialized with transparent black (all values 0).\n    pub fn with_stride(size: Vector2I, stride: usize, format: Format) -> Canvas {\n        Canvas {\n            pixels: vec![0; stride * size.y() as usize],\n            size,\n            stride,\n            formattazione: format,\n        }\n    }\n    \n    pub fn detect_edges(&mut self, threshold: u8) {\n        let width = self.size.x() as usize;\n        let height = self.size.y() as usize;\n        let stride = self.stride;\n        let format = self.formattazione;\n\n        let mut edges = vec![0; width * height];\n<|editable_region_start|>\n\n        for<|user_cursor_is_here|>\n        for y in 0..height {\n            for x in 0..width {\n                let pixel = self.get_pixel(x, y);\n<|editable_region_end|>\n                let neighbors = self.get_neighbors(x, y);\n                let edge = neighbors.iter().any(|&n| n > threshold);\n                edges[y * width + x] = edge as u8;\n            }\n        }\n\n        self.pixels = edges;\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn blit_from_canvas(&mut self, src: &Canvas) {\n        self.blit_from(\n            Vector2I::default(),\n            &src.pixels,\n            src.size,\n            src.stride,\n            src.formattazione,\n        )\n    }\n```"}, {"role": "assistant", "content": "Suggestion:\n```font-kit/src/canvas.rs\n    /// Creates a new blank canvas with the given pixel size, stride (number of bytes between\n    /// successive rows), and format.\n    ///\n    /// The canvas is initialized with transparent black (all values 0).\n    pub fn with_stride(size: Vector2I, stride: usize, format: Format) -> Canvas {\n        Canvas {\n            pixels: vec![0; stride * size.y() as usize],\n            size,\n            stride,\n            formattazione: format,\n        }\n    }\n    \n    pub fn detect_edges(&mut self, threshold: u8) {\n        let width = self.size.x() as usize;\n        let height = self.size.y() as usize;\n        let stride = self.stride;\n        let format = self.formattazione;\n\n        let mut edges = vec![0; width * height];\n<|editable_region_start|>\n\n        for channel in 0..format.bits_per_pixel() / 8 {\n            for y in 0..height {\n                for x in 0..width {\n                    let pixel = self.get_pixel(x, y);\n<|editable_region_end|>\n                let neighbors = self.get_neighbors(x, y);\n                let edge = neighbors.iter().any(|&n| n > threshold);\n                edges[y * width + x] = edge as u8;\n            }\n        }\n\n        self.pixels = edges;\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn blit_from_canvas(&mut self, src: &Canvas) {\n        self.blit_from(\n            Vector2I::default(),\n            &src.pixels,\n            src.size,\n            src.stride,\n            src.formattazione,\n        )\n    }\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \".github/workflows/deploy.yml\":\n```diff\n@@ -28,7 +28,7 @@\n         with:\n           node-version-file: './.nvmrc'\n \n-  \n+    \n       # envchain balsamiq-aws-srlinternal aws iam create-service-linked-role --aws-service-name es.amazonaws.com\n       # \ud83d\udc46 if it fails with `An error occurred (InvalidInput) when calling the CreateServiceLinkedRole operation: Service role name AWSServiceRoleForAmazonElasticsearchService has been taken in this account, please try a different suffix.` you're good. This means the service role was already created.\n       #\n\n```\n\nUser edited \".github/workflows/deploy.yml\":\n```diff\n@@ -28,7 +28,7 @@\n         with:\n           node-version-file: './.nvmrc'\n \n-    \n+      #\n       # envchain balsamiq-aws-srlinternal aws iam create-service-linked-role --aws-service-name es.amazonaws.com\n       # \ud83d\udc46 if it fails with `An error occurred (InvalidInput) when calling the CreateServiceLinkedRole operation: Service role name AWSServiceRoleForAmazonElasticsearchService has been taken in this account, please try a different suffix.` you're good. This means the service role was already created.\n       #\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```.github/workflows/deploy.yml\n<|start_of_file|>\non:\n  push:\n    branches:\n      - release\n      - staging\n\n  workflow_dispatch:\n    inputs:\n      branchName:\n        description: 'Type name of the branch selected above to confirm (e.g., \"staging\")'\n<|editable_region_start|>\n        required: true\n\njobs:\n  deploy:\n    # When triggered manually, run this job only if user consciously confirms the branch name they've selected from the dropdown\n    if: ${{ github.event_name != 'workflow_dispatch' || github.ref == format('refs/heads/{0}', github.event.inputs.branchName) }}\n\n    runs-on: ubuntu-latest\n    env:\n      AWS_LLC_ACCESS_KEY_ID: ${{ secrets.AWS_LLC_ACCESS_KEY_ID }}\n      AWS_LLC_SECRET_ACCESS_KEY: ${{ secrets.AWS_LLC_SECRET_ACCESS_KEY }}\n      CONVOX_RACK_PRODUCTION_PASSWORD: ${{ secrets.CONVOX_RACK_PRODUCTION_PASSWORD }}\n      CONVOX_RACK_STAGING_PASSWORD: ${{ secrets.CONVOX_RACK_STAGING_PASSWORD }}\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-node@v4\n        with:\n          node-version-file: './.nvmrc'\n\n      #<|user_cursor_is_here|>\n      # envchain balsamiq-aws-srlinternal aws iam create-service-linked-role --aws-service-name es.amazonaws.com\n      # \ud83d\udc46 if it fails with `An error occurred (InvalidInput) when calling the CreateServiceLinkedRole operation: Service role name AWSServiceRoleForAmazonElasticsearchService has been taken in this account, please try a different suffix.` you're good. This means the service role was already created.\n      #\n      #\n      # ( cd lbc/src/lambda/ && nvm exec npm run build ) && ( cd lbc/infrastructure/ && nvm exec envchain balsamiq-aws-srlinternal bin/cli deploy staging new && nvm exec envchain balsamiq-aws-srlinternal bin/cli run staging 'cd ops/ && bin/configure-index-templates' )\n<|editable_region_end|>\n      - run: script/deploy \"${GITHUB_REF:11}\"  # 11 comes from offsetting `refs/heads/` prefix\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```.github/workflows/deploy.yml\n<|start_of_file|>\non:\n  push:\n    branches:\n      - release\n      - staging\n\n  workflow_dispatch:\n    inputs:\n      branchName:\n        description: 'Type name of the branch selected above to confirm (e.g., \"staging\")'\n<|editable_region_start|>\n        required: true\n\njobs:\n  deploy:\n    # When triggered manually, run this job only if user consciously confirms the branch name they've selected from the dropdown\n    if: ${{ github.event_name != 'workflow_dispatch' || github.ref == format('refs/heads/{0}', github.event.inputs.branchName) }}\n\n    runs-on: ubuntu-latest\n    env:\n      AWS_LLC_ACCESS_KEY_ID: ${{ secrets.AWS_LLC_ACCESS_KEY_ID }}\n      AWS_LLC_SECRET_ACCESS_KEY: ${{ secrets.AWS_LLC_SECRET_ACCESS_KEY }}\n      CONVOX_RACK_PRODUCTION_PASSWORD: ${{ secrets.CONVOX_RACK_PRODUCTION_PASSWORD }}\n      CONVOX_RACK_STAGING_PASSWORD: ${{ secrets.CONVOX_RACK_STAGING_PASSWORD }}\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-node@v4\n        with:\n          node-version-file: './.nvmrc'\n\n      # Create the service role\n      # envchain balsamiq-aws-srlinternal aws iam create-service-linked-role --aws-service-name es.amazonaws.com\n      # \ud83d\udc46 if it fails with `An error occurred (InvalidInput) when calling the CreateServiceLinkedRole operation: Service role name AWSServiceRoleForAmazonElasticsearchService has been taken in this account, please try a different suffix.` you're good. This means the service role was already created.\n      #\n      #\n      # ( cd lbc/src/lambda/ && nvm exec npm run build ) && ( cd lbc/infrastructure/ && nvm exec envchain balsamiq-aws-srlinternal bin/cli deploy staging new && nvm exec envchain balsamiq-aws-srlinternal bin/cli run staging 'cd ops/ && bin/configure-index-templates' )\n<|editable_region_end|>\n      - run: script/deploy \"${GITHUB_REF:11}\"  # 11 comes from offsetting `refs/heads/` prefix\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"bindings/rust/lib.rs\":\n```diff\n@@ -25,7 +25,7 @@\n /// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n ///\n /// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\n-pub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_cpp) };\n+pub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_git_commit) };\n \n /// Get the tree-sitter [Language][] for this grammar.\n ///\n\n```\n\nUser edited \"crates/languages/src/lib.rs\":\n```diff\n@@ -74,7 +74,7 @@\n         (\"tsx\", tree_sitter_typescript::LANGUAGE_TSX),\n         (\"typescript\", tree_sitter_typescript::LANGUAGE_TYPESCRIPT),\n         (\"yaml\", tree_sitter_yaml::LANGUAGE),\n-        (\"gitcommit\", tree_sitter_gitcommit::LANGUAGE),\n+        (\"gitcommit\", tree_sitter_gitcommit::language()),\n     ]);\n \n     macro_rules! language {\n\n```\n\nUser edited \"crates/languages/src/lib.rs\":\n```diff\n@@ -74,7 +74,7 @@\n         (\"tsx\", tree_sitter_typescript::LANGUAGE_TSX),\n         (\"typescript\", tree_sitter_typescript::LANGUAGE_TYPESCRIPT),\n         (\"yaml\", tree_sitter_yaml::LANGUAGE),\n-        (\"gitcommit\", tree_sitter_gitcommit::language()),\n+        (\"gitcommit\", tree_sitter_gitcommit::language().into()),\n     ]);\n \n     macro_rules! language {\n\n```\n\nUser edited \"bindings/rust/lib.rs\":\n```diff\n@@ -52,7 +52,7 @@\n     fn test_can_load_grammar() {\n         let mut parser = tree_sitter::Parser::new();\n         parser\n-            .set_language(&super::language())\n+            .set_language(&LAN)\n             .expect(\"Error loading git_commit language\");\n     }\n }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```tree-sitter-git-commit/bindings/rust/lib.rs\n<|start_of_file|>\n//! This crate provides git_commit language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [language][language func] function to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n<|editable_region_start|>\n//! ```\n//! let code = \"\";\n//! let mut parser = tree_sitter::Parser::new();\n//! parser.set_language(&tree_sitter_gitcommit::language()).expect(\"Error loading git_commit grammar\");\n//! let tree = parser.parse(code, None).unwrap();\n//! ```\n//!\n//! [Language]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Language.html\n//! [language func]: fn.language.html\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter::Language;\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_git_commit() -> *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_git_commit) };\n\n/// Get the tree-sitter [Language][] for this grammar.\n///\n/// [Language]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Language.html\npub fn language() -> Language {\n    unsafe { tree_sitter_git_commit().into() }\n}\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: &'static str = include_str!(\"../../src/node-types.json\");\n\n// Uncomment these to include any queries that this grammar contains\n\n// pub const HIGHLIGHTS_QUERY: &'static str = include_str!(\"../../queries/highlights.scm\");\n// pub const INJECTIONS_QUERY: &'static str = include_str!(\"../../queries/injections.scm\");\n// pub const LOCALS_QUERY: &'static str = include_str!(\"../../queries/locals.scm\");\n// pub const TAGS_QUERY: &'static str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(&LAN<|user_cursor_is_here|>)\n            .expect(\"Error loading git_commit language\");\n    }\n}\n<|editable_region_end|>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```tree-sitter-git-commit/bindings/rust/lib.rs\n<|start_of_file|>\n//! This crate provides git_commit language support for the [tree-sitter][] parsing library.\n//!\n//! Typically, you will use the [language][language func] function to add this language to a\n//! tree-sitter [Parser][], and then use the parser to parse some code:\n//!\n<|editable_region_start|>\n//! ```\n//! let code = \"\";\n//! let mut parser = tree_sitter::Parser::new();\n//! parser.set_language(&tree_sitter_gitcommit::language()).expect(\"Error loading git_commit grammar\");\n//! let tree = parser.parse(code, None).unwrap();\n//! ```\n//!\n//! [Language]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Language.html\n//! [language func]: fn.language.html\n//! [Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n//! [tree-sitter]: https://tree-sitter.github.io/\n\nuse tree_sitter::Language;\nuse tree_sitter_language::LanguageFn;\n\nextern \"C\" {\n    fn tree_sitter_git_commit() -> *const ();\n}\n\n/// The tree-sitter [`LanguageFn`][LanguageFn] for this grammar.\n///\n/// [LanguageFn]: https://docs.rs/tree-sitter-language/*/tree_sitter_language/struct.LanguageFn.html\npub const LANGUAGE: LanguageFn = unsafe { LanguageFn::from_raw(tree_sitter_git_commit) };\n\n/// Get the tree-sitter [Language][] for this grammar.\n///\n/// [Language]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Language.html\npub fn language() -> Language {\n    unsafe { tree_sitter_git_commit().into() }\n}\n\n/// The content of the [`node-types.json`][] file for this grammar.\n///\n/// [`node-types.json`]: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types\npub const NODE_TYPES: &'static str = include_str!(\"../../src/node-types.json\");\n\n// Uncomment these to include any queries that this grammar contains\n\n// pub const HIGHLIGHTS_QUERY: &'static str = include_str!(\"../../queries/highlights.scm\");\n// pub const INJECTIONS_QUERY: &'static str = include_str!(\"../../queries/injections.scm\");\n// pub const LOCALS_QUERY: &'static str = include_str!(\"../../queries/locals.scm\");\n// pub const TAGS_QUERY: &'static str = include_str!(\"../../queries/tags.scm\");\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_can_load_grammar() {\n        let mut parser = tree_sitter::Parser::new();\n        parser\n            .set_language(&LANGUAGE)\n            .expect(\"Error loading git_commit language\");\n    }\n}\n<|editable_region_end|>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/input_excerpt.rs\":\n```diff\n@@ -23,7 +23,7 @@\n \n     while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {\n         let parent_tokens = tokens_for_bytes(parent.byte_range().len());\n-        if \n+        if parent.byte\n         if parent_tokens <= editable_region_token_limit {\n             scope_range = Point::new(\n                 parent.start_position().row as u32,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/zeta/src/input_excerpt.rs\n<|start_of_file|>\nuse crate::{\n    tokens_for_bytes, CURSOR_MARKER, EDITABLE_REGION_END_MARKER, EDITABLE_REGION_START_MARKER,\n    START_OF_FILE_MARKER,\n};\nuse language::{BufferSnapshot, Point};\nuse std::{fmt::Write, ops::Range};\n\npub struct InputExcerpt {\n    pub editable_range: Range<Point>,\n<|editable_region_start|>\n    pub prompt: String,\n    pub speculated_output: String,\n}\n\npub fn excerpt_for_cursor_position(\n    position: Point,\n    path: &str,\n    snapshot: &BufferSnapshot,\n    editable_region_token_limit: usize,\n    context_token_limit: usize,\n) -> InputExcerpt {\n    let mut scope_range = position..position;\n    let mut remaining_edit_tokens = editable_region_token_limit;\n\n    while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {\n        let parent_tokens = tokens_for_bytes(parent.byte_range().len());\n        if parent.byte<|user_cursor_is_here|>\n        if parent_tokens <= editable_region_token_limit {\n            scope_range = Point::new(\n                parent.start_position().row as u32,\n                parent.start_position().column as u32,\n            )\n                ..Point::new(\n                    parent.end_position().row as u32,\n                    parent.end_position().column as u32,\n                );\n            remaining_edit_tokens = editable_region_token_limit - parent_tokens;\n        } else {\n            break;\n<|editable_region_end|>\n        }\n    }\n\n    let editable_range = expand_range(snapshot, scope_range, remaining_edit_tokens);\n    let context_range = expand_range(snapshot, editable_range.clone(), context_token_limit);\n\n    let mut prompt = String::new();\n    let mut speculated_output = String::new();\n\n    writeln!(&mut prompt, \"```{path}\").unwrap();\n    if context_range.start == Point::zero() {\n        writeln!(&mut prompt, \"{START_OF_FILE_MARKER}\").unwrap();\n    }\n\n    for chunk in snapshot.chunks(context_range.start..editable_range.start, false) {\n        prompt.push_str(chunk.text);\n    }\n\n    push_editable_range(position, snapshot, editable_range.clone(), &mut prompt);\n    push_editable_range(\n        position,\n        snapshot,\n        editable_range.clone(),\n        &mut speculated_output,\n    );\n\n    for chunk in snapshot.chunks(editable_range.end..context_range.end, false) {\n        prompt.push_str(chunk.text);\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/zeta/src/input_excerpt.rs\n<|start_of_file|>\nuse crate::{\n    tokens_for_bytes, CURSOR_MARKER, EDITABLE_REGION_END_MARKER, EDITABLE_REGION_START_MARKER,\n    START_OF_FILE_MARKER,\n};\nuse language::{BufferSnapshot, Point};\nuse std::{fmt::Write, ops::Range};\n\npub struct InputExcerpt {\n    pub editable_range: Range<Point>,\n<|editable_region_start|>\n    pub prompt: String,\n    pub speculated_output: String,\n}\n\npub fn excerpt_for_cursor_position(\n    position: Point,\n    path: &str,\n    snapshot: &BufferSnapshot,\n    editable_region_token_limit: usize,\n    context_token_limit: usize,\n) -> InputExcerpt {\n    let mut scope_range = position..position;\n    let mut remaining_edit_tokens = editable_region_token_limit;\n\n    while let Some(parent) = snapshot.syntax_ancestor(scope_range.clone()) {\n        let parent_tokens = tokens_for_bytes(parent.byte_range().len());\n        if parent.byte_range() == scope_range {\n            \n        } else if parent_tokens <= editable_region_token_limit {\n            scope_range = Point::new(\n                parent.start_position().row as u32,\n                parent.start_position().column as u32,\n            )\n                ..Point::new(\n                    parent.end_position().row as u32,\n                    parent.end_position().column as u32,\n                );\n            remaining_edit_tokens = editable_region_token_limit - parent_tokens;\n        } else {\n            break;\n<|editable_region_end|>\n        }\n    }\n\n    let editable_range = expand_range(snapshot, scope_range, remaining_edit_tokens);\n    let context_range = expand_range(snapshot, editable_range.clone(), context_token_limit);\n\n    let mut prompt = String::new();\n    let mut speculated_output = String::new();\n\n    writeln!(&mut prompt, \"```{path}\").unwrap();\n    if context_range.start == Point::zero() {\n        writeln!(&mut prompt, \"{START_OF_FILE_MARKER}\").unwrap();\n    }\n\n    for chunk in snapshot.chunks(context_range.start..editable_range.start, false) {\n        prompt.push_str(chunk.text);\n    }\n\n    push_editable_range(position, snapshot, editable_range.clone(), &mut prompt);\n    push_editable_range(\n        position,\n        snapshot,\n        editable_range.clone(),\n        &mut speculated_output,\n    );\n\n    for chunk in snapshot.chunks(editable_range.end..context_range.end, false) {\n        prompt.push_str(chunk.text);\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/remote_server/src/remote_editing_tests.rs\":\n```diff\n@@ -1271,6 +1271,9 @@\n     assert_eq!(server_branch.as_ref(), \"totally-new-branch\");\n }\n \n+#[gpui::test]\n+async fn test_\n+\n pub async fn init_test(\n     server_fs: &Arc<FakeFs>,\n     cx: &mut TestAppContext,\n\n```\n\nUser edited \"crates/remote_server/src/remote_editing_tests.rs\":\n```diff\n@@ -1272,7 +1272,7 @@\n }\n \n #[gpui::test]\n-async fn test_\n+async fn test_remote_\n \n pub async fn init_test(\n     server_fs: &Arc<FakeFs>,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/remote_server/src/remote_editing_tests.rs\n                        .current_branch(root_path.clone(), cx)\n                        .unwrap()\n                })\n        })\n    });\n\n    assert_eq!(server_branch.as_ref(), branches[2]);\n\n    // Also try creating a new branch\n    cx.update(|cx| {\n        project.update(cx, |project, cx| {\n<|editable_region_start|>\n            project.update_or_create_branch(root_path.clone(), \"totally-new-branch\".to_string(), cx)\n        })\n    })\n    .await\n    .unwrap();\n\n    cx.run_until_parked();\n\n    let server_branch = server_cx.update(|cx| {\n        headless_project.update(cx, |headless_project, cx| {\n            headless_project\n                .worktree_store\n                .update(cx, |worktree_store, cx| {\n                    worktree_store.current_branch(root_path, cx).unwrap()\n                })\n        })\n    });\n\n    assert_eq!(server_branch.as_ref(), \"totally-new-branch\");\n}\n\n#[gpui::test]\nasync fn test_remote_<|user_cursor_is_here|>\n\npub async fn init_test(\n    server_fs: &Arc<FakeFs>,\n    cx: &mut TestAppContext,\n    server_cx: &mut TestAppContext,\n) -> (Entity<Project>, Entity<HeadlessProject>) {\n    let server_fs = server_fs.clone();\n    cx.update(|cx| {\n        release_channel::init(SemanticVersion::default(), cx);\n    });\n    server_cx.update(|cx| {\n        release_channel::init(SemanticVersion::default(), cx);\n    });\n    init_logger();\n\n    let (opts, ssh_server_client) = SshRemoteClient::fake_server(cx, server_cx);\n    let http_client = Arc::new(BlockedHttpClient);\n    let node_runtime = NodeRuntime::unavailable();\n<|editable_region_end|>\n    let languages = Arc::new(LanguageRegistry::new(cx.executor()));\n    let proxy = Arc::new(ExtensionHostProxy::new());\n    server_cx.update(HeadlessProject::init);\n    let headless = server_cx.new(|cx| {\n        client::init_settings(cx);\n\n        HeadlessProject::new(\n            crate::HeadlessAppState {\n                session: ssh_server_client,\n                fs: server_fs.clone(),\n                http_client,\n                node_runtime,\n                languages,\n                extension_host_proxy: proxy,\n            },\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/remote_server/src/remote_editing_tests.rs\n                        .current_branch(root_path.clone(), cx)\n                        .unwrap()\n                })\n        })\n    });\n\n    assert_eq!(server_branch.as_ref(), branches[2]);\n\n    // Also try creating a new branch\n    cx.update(|cx| {\n        project.update(cx, |project, cx| {\n<|editable_region_start|>\n            project.update_or_create_branch(root_path.clone(), \"totally-new-branch\".to_string(), cx)\n        })\n    })\n    .await\n    .unwrap();\n\n    cx.run_until_parked();\n\n    let server_branch = server_cx.update(|cx| {\n        headless_project.update(cx, |headless_project, cx| {\n            headless_project\n                .worktree_store\n                .update(cx, |worktree_store, cx| {\n                    worktree_store.current_branch(root_path, cx).unwrap()\n                })\n        })\n    });\n\n    assert_eq!(server_branch.as_ref(), \"totally-new-branch\");\n}\n\n#[gpui::test]\nasync fn test_remote_branch_creation(cx: &mut TestAppContext, server_cx: &mut TestAppContext) {\n    let (project, headless_project) = init_test(server_fs, cx, server_cx);\n}\n\npub async fn init_test(\n    server_fs: &Arc<FakeFs>,\n    cx: &mut TestAppContext,\n    server_cx: &mut TestAppContext,\n) -> (Entity<Project>, Entity<HeadlessProject>) {\n    let server_fs = server_fs.clone();\n    cx.update(|cx| {\n        release_channel::init(SemanticVersion::default(), cx);\n    });\n    server_cx.update(|cx| {\n        release_channel::init(SemanticVersion::default(), cx);\n    });\n    init_logger();\n\n    let (opts, ssh_server_client) = SshRemoteClient::fake_server(cx, server_cx);\n    let http_client = Arc::new(BlockedHttpClient);\n    let node_runtime = NodeRuntime::unavailable();\n<|editable_region_end|>\n    let languages = Arc::new(LanguageRegistry::new(cx.executor()));\n    let proxy = Arc::new(ExtensionHostProxy::new());\n    server_cx.update(HeadlessProject::init);\n    let headless = server_cx.new(|cx| {\n        client::init_settings(cx);\n\n        HeadlessProject::new(\n            crate::HeadlessAppState {\n                session: ssh_server_client,\n                fs: server_fs.clone(),\n                http_client,\n                node_runtime,\n                languages,\n                extension_host_proxy: proxy,\n            },\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/panel/src/panel.rs\":\n```diff\n@@ -70,7 +70,7 @@\n     panel_icon_button(id, icon).style(ui::ButtonStyle::Filled)\n }\n \n-\n+pub fn panel_ed\n \n pub fn panel_edge_to_edge_editor(editor: Entity<Editor>, window: &mut Window, cx: &mut App) -> Div {\n     let bg_color = cx.theme().colors().editor_background;\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/panel/src/panel.rs\nimpl RenderOnce for PanelTab {\n    fn render(self, _window: &mut Window, _cx: &mut App) -> impl IntoElement {\n        div()\n    }\n}\n\npub fn panel_button(label: impl Into<SharedString>) -> ui::Button {\n    let label = label.into();\n    let id = ElementId::Name(label.clone().to_lowercase().replace(' ', \"_\").into());\n    ui::Button::new(id, label)\n        .label_size(ui::LabelSize::Small)\n        // TODO: Change this once we use on_surface_bg in button_like\n        .layer(ui::ElevationIndex::ModalSurface)\n        .size(ui::ButtonSize::Compact)\n}\n\npub fn panel_filled_button(label: impl Into<SharedString>) -> ui::Button {\n    panel_button(label).style(ui::ButtonStyle::Filled)\n}\n\npub fn panel_icon_button(id: impl Into<SharedString>, icon: IconName) -> ui::IconButton {\n    let id = ElementId::Name(id.into());\n    ui::IconButton::new(id, icon)\n        // TODO: Change this once we use on_surface_bg in button_like\n        .layer(ui::ElevationIndex::ModalSurface)\n<|editable_region_start|>\n        .size(ui::ButtonSize::Compact)\n}\n\npub fn panel_filled_icon_button(id: impl Into<SharedString>, icon: IconName) -> ui::IconButton {\n    panel_icon_button(id, icon).style(ui::ButtonStyle::Filled)\n}\n\npub fn panel_ed<|user_cursor_is_here|>\n\npub fn panel_edge_to_edge_editor(editor: Entity<Editor>, window: &mut Window, cx: &mut App) -> Div {\n    let bg_color = cx.theme().colors().editor_background;\n    let font_size = TextSize::Editor.rems(cx);\n    let line_height = window.line_height();\n\n    let settings = ThemeSettings::get_global(cx);\n    let text_style = TextStyle {\n        color: cx.theme().colors().text,\n        font_family: settings.ui_font.family.clone(),\n        font_features: settings.ui_font.features.clone(),\n        font_size: font_size.into(),\n        font_weight: settings.ui_font.weight,\n<|editable_region_end|>\n        line_height: line_height.into(),\n        ..Default::default()\n    };\n\n    let editor_element = EditorElement::new(\n        &editor,\n        EditorStyle {\n            background: bg_color,\n            local_player: cx.theme().players().local(),\n            text: text_style,\n            ..Default::default()\n        },\n    );\n\n    div()\n        .w_full()\n        .h_full()\n        .bg(cx.theme().colors().background)\n        .border_b_1()\n        .border_color(cx.theme().colors().border)\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/panel/src/panel.rs\nimpl RenderOnce for PanelTab {\n    fn render(self, _window: &mut Window, _cx: &mut App) -> impl IntoElement {\n        div()\n    }\n}\n\npub fn panel_button(label: impl Into<SharedString>) -> ui::Button {\n    let label = label.into();\n    let id = ElementId::Name(label.clone().to_lowercase().replace(' ', \"_\").into());\n    ui::Button::new(id, label)\n        .label_size(ui::LabelSize::Small)\n        // TODO: Change this once we use on_surface_bg in button_like\n        .layer(ui::ElevationIndex::ModalSurface)\n        .size(ui::ButtonSize::Compact)\n}\n\npub fn panel_filled_button(label: impl Into<SharedString>) -> ui::Button {\n    panel_button(label).style(ui::ButtonStyle::Filled)\n}\n\npub fn panel_icon_button(id: impl Into<SharedString>, icon: IconName) -> ui::IconButton {\n    let id = ElementId::Name(id.into());\n    ui::IconButton::new(id, icon)\n        // TODO: Change this once we use on_surface_bg in button_like\n        .layer(ui::ElevationIndex::ModalSurface)\n<|editable_region_start|>\n        .size(ui::ButtonSize::Compact)\n}\n\npub fn panel_filled_icon_button(id: impl Into<SharedString>, icon: IconName) -> ui::IconButton {\n    panel_icon_button(id, icon).style(ui::ButtonStyle::Filled)\n}\n\npub fn panel_editor_container(editor: Entity<Editor>, window: &mut Window, cx: &mut App) -> Div {\n    \n}\n\npub fn panel_edge_to_edge_editor(editor: Entity<Editor>, window: &mut Window, cx: &mut App) -> Div {\n    let bg_color = cx.theme().colors().editor_background;\n    let font_size = TextSize::Editor.rems(cx);\n    let line_height = window.line_height();\n\n    let settings = ThemeSettings::get_global(cx);\n    let text_style = TextStyle {\n        color: cx.theme().colors().text,\n        font_family: settings.ui_font.family.clone(),\n        font_features: settings.ui_font.features.clone(),\n        font_size: font_size.into(),\n        font_weight: settings.ui_font.weight,\n<|editable_region_end|>\n        line_height: line_height.into(),\n        ..Default::default()\n    };\n\n    let editor_element = EditorElement::new(\n        &editor,\n        EditorStyle {\n            background: bg_color,\n            local_player: cx.theme().players().local(),\n            text: text_style,\n            ..Default::default()\n        },\n    );\n\n    div()\n        .w_full()\n        .h_full()\n        .bg(cx.theme().colors().background)\n        .border_b_1()\n        .border_color(cx.theme().colors().border)\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/collab/src/db/tables/worktree_repository.rs\":\n```diff\n@@ -13,6 +13,7 @@\n     pub scan_id: i64,\n     pub branch: Option<String>,\n     pub is_deleted: bool,\n+    /\n     pub current_merge_conflicts: String,\n }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/collab/src/db/tables/worktree_repository.rs\n<|start_of_file|>\nuse crate::db::ProjectId;\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = \"worktree_repositories\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub project_id: ProjectId,\n    #[sea_orm(primary_key)]\n    pub worktree_id: i64,\n    #[sea_orm(primary_key)]\n<|editable_region_start|>\n    pub work_directory_id: i64,\n    pub scan_id: i64,\n    pub branch: Option<String>,\n    pub is_deleted: bool,\n    /<|user_cursor_is_here|>\n    pub current_merge_conflicts: String,\n}\n<|editable_region_end|>\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/collab/src/db/tables/worktree_repository.rs\n<|start_of_file|>\nuse crate::db::ProjectId;\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = \"worktree_repositories\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub project_id: ProjectId,\n    #[sea_orm(primary_key)]\n    pub worktree_id: i64,\n    #[sea_orm(primary_key)]\n<|editable_region_start|>\n    pub work_directory_id: i64,\n    pub scan_id: i64,\n    pub branch: Option<String>,\n    pub is_deleted: bool,\n    /// A list of all git merge conflicts in the worktree\n    pub current_merge_conflicts: String,\n}\n<|editable_region_end|>\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"services/webserver/src/server/websocket/session.rs\":\n```diff\n@@ -40,6 +40,7 @@\n         session: &mut Session,\n         message: ServerResponse,\n     ) -> Result<(), WebsocketError> {\n+        \n         let msg_encoded = serde_json::to_vec(&message)\n             .map_err(WebsocketError::UnserializablePayload)?;\n         session.binary(msg_encoded).await?;\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```services/webserver/src/server/websocket/session.rs\n    FuelStreams,\n};\nuse fuel_web_utils::{\n    server::middlewares::api_key::{\n        rate_limiter::RateLimitsController,\n        ApiKey,\n    },\n    telemetry::Telemetry,\n};\nuse tokio::sync::{broadcast, Mutex};\n<|editable_region_start|>\n\nuse crate::{\n    metrics::{Metrics, SubscriptionChange},\n    server::errors::WebsocketError,\n};\n\n#[derive(Clone)]\nstruct MessageHandler {\n    api_key: ApiKey,\n}\n\nimpl MessageHandler {\n    fn new(api_key: &ApiKey) -> Self {\n        Self {\n            api_key: api_key.to_owned(),\n        }\n    }\n\n    async fn send_message(\n        &self,\n        session: &mut Session,\n        message: ServerResponse,\n    ) -> Result<(), WebsocketError> {\n        <|user_cursor_is_here|>\n        let msg_encoded = serde_json::to_vec(&message)\n            .map_err(WebsocketError::UnserializablePayload)?;\n        session.binary(msg_encoded).await?;\n        Ok(())\n    }\n\n    async fn send_error(\n        &self,\n        session: &mut Session,\n        error: &WebsocketError,\n    ) -> Result<(), WebsocketError> {\n        let api_key = self.api_key.to_owned();\n        let error_msg = ServerResponse::Error(error.to_string());\n        if let Err(send_err) = self.send_message(session, error_msg).await {\n            tracing::error!(\n                %api_key,\n                error = %send_err,\n                \"Failed to send error message\"\n            );\n            return Err(WebsocketError::SendError);\n        }\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\nstruct MetricsHandler {\n    telemetry: Arc<Telemetry<Metrics>>,\n    api_key: ApiKey,\n}\n\n<|editable_region_end|>\nimpl MetricsHandler {\n    fn new(telemetry: Arc<Telemetry<Metrics>>, api_key: &ApiKey) -> Self {\n```"}, {"role": "assistant", "content": "Suggestion:\n```services/webserver/src/server/websocket/session.rs\n    FuelStreams,\n};\nuse fuel_web_utils::{\n    server::middlewares::api_key::{\n        rate_limiter::RateLimitsController,\n        ApiKey,\n    },\n    telemetry::Telemetry,\n};\nuse tokio::sync::{broadcast, Mutex};\n<|editable_region_start|>\n\nuse crate::{\n    metrics::{Metrics, SubscriptionChange},\n    server::errors::WebsocketError,\n};\n\n#[derive(Clone)]\nstruct MessageHandler {\n    api_key: ApiKey,\n}\n\nimpl MessageHandler {\n    fn new(api_key: &ApiKey) -> Self {\n        Self {\n            api_key: api_key.to_owned(),\n        }\n    }\n\n    async fn send_message(\n        &self,\n        session: &mut Session,\n        message: ServerResponse,\n    ) -> Result<(), WebsocketError> {\n        tracing::debug!(%self.api_key, \"Sending websocket message\");\n        let msg_encoded = serde_json::to_vec(&message)\n            .map_err(WebsocketError::UnserializablePayload)?;\n        session.binary(msg_encoded).await?;\n        Ok(())\n    }\n\n    async fn send_error(\n        &self,\n        session: &mut Session,\n        error: &WebsocketError,\n    ) -> Result<(), WebsocketError> {\n        let api_key = self.api_key.to_owned();\n        let error_msg = ServerResponse::Error(error.to_string());\n        if let Err(send_err) = self.send_message(session, error_msg).await {\n            tracing::error!(\n                %api_key,\n                error = %send_err,\n                \"Failed to send error message\"\n            );\n            return Err(WebsocketError::SendError);\n        }\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\nstruct MetricsHandler {\n    telemetry: Arc<Telemetry<Metrics>>,\n    api_key: ApiKey,\n}\n\n<|editable_region_end|>\nimpl MetricsHandler {\n    fn new(telemetry: Arc<Telemetry<Metrics>>, api_key: &ApiKey) -> Self {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"app/models/user.rb\":\n```diff\n@@ -81,7 +81,7 @@\n     omniauth_providers: %i[facebook facebook_analytics google_oauth2 google_specific_video]\n \n   # Enums\n-  enum role: {user: 0, creator: 1, delegate: 2, admin: 3}\n+  enum :role: {user: 0, creator: 1, delegate: 2, admin: 3}\n \n   # Associations\n   delegated_type :profileable, types: %w[Creator Delegate Admin Bot], dependent: :destroy\n\n```\n\nUser edited \"app/models/user.rb\":\n```diff\n@@ -81,7 +81,7 @@\n     omniauth_providers: %i[facebook facebook_analytics google_oauth2 google_specific_video]\n \n   # Enums\n-  enum :role: {user: 0, creator: 1, delegate: 2, admin: 3}\n+  enum :role,user: 0, creator: 1, delegate: 2, admin: 3}\n \n   # Associations\n   delegated_type :profileable, types: %w[Creator Delegate Admin Bot], dependent: :destroy\n\n```\n\nUser edited \"app/models/user.rb\":\n```diff\n@@ -81,7 +81,7 @@\n     omniauth_providers: %i[facebook facebook_analytics google_oauth2 google_specific_video]\n \n   # Enums\n-  enum :role,user: 0, creator: 1, delegate: 2, admin: 3}\n+  enum :role, user: 0, creator: 1, delegate: 2, admin: 3\n \n   # Associations\n   delegated_type :profileable, types: %w[Creator Delegate Admin Bot], dependent: :destroy\n\n```\n\nUser edited \"app/models/campaign.rb\":\n```diff\n@@ -137,7 +137,7 @@\n   validates :title, :posting_date, presence: true\n \n   # Enums\n-  enum status: {fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5}\n+  enum :status fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5}\n \n   # 3rd Party\n   has_noticed_notifications\n\n```\n\nUser edited \"app/models/campaign.rb\":\n```diff\n@@ -137,7 +137,7 @@\n   validates :title, :posting_date, presence: true\n \n   # Enums\n-  enum :status fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5}\n+  enum :status, fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5}\n \n   # 3rd Party\n   has_noticed_notifications\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```app/models/campaign.rb\n  # def creator\n  #   super || legacy_users.creator.first.creator\n  # end\n\n  # Active Storage\n  has_one_attached :brief_document\n  has_one_attached :legal_document\n\n  # Action Text\n  has_rich_text :additional_disclaimer\n  has_rich_text :tracking_links_and_discount_codes\n\n  # Scopes\n  scope :ongoing, -> { where(status: %w[term_agreement content_creation]) }\n  scope :done, -> { where(status: %w[complete declined]) }\n  scope :past_schedule, -> { where(posting_date: ..Time.zone.now) }\n  scope :upcoming_schedule, -> { where(posting_date: Time.zone.now..) }\n\n  scope :by_stage,\n    ->(stage) {\n      if stage.present?\n        if %w[past_schedule upcoming_schedule].include?(stage)\n          (stage == \"past_schedule\") ? past_schedule.order(posting_date: :desc) : upcoming_schedule.order(posting_date: :asc)\n        else\n          where(status: stage)\n        end\n      end\n    }\n\n  # Validations\n  validates :title, :posting_date, presence: true\n<|editable_region_start|>\n\n  # Enums\n  enum :status, <|user_cursor_is_here|>fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5}\n\n  # 3rd Party\n  has_noticed_notifications\n  monetize :custom_price_cents, with_model_currency: :currency, allow_nil: true\n  monetize :final_price_cents, with_model_currency: :currency, allow_nil: true\n\n  # Nested attributes\n  accepts_nested_attributes_for :campaign_deliverables, reject_if: ->(attributes) { attributes[\"quantity\"].to_i < 1 }, allow_destroy: true\n\n  # Callbacks\n  before_validation on: :create do\n    set_default_organization\n    set_default_current_delegate\n    set_default_currency\n    set_default_organization\n<|editable_region_end|>\n  end\n\n  before_validation :calculate_final_price\n  before_validation :assign_status_for_external_campaigns\n  before_validation :add_deadline_dates\n\n  after_update_commit :set_posting_date_for_deliverables\n  after_update_commit :set_payment_due_at\n  after_update_commit :accept_agreement, if: :accepting_agreement_kind\n\n  # Decorators / Helpers\n\n  def delegate\n    primary_delegate || delegates.first\n  end\n\n  def members\n    [creator_user, primary_delegate&.user || delegate_users, owner].flatten.compact\n```"}, {"role": "assistant", "content": "Suggestion:\n```app/models/campaign.rb\n  # def creator\n  #   super || legacy_users.creator.first.creator\n  # end\n\n  # Active Storage\n  has_one_attached :brief_document\n  has_one_attached :legal_document\n\n  # Action Text\n  has_rich_text :additional_disclaimer\n  has_rich_text :tracking_links_and_discount_codes\n\n  # Scopes\n  scope :ongoing, -> { where(status: %w[term_agreement content_creation]) }\n  scope :done, -> { where(status: %w[complete declined]) }\n  scope :past_schedule, -> { where(posting_date: ..Time.zone.now) }\n  scope :upcoming_schedule, -> { where(posting_date: Time.zone.now..) }\n\n  scope :by_stage,\n    ->(stage) {\n      if stage.present?\n        if %w[past_schedule upcoming_schedule].include?(stage)\n          (stage == \"past_schedule\") ? past_schedule.order(posting_date: :desc) : upcoming_schedule.order(posting_date: :asc)\n        else\n          where(status: stage)\n        end\n      end\n    }\n\n  # Validations\n  validates :title, :posting_date, presence: true\n<|editable_region_start|>\n\n  # Enums\n  enum :status, fresh: 0, term_agreement: 1, content_creation: 2, payment: 3, complete: 4, declined: 5\n\n  # 3rd Party\n  has_noticed_notifications\n  monetize :custom_price_cents, with_model_currency: :currency, allow_nil: true\n  monetize :final_price_cents, with_model_currency: :currency, allow_nil: true\n\n  # Nested attributes\n  accepts_nested_attributes_for :campaign_deliverables, reject_if: ->(attributes) { attributes[\"quantity\"].to_i < 1 }, allow_destroy: true\n\n  # Callbacks\n  before_validation on: :create do\n    set_default_organization\n    set_default_current_delegate\n    set_default_currency\n    set_default_organization\n<|editable_region_end|>\n  end\n\n  before_validation :calculate_final_price\n  before_validation :assign_status_for_external_campaigns\n  before_validation :add_deadline_dates\n\n  after_update_commit :set_posting_date_for_deliverables\n  after_update_commit :set_payment_due_at\n  after_update_commit :accept_agreement, if: :accepting_agreement_kind\n\n  # Decorators / Helpers\n\n  def delegate\n    primary_delegate || delegates.first\n  end\n\n  def members\n    [creator_user, primary_delegate&.user || delegate_users, owner].flatten.compact\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -19,6 +19,7 @@\n   \"buffer_font_size\": 14.0,\n   // \"buffer_font_weight\": 2000,\n   \"buffer_font_family\": \"Maple Mono NF\",\n+  \"\"\n   \"buffer_font_features\": {\n     \"cv01\": 1,\n     \"cv03\": 1,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n<|start_of_file|>\n// Zed settings\n//\n// For information on how to configure Zed, see the Zed\n// documentation: https://zed.dev/docs/configuring-zed\n//\n// To see all of Zed's default settings without changing your\n// custom settings, run `zed: open default settings` from the\n// command palette\n{\n<|editable_region_start|>\n  \"vim_mode\": false,\n  \"assistant\": {\n    \"default_model\": {\n      \"provider\": \"zed.dev\",\n      \"model\": \"claude-3-5-sonnet-latest\"\n    },\n    \"version\": \"2\"\n  },\n  \"ui_font_size\": 15,\n  \"buffer_font_size\": 14.0,\n  // \"buffer_font_weight\": 2000,\n  \"buffer_font_family\": \"Maple Mono NF\",\n  \"<|user_cursor_is_here|>\"\n  \"buffer_font_features\": {\n    \"cv01\": 1,\n    \"cv03\": 1,\n    \"ss03\": 1\n  },\n  \"theme\": {\n    \"mode\": \"system\",\n    \"light\": \"One Light\",\n    \"dark\": \"One Dark\"\n  },\n  // \"theme\": \"Solarized Dark\",\n  \"features\": {\n    \"inline_completion_provider\": \"zed\"\n  },\n  \"terminal\": {\n<|editable_region_end|>\n    \"font_family\": \"Maple Mono\",\n    \"shell\": {\n      \"program\": \"pwsh.exe\"\n      // \"with_arguments\": {\n      //   \"program\": \"pwsh.exe\",\n      //   \"args\": [\"-nologo\"]\n      // }\n    }\n  },\n  \"proxy\": \"http://127.0.0.1:10809\"\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n<|start_of_file|>\n// Zed settings\n//\n// For information on how to configure Zed, see the Zed\n// documentation: https://zed.dev/docs/configuring-zed\n//\n// To see all of Zed's default settings without changing your\n// custom settings, run `zed: open default settings` from the\n// command palette\n{\n<|editable_region_start|>\n  \"vim_mode\": false,\n  \"assistant\": {\n    \"default_model\": {\n      \"provider\": \"zed.dev\",\n      \"model\": \"claude-3-5-sonnet-latest\"\n    },\n    \"version\": \"2\"\n  },\n  \"ui_font_size\": 15,\n  \"buffer_font_size\": 14.0,\n  // \"buffer_font_weight\": 2000,\n  \"buffer_font_family\": \"Maple Mono NF\",\n  \"buffer_line_height\": \"comfortable\",\n  \"buffer_font_features\": {\n    \"cv01\": 1,\n    \"cv03\": 1,\n    \"ss03\": 1\n  },\n  \"theme\": {\n    \"mode\": \"system\",\n    \"light\": \"One Light\",\n    \"dark\": \"One Dark\"\n  },\n  // \"theme\": \"Solarized Dark\",\n  \"features\": {\n    \"inline_completion_provider\": \"zed\"\n  },\n  \"terminal\": {\n<|editable_region_end|>\n    \"font_family\": \"Maple Mono\",\n    \"shell\": {\n      \"program\": \"pwsh.exe\"\n      // \"with_arguments\": {\n      //   \"program\": \"pwsh.exe\",\n      //   \"args\": [\"-nologo\"]\n      // }\n    }\n  },\n  \"proxy\": \"http://127.0.0.1:10809\"\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -12513,6 +12513,9 @@\n     }\n }\n \n+#[gpuy]\n+async fn \n+\n #[gpui::test]\n async fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {\n     init_test(cx, |_| {});\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/editor_tests.rs\n    // Now, when all ranges selected belong to buffer_1, the revert should succeed,\n    // but not affect buffer_2 and its related excerpts.\n    editor.update(cx, |editor, cx| {\n        assert_eq!(\n            editor.text(cx),\n            \"aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}\"\n        );\n    });\n    buffer_1.update(cx, |buffer, _| {\n        assert_eq!(buffer.text(), base_text_1);\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert_eq!(\n            buffer.text(),\n<|editable_region_start|>\n            \"Xlll\\nXmmm\\nXnnn\\nXooo\\nXppp\\nXqqq\\nXrrr\\nXsss\\nXttt\\nXuuu\"\n        );\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert_eq!(\n            buffer.text(),\n            \"Xvvv\\nXwww\\nXxxx\\nXyyy\\nXzzz\\nX{{{\\nX|||\\nX}}}\\nX~~~\\nX\\u{7f}\\u{7f}\\u{7f}\"\n        );\n    });\n\n    fn edit_first_char_of_every_line(text: &str) -> String {\n        text.split('\\n')\n            .map(|line| format!(\"X{}\", &line[1..]))\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }\n}\n\n#[gpuy<|user_cursor_is_here|>]\nasync fn \n\n#[gpui::test]\nasync fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let cols = 4;\n    let rows = 10;\n    let sample_text_1 = sample_text(rows, cols, 'a');\n    assert_eq!(\n<|editable_region_end|>\n        sample_text_1,\n        \"aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\"\n    );\n    let sample_text_2 = sample_text(rows, cols, 'l');\n    assert_eq!(\n        sample_text_2,\n        \"llll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu\"\n    );\n    let sample_text_3 = sample_text(rows, cols, 'v');\n    assert_eq!(\n        sample_text_3,\n        \"vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}\"\n    );\n\n    let buffer_1 = cx.new(|cx| Buffer::local(sample_text_1.clone(), cx));\n    let buffer_2 = cx.new(|cx| Buffer::local(sample_text_2.clone(), cx));\n    let buffer_3 = cx.new(|cx| Buffer::local(sample_text_3.clone(), cx));\n\n    let multi_buffer = cx.new(|cx| {\n        let mut multibuffer = MultiBuffer::new(ReadWrite);\n        multibuffer.push_excerpts(\n            buffer_1.clone(),\n            [\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/editor_tests.rs\n    // Now, when all ranges selected belong to buffer_1, the revert should succeed,\n    // but not affect buffer_2 and its related excerpts.\n    editor.update(cx, |editor, cx| {\n        assert_eq!(\n            editor.text(cx),\n            \"aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}\"\n        );\n    });\n    buffer_1.update(cx, |buffer, _| {\n        assert_eq!(buffer.text(), base_text_1);\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert_eq!(\n            buffer.text(),\n<|editable_region_start|>\n            \"Xlll\\nXmmm\\nXnnn\\nXooo\\nXppp\\nXqqq\\nXrrr\\nXsss\\nXttt\\nXuuu\"\n        );\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert_eq!(\n            buffer.text(),\n            \"Xvvv\\nXwww\\nXxxx\\nXyyy\\nXzzz\\nX{{{\\nX|||\\nX}}}\\nX~~~\\nX\\u{7f}\\u{7f}\\u{7f}\"\n        );\n    });\n\n    fn edit_first_char_of_every_line(text: &str) -> String {\n        text.split('\\n')\n            .map(|line| format!(\"X{}\", &line[1..]))\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }\n}\n\n#[gpui::test]\nasync fn test_multibuffer_revert_changes(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n}\n\n#[gpui::test]\nasync fn test_mutlibuffer_in_navigation_history(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let cols = 4;\n    let rows = 10;\n    let sample_text_1 = sample_text(rows, cols, 'a');\n    assert_eq!(\n<|editable_region_end|>\n        sample_text_1,\n        \"aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\"\n    );\n    let sample_text_2 = sample_text(rows, cols, 'l');\n    assert_eq!(\n        sample_text_2,\n        \"llll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu\"\n    );\n    let sample_text_3 = sample_text(rows, cols, 'v');\n    assert_eq!(\n        sample_text_3,\n        \"vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}\"\n    );\n\n    let buffer_1 = cx.new(|cx| Buffer::local(sample_text_1.clone(), cx));\n    let buffer_2 = cx.new(|cx| Buffer::local(sample_text_2.clone(), cx));\n    let buffer_3 = cx.new(|cx| Buffer::local(sample_text_3.clone(), cx));\n\n    let multi_buffer = cx.new(|cx| {\n        let mut multibuffer = MultiBuffer::new(ReadWrite);\n        multibuffer.push_excerpts(\n            buffer_1.clone(),\n            [\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/vim/src/normal/paste.rs\":\n```diff\n@@ -732,6 +732,7 @@\n             Mode::Normal,\n         );\n         cx.simulate_keystrokes(\"4 g l w escape d i w 0 shift-p\");\n+        cx.a\n         cx.assert_state(\n             indoc! {\"\n                on\u02c7efish\u2022\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/vim/src/normal/paste.rs\n        cx.simulate_shared_keystrokes(\"\\\" \\\" d ^\").await;\n        cx.shared_register('0').await.assert_eq(\"the \");\n        cx.shared_register('\"').await.assert_eq(\"the \");\n\n        cx.simulate_shared_keystrokes(\"^ \\\" + d $\").await;\n        cx.shared_clipboard().await.assert_eq(\"lazy dog\");\n        cx.shared_register('\"').await.assert_eq(\"lazy dog\");\n\n        cx.simulate_shared_keystrokes(\"/ d o g enter\").await;\n        cx.shared_register('/').await.assert_eq(\"dog\");\n        cx.simulate_shared_keystrokes(\"\\\" / shift-p\").await;\n        cx.shared_state().await.assert_eq(indoc! {\"\n                The quick brown\n                do\u02c7g\"});\n\n        // not testing nvim as it doesn't have a filename\n        cx.simulate_keystrokes(\"\\\" % p\");\n        #[cfg(not(target_os = \"windows\"))]\n        cx.assert_state(\n            indoc! {\"\n                    The quick brown\n                    dogdir/file.r\u02c7s\"},\n<|editable_region_start|>\n            Mode::Normal,\n        );\n        #[cfg(target_os = \"windows\")]\n        cx.assert_state(\n            indoc! {\"\n                    The quick brown\n                    dogdir\\\\file.r\u02c7s\"},\n            Mode::Normal,\n        );\n    }\n\n    #[gpui::test]\n    async fn test_multicursor_paste(cx: &mut gpui::TestAppContext) {\n        let mut cx = VimTestContext::new(cx, true).await;\n\n        cx.update_global(|store: &mut SettingsStore, cx| {\n            store.update_user_settings::<VimSettings>(cx, |s| {\n                s.use_system_clipboard = Some(UseSystemClipboard::Never)\n            });\n        });\n\n        cx.set_state(\n            indoc! {\"\n               \u02c7fish one\n               fish two\n               fish red\n               fish blue\n                \"},\n            Mode::Normal,\n        );\n        cx.simulate_keystrokes(\"4 g l w escape d i w 0 shift-p\");\n        cx.<|user_cursor_is_here|>a\n        cx.assert_state(\n            indoc! {\"\n               on\u02c7efish\u2022\n               tw\u02c7ofish\u2022\n               re\u02c7dfish\u2022\n               blu\u02c7efish\u2022\n                \"},\n<|editable_region_end|>\n            Mode::Normal,\n        );\n    }\n}\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/vim/src/normal/paste.rs\n        cx.simulate_shared_keystrokes(\"\\\" \\\" d ^\").await;\n        cx.shared_register('0').await.assert_eq(\"the \");\n        cx.shared_register('\"').await.assert_eq(\"the \");\n\n        cx.simulate_shared_keystrokes(\"^ \\\" + d $\").await;\n        cx.shared_clipboard().await.assert_eq(\"lazy dog\");\n        cx.shared_register('\"').await.assert_eq(\"lazy dog\");\n\n        cx.simulate_shared_keystrokes(\"/ d o g enter\").await;\n        cx.shared_register('/').await.assert_eq(\"dog\");\n        cx.simulate_shared_keystrokes(\"\\\" / shift-p\").await;\n        cx.shared_state().await.assert_eq(indoc! {\"\n                The quick brown\n                do\u02c7g\"});\n\n        // not testing nvim as it doesn't have a filename\n        cx.simulate_keystrokes(\"\\\" % p\");\n        #[cfg(not(target_os = \"windows\"))]\n        cx.assert_state(\n            indoc! {\"\n                    The quick brown\n                    dogdir/file.r\u02c7s\"},\n<|editable_region_start|>\n            Mode::Normal,\n        );\n        #[cfg(target_os = \"windows\")]\n        cx.assert_state(\n            indoc! {\"\n                    The quick brown\n                    dogdir\\\\file.r\u02c7s\"},\n            Mode::Normal,\n        );\n    }\n\n    #[gpui::test]\n    async fn test_multicursor_paste(cx: &mut gpui::TestAppContext) {\n        let mut cx = VimTestContext::new(cx, true).await;\n\n        cx.update_global(|store: &mut SettingsStore, cx| {\n            store.update_user_settings::<VimSettings>(cx, |s| {\n                s.use_system_clipboard = Some(UseSystemClipboard::Never)\n            });\n        });\n\n        cx.set_state(\n            indoc! {\"\n               \u02c7fish one\n               fish two\n               fish red\n               fish blue\n                \"},\n            Mode::Normal,\n        );\n        cx.simulate_keystrokes(\"4 g l w escape d i w 0 shift-p\");\n        cx.assert_state();\n        cx.assert_state(\n            indoc! {\"\n               on\u02c7efish\u2022\n               tw\u02c7ofish\u2022\n               re\u02c7dfish\u2022\n               blu\u02c7efish\u2022\n                \"},\n<|editable_region_end|>\n            Mode::Normal,\n        );\n    }\n}\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -496,7 +496,7 @@\n #[gpui::test]\n fn test_toggle_adjacent_hunks(cx: &mut TestAppContext) {\n     let base_text = \"b\\n\";\n-    let \n+    let text = \"\\n\"\n }\n \n #[gpui::test]\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -495,7 +495,7 @@\n \n #[gpui::test]\n fn test_toggle_adjacent_hunks(cx: &mut TestAppContext) {\n-    let base_text = \"b\\n\";\n+    let base_text = \"b\\nc\\\";\n     let text = \"\\n\"\n }\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/multi_buffer/src/multi_buffer_tests.rs\n        multibuffer.collapse_diff_hunks(vec![Anchor::min()..Anchor::max()], cx);\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"\n            one\n            four\n            seven\n            \"\n        },\n    );\n\n    assert_eq!(\n<|editable_region_start|>\n        snapshot\n            .diff_hunk_before(Point::new(2, 0))\n            .map(|hunk| hunk.row_range.start.0..hunk.row_range.end.0),\n        Some(1..1),\n    );\n    assert_eq!(\n        snapshot\n            .diff_hunk_before(Point::new(4, 0))\n            .map(|hunk| hunk.row_range.start.0..hunk.row_range.end.0),\n        Some(2..2)\n    );\n}\n\n#[gpui::test]\nfn test_toggle_adjacent_hunks(cx: &mut TestAppContext) {\n    let base_text = \"b\\nc\\<|user_cursor_is_here|>\";\n    let text = \"\\n\"\n}\n\n#[gpui::test]\nfn test_editing_text_in_diff_hunks(cx: &mut TestAppContext) {\n    let base_text = \"one\\ntwo\\nfour\\nfive\\nsix\\nseven\\n\";\n    let text = \"one\\ntwo\\nTHREE\\nfour\\nfive\\nseven\\n\";\n    let buffer = cx.new(|cx| Buffer::local(text, cx));\n    let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(&base_text, &buffer, cx));\n    let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer.clone(), cx));\n\n    let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.add_change_set(change_set.clone(), cx);\n        (multibuffer.snapshot(cx), multibuffer.subscribe())\n    });\n\n    cx.executor().run_until_parked();\n    multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.set_all_diff_hunks_expanded(cx);\n<|editable_region_end|>\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"\n              one\n              two\n            + THREE\n              four\n              five\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/multi_buffer/src/multi_buffer_tests.rs\n        multibuffer.collapse_diff_hunks(vec![Anchor::min()..Anchor::max()], cx);\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"\n            one\n            four\n            seven\n            \"\n        },\n    );\n\n    assert_eq!(\n<|editable_region_start|>\n        snapshot\n            .diff_hunk_before(Point::new(2, 0))\n            .map(|hunk| hunk.row_range.start.0..hunk.row_range.end.0),\n        Some(1..1),\n    );\n    assert_eq!(\n        snapshot\n            .diff_hunk_before(Point::new(4, 0))\n            .map(|hunk| hunk.row_range.start.0..hunk.row_range.end.0),\n        Some(2..2)\n    );\n}\n\n#[gpui::test]\nfn test_toggle_adjacent_hunks(cx: &mut TestAppContext) {\n    let base_text = \"b\\nc\\nd\";\n    let text = \"\\n\";\n}\n\n#[gpui::test]\nfn test_editing_text_in_diff_hunks(cx: &mut TestAppContext) {\n    let base_text = \"one\\ntwo\\nfour\\nfive\\nsix\\nseven\\n\";\n    let text = \"one\\ntwo\\nTHREE\\nfour\\nfive\\nseven\\n\";\n    let buffer = cx.new(|cx| Buffer::local(text, cx));\n    let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(&base_text, &buffer, cx));\n    let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer.clone(), cx));\n\n    let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.add_change_set(change_set.clone(), cx);\n        (multibuffer.snapshot(cx), multibuffer.subscribe())\n    });\n\n    cx.executor().run_until_parked();\n    multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.set_all_diff_hunks_expanded(cx);\n<|editable_region_end|>\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"\n              one\n              two\n            + THREE\n              four\n              five\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"apps/daos.fun/src/page-components/Raise/NFTSpot/SignWallet/mount.tsx\":\n```diff\n@@ -61,9 +61,10 @@\n           dao_mint,\n           invite_id,\n           linked_wallet: wallet.publicKey.toBase58(),\n+          delegate_wallet,\n           signature,\n           token: token as string,\n-          snapshot_id: snapshot_id,\n+          snapshot_id,\n         });\n \n         if (!res.ok) {\n\n```\n\nUser edited \"apps/daos.fun/src/page-components/Raise/NFTSpot/SignWallet/mount.tsx\":\n```diff\n@@ -95,6 +95,7 @@\n       }\n     },\n     [\n+      \n       wallet,\n       user_id,\n       insert_nft_whitelist,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```apps/daos.fun/src/page-components/Raise/NFTSpot/SignWallet/mount.tsx\n        if (!formRef.current) return;\n        const formData = new FormData(formRef.current);\n        const token = formData.get(\"cf-turnstile-response\");\n\n        const res = await insert_nft_whitelist.mutateAsync({\n          dao_mint,\n          invite_id,\n          linked_wallet: wallet.publicKey.toBase58(),\n          delegate_wallet,\n          signature,\n          token: token as string,\n          snapshot_id,\n        });\n\n        if (!res.ok) {\n          on_close?.();\n          return set_toast({\n<|editable_region_start|>\n            title: \"Invite error\",\n            // @ts-ignore\n            subtitle: res.error,\n          });\n        }\n\n        set_toast({\n          title: \"Welcome to the Party Round!\",\n          subtitle: \"You have been approved\",\n        });\n        on_close?.();\n        // remove invite query params from url\n        window.history.replaceState({}, \"\", window.location.pathname);\n        // refresh party round\n        approved.refetch();\n      } catch (err) {\n        console.debug({ err });\n        set_toast({\n          title: \"Invite error\",\n          // @ts-ignore\n          subtitle: err,\n        });\n      }\n    },\n    [\n      <|user_cursor_is_here|>\n<|editable_region_end|>\n      wallet,\n      user_id,\n      insert_nft_whitelist,\n      on_close,\n      formRef,\n      approved,\n      set_toast,\n      dao_mint,\n      snapshot_id,\n    ]\n  );\n\n  return (\n    <form ref={formRef} onSubmit={on_submit}>\n      <SignWallet\n        on_close={on_close}\n        user={user}\n        user_wallet_base58={wallet?.publicKey?.toBase58() ?? \"\"}\n      />\n    </form>\n  );\n};\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```apps/daos.fun/src/page-components/Raise/NFTSpot/SignWallet/mount.tsx\n        if (!formRef.current) return;\n        const formData = new FormData(formRef.current);\n        const token = formData.get(\"cf-turnstile-response\");\n\n        const res = await insert_nft_whitelist.mutateAsync({\n          dao_mint,\n          invite_id,\n          linked_wallet: wallet.publicKey.toBase58(),\n          delegate_wallet,\n          signature,\n          token: token as string,\n          snapshot_id,\n        });\n\n        if (!res.ok) {\n          on_close?.();\n          return set_toast({\n<|editable_region_start|>\n            title: \"Invite error\",\n            // @ts-ignore\n            subtitle: res.error,\n          });\n        }\n\n        set_toast({\n          title: \"Welcome to the Party Round!\",\n          subtitle: \"You have been approved\",\n        });\n        on_close?.();\n        // remove invite query params from url\n        window.history.replaceState({}, \"\", window.location.pathname);\n        // refresh party round\n        approved.refetch();\n      } catch (err) {\n        console.debug({ err });\n        set_toast({\n          title: \"Invite error\",\n          // @ts-ignore\n          subtitle: err,\n        });\n      }\n    },\n    [\n      delegate_wallet,\n<|editable_region_end|>\n      wallet,\n      user_id,\n      insert_nft_whitelist,\n      on_close,\n      formRef,\n      approved,\n      set_toast,\n      dao_mint,\n      snapshot_id,\n    ]\n  );\n\n  return (\n    <form ref={formRef} onSubmit={on_submit}>\n      <SignWallet\n        on_close={on_close}\n        user={user}\n        user_wallet_base58={wallet?.publicKey?.toBase58() ?? \"\"}\n      />\n    </form>\n  );\n};\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zed/src/main.rs\":\n```diff\n@@ -569,6 +569,7 @@\n         let urls: Vec<_> = args\n             .paths_or_urls\n             .iter()\n+            \n             .filter_map(|arg| parse_url_arg(arg, cx).log_err())\n             .collect();\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/zed/src/main.rs\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"theme\",\n            value = cx.theme().name.to_string()\n        );\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"keymap\",\n            value = BaseKeymap::get_global(cx).to_string()\n<|editable_region_start|>\n        );\n        telemetry.flush_events();\n\n        let fs = app_state.fs.clone();\n        load_user_themes_in_background(fs.clone(), cx);\n        watch_themes(fs.clone(), cx);\n        watch_languages(fs.clone(), app_state.languages.clone(), cx);\n        watch_file_types(fs.clone(), cx);\n\n        cx.set_menus(app_menus());\n        initialize_workspace(app_state.clone(), prompt_builder, cx);\n\n        cx.activate(true);\n\n        cx.spawn({\n            let client = app_state.client.clone();\n            |cx| async move { authenticate(client, &cx).await }\n        })\n        .detach_and_log_err(cx);\n\n        let args = Args::parse();\n        let urls: Vec<_> = args\n            .paths_or_urls\n            .iter()\n            <|user_cursor_is_here|>\n            .filter_map(|arg| parse_url_arg(arg, cx).log_err())\n            .collect();\n\n        if !urls.is_empty() {\n            open_listener.open_urls(urls)\n        }\n\n        match open_rx\n            .try_next()\n            .ok()\n            .flatten()\n            .and_then(|urls| OpenRequest::parse(urls, cx).log_err())\n        {\n            Some(request) => {\n                handle_open_request(request, app_state.clone(), cx);\n            }\n            None => {\n                cx.spawn({\n                    let app_state = app_state.clone();\n                    |mut cx| async move {\n                        if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                            fail_to_open_window_async(e, &mut cx)\n                        }\n                    }\n                })\n                .detach();\n            }\n        }\n\n        let app_state = app_state.clone();\n        cx.spawn(move |cx| async move {\n<|editable_region_end|>\n            while let Some(urls) = open_rx.next().await {\n                cx.update(|cx| {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/zed/src/main.rs\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"theme\",\n            value = cx.theme().name.to_string()\n        );\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"keymap\",\n            value = BaseKeymap::get_global(cx).to_string()\n<|editable_region_start|>\n        );\n        telemetry.flush_events();\n\n        let fs = app_state.fs.clone();\n        load_user_themes_in_background(fs.clone(), cx);\n        watch_themes(fs.clone(), cx);\n        watch_languages(fs.clone(), app_state.languages.clone(), cx);\n        watch_file_types(fs.clone(), cx);\n\n        cx.set_menus(app_menus());\n        initialize_workspace(app_state.clone(), prompt_builder, cx);\n\n        cx.activate(true);\n\n        cx.spawn({\n            let client = app_state.client.clone();\n            |cx| async move { authenticate(client, &cx).await }\n        })\n        .detach_and_log_err(cx);\n\n        let args = Args::parse();\n        let urls: Vec<_> = args\n            .paths_or_urls\n            .iter()\n            .cloned()\n            .filter_map(|arg| parse_url_arg(arg, cx).log_err())\n            .collect();\n\n        if !urls.is_empty() {\n            open_listener.open_urls(urls)\n        }\n\n        match open_rx\n            .try_next()\n            .ok()\n            .flatten()\n            .and_then(|urls| OpenRequest::parse(urls, cx).log_err())\n        {\n            Some(request) => {\n                handle_open_request(request, app_state.clone(), cx);\n            }\n            None => {\n                cx.spawn({\n                    let app_state = app_state.clone();\n                    |mut cx| async move {\n                        if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                            fail_to_open_window_async(e, &mut cx)\n                        }\n                    }\n                })\n                .detach();\n            }\n        }\n\n        let app_state = app_state.clone();\n        cx.spawn(move |cx| async move {\n<|editable_region_end|>\n            while let Some(urls) = open_rx.next().await {\n                cx.update(|cx| {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -74,6 +74,7 @@\n     align-items: center; */\n }\n \n+nav\n .navbar {\n     /* content-align: center; */\n     /* align-items: center; */\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\nh2 {\n    text-align: center;\n    padding: 10px;\n    color: black;\n    font-weight: bolder;\n    outline: 10px dotted blueviolet;\n    text-align: center;\n    color: brown;\n<|editable_region_start|>\n    line-height: 2;\n}\n\nh3 {\n    font-family: cursive;\n    font-weight: 400;\n}\n\nbr {\n    line-height: 90px;\n}\n\ndiv {\n    background: scroll;\n    background-size: cover;\n    /* background-repeat: no-repeat; */\n    background-attachment: fixed;\n    text-align: center;\n    /* display: flex; */\n    /* justify-content: center;\n    align-items: center; */\n}\n\nnav\n<|user_cursor_is_here|>.navbar {\n    /* content-align: center; */\n    /* align-items: center; */\n    /* justify-content: center; */\n    display: center, flex;\n    font-size: large;\n    font-weight: 1000;\n    font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;\n    text-decoration-color: whitesmoke;\n    text-shadow: 0cqmax;\n}\n\n/* select,\noption,\noptgroup,\npre,\nselect,\ntextarea\ntextarea-color {\n    color: blanchedalmond;\n    width: 100%;\n    color: #ff0000;\n    color: blanchedalmond;\n    width: 100%;\n<|editable_region_end|>\n    } */\n\n\n@media screen and (max-width: 780px) {\n\n    img,\n    main,\n    nav {\n        display: block;\n        display: float;\n```"}, {"role": "assistant", "content": "Suggestion:\n```\nh2 {\n    text-align: center;\n    padding: 10px;\n    color: black;\n    font-weight: bolder;\n    outline: 10px dotted blueviolet;\n    text-align: center;\n    color: brown;\n<|editable_region_start|>\n    line-height: 2;\n}\n\nh3 {\n    font-family: cursive;\n    font-weight: 400;\n}\n\nbr {\n    line-height: 90px;\n}\n\ndiv {\n    background: scroll;\n    background-size: cover;\n    /* background-repeat: no-repeat; */\n    background-attachment: fixed;\n    text-align: center;\n    /* display: flex; */\n    /* justify-content: center;\n    align-items: center; */\n}\n\nnav,\n.navbar {\n    /* content-align: center; */\n    /* align-items: center; */\n    /* justify-content: center; */\n    display: center, flex;\n    font-size: large;\n    font-weight: 1000;\n    font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;\n    text-decoration-color: whitesmoke;\n    text-shadow: 0cqmax;\n}\n\n/* select,\noption,\noptgroup,\npre,\nselect,\ntextarea\ntextarea-color {\n    color: blanchedalmond;\n    width: 100%;\n    color: #ff0000;\n    color: blanchedalmond;\n    width: 100%;\n<|editable_region_end|>\n    } */\n\n\n@media screen and (max-width: 780px) {\n\n    img,\n    main,\n    nav {\n        display: block;\n        display: float;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"config/initializers/pay.rb\":\n```diff\n@@ -6,6 +6,8 @@\n   config.support_email = \"support@nologox.com\"\n \n   config.send_emails = true\n+  \n+  \n \n   config.default_product_name = \"default\"\n   config.default_plan_name = \"default\"\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```config/initializers/pay.rb\n<|start_of_file|>\nPay.setup do |config|\n  # For use in the receipt/refund/renewal mailers\n  config.business_name = \"No Logo Media Limited\"\n  config.business_address = \"11 Erngath Road, Bo'Ness, Scotland, EH51 9DP\"\n  config.application_name = \"No Logo X\"\n  config.support_email = \"support@nologox.com\"\n\n  config.send_emails = true\n  \n<|editable_region_start|>\n  <|user_cursor_is_here|>\n\n  config.default_product_name = \"default\"\n  config.default_plan_name = \"default\"\n\n  config.automount_routes = true\n<|editable_region_end|>\n  config.routes_path = \"/payments\" # Only when automount_routes is true\nend\n\n# Pay::Webhooks.delegator.subscribe \"stripe.invoice.paid\", InvoicePaid.new\n# Pay::Webhooks.delegator.subscribe \"stripe.invoice.payment_succeeded\", InvoicePaid.new\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```config/initializers/pay.rb\n<|start_of_file|>\nPay.setup do |config|\n  # For use in the receipt/refund/renewal mailers\n  config.business_name = \"No Logo Media Limited\"\n  config.business_address = \"11 Erngath Road, Bo'Ness, Scotland, EH51 9DP\"\n  config.application_name = \"No Logo X\"\n  config.support_email = \"support@nologox.com\"\n\n  config.send_emails = true\n  \n<|editable_region_start|>\n  config.automatic_tax = true\n\n  config.default_product_name = \"default\"\n  config.default_plan_name = \"default\"\n\n  config.automount_routes = true\n<|editable_region_end|>\n  config.routes_path = \"/payments\" # Only when automount_routes is true\nend\n\n# Pay::Webhooks.delegator.subscribe \"stripe.invoice.paid\", InvoicePaid.new\n# Pay::Webhooks.delegator.subscribe \"stripe.invoice.payment_succeeded\", InvoicePaid.new\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"packages/server/src/nft/index.ts\":\n```diff\n@@ -152,35 +152,6 @@\n       }\n     }),\n \n-  check_wallet_in_snapshot_id: baseProcedure\n-    .input(\n-      z.object({\n-        snapshot_id: z.number(),\n-      })\n-    )\n-    .query(async ({ input }) => {\n-      const twitter_authed = await verify_twitter();\n-      if (!twitter_authed) throw new Error(\"No Twitter account\");\n-\n-      try {\n-        const result = await db.sql<\n-          s.nft_snapshot_user.SQL,\n-          { total_nft_count: number }[]\n-        >`\n-              SELECT COALESCE(SUM(nsu.nft_count), 0) as total_nft_count\n-              FROM linked_wallets lw\n-              JOIN nft_snapshot_user nsu\n-                ON nsu.user_address = lw.wallet_base58\n-              WHERE lw.user_id = ${db.param(twitter_authed.user_id)}\n-                AND nsu.nft_snapshot_id = ${db.param(input.snapshot_id)}\n-            `.run(pool);\n-\n-        return result[0]?.total_nft_count ?? 0;\n-      } catch (e) {\n-        console.error(e);\n-        return 0;\n-      }\n-    }),\n \n   get_snapshots: baseProcedure\n     .input(\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```packages/server/src/nft/index.ts\n      z.object({\n        dao_mint: z.string(),\n        snapshot_id: z.number(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const existing = await db\n        .select(\"nft_snapshot\", {\n          dao_mint: input.dao_mint,\n          id: input.snapshot_id,\n        })\n        .run(pool);\n\n      if (!existing.length) {\n        throw new Error(\"Snapshot not found for this DAO\");\n      }\n\n      try {\n        const updated = await db.sql`\n          UPDATE nft_snapshot\n          SET revoked = true\n          WHERE id = ${db.param(input.snapshot_id)}\n        `.run(pool);\n\n        return updated;\n      } catch (error) {\n<|editable_region_start|>\n        console.error(\"Error revoking snapshot:\", error);\n        throw new Error(\n          error instanceof Error ? error.message : \"Failed to revoke snapshot\"\n        );\n      }\n    }),\n\n<|user_cursor_is_here|>\n  get_snapshots: baseProcedure\n    .input(\n      z.object({\n        dao_mint: z.string(),\n      })\n    )\n    .query(async ({ input }) => {\n      try {\n        const snapshots = await db.sql<\n          s.nft_snapshot.SQL,\n          (SelectableForTable<\"nft_snapshot\"> & {\n            wallets_count: number;\n          })[]\n<|editable_region_end|>\n        >`\n        SELECT\n          s.*,\n          COUNT(DISTINCT u.user_address) as wallets_count\n        FROM nft_snapshot s\n        LEFT JOIN nft_snapshot_user u ON s.id = u.nft_snapshot_id\n        WHERE s.dao_mint = ${db.param(input.dao_mint)}\n        AND s.revoked = false\n        GROUP BY s.id\n      `.run(pool);\n\n        return snapshots;\n      } catch (e) {\n        console.error(e);\n        return [];\n      }\n    }),\n\n  link_new_wallet: baseProcedure\n    .input(\n```"}, {"role": "assistant", "content": "Suggestion:\n```packages/server/src/nft/index.ts\n      z.object({\n        dao_mint: z.string(),\n        snapshot_id: z.number(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const existing = await db\n        .select(\"nft_snapshot\", {\n          dao_mint: input.dao_mint,\n          id: input.snapshot_id,\n        })\n        .run(pool);\n\n      if (!existing.length) {\n        throw new Error(\"Snapshot not found for this DAO\");\n      }\n\n      try {\n        const updated = await db.sql`\n          UPDATE nft_snapshot\n          SET revoked = true\n          WHERE id = ${db.param(input.snapshot_id)}\n        `.run(pool);\n\n        return updated;\n      } catch (error) {\n<|editable_region_start|>\n        console.error(\"Error revoking snapshot:\", error);\n        throw new Error(\n          error instanceof Error ? error.message : \"Failed to revoke snapshot\"\n        );\n      }\n    }),\n\n  get_snapshots: baseProcedure\n    .input(\n      z.object({\n        dao_mint: z.string(),\n      })\n    )\n    .query(async ({ input }) => {\n      try {\n        const snapshots = await db.sql<\n          s.nft_snapshot.SQL,\n          (SelectableForTable<\"nft_snapshot\"> & {\n            wallets_count: number;\n          })[]\n<|editable_region_end|>\n        >`\n        SELECT\n          s.*,\n          COUNT(DISTINCT u.user_address) as wallets_count\n        FROM nft_snapshot s\n        LEFT JOIN nft_snapshot_user u ON s.id = u.nft_snapshot_id\n        WHERE s.dao_mint = ${db.param(input.dao_mint)}\n        AND s.revoked = false\n        GROUP BY s.id\n      `.run(pool);\n\n        return snapshots;\n      } catch (e) {\n        console.error(e);\n        return [];\n      }\n    }),\n\n  link_new_wallet: baseProcedure\n    .input(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/lib/components/ui/PromptBox.svelte\":\n```diff\n@@ -9,7 +9,10 @@\n \t// Utils\n \n \t// Props\n-\tconst {}: {} = $props()\n+\tconst {\n+\t\n+\t\n+\t}: {} = $props()\n </script>\n \n <form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\n```\n\n\n\nUser edited \"src/lib/components/ui/PromptBox.svelte\":\n```diff\n@@ -12,6 +12,7 @@\n \tconst {\n \t\n \t\n+\t\n \t}: {} = $props()\n </script>\n \n\n```\n\nUser edited \"src/lib/components/ui/PromptBox.svelte\":\n```diff\n@@ -10,10 +10,12 @@\n \n \t// Props\n \tconst {\n-\t\n-\t\n-\t\n-\t}: {} = $props()\n+\t\tchanges,\n+\t\tsubmitting\n+\t}: {\n+\t\tchanges: string;\n+\t\tsubmitting: boolean;\n+\t} = $props()\n </script>\n \n <form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\n```\n\nUser edited \"src/lib/components/ui/PromptBox.svelte\":\n```diff\n@@ -10,12 +10,10 @@\n \n \t// Props\n \tconst {\n-\t\tchanges,\n-\t\tsubmitting\n-\t}: {\n-\t\tchanges: string;\n-\t\tsubmitting: boolean;\n-\t} = $props()\n+\t\n+\t\n+\t\n+\t}: {} = $props()\n </script>\n \n <form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\n```\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -54,6 +54,8 @@\n \t\t\t\t>Adjust</Button\n \t\t\t>\n \t\t</form>\n+\t\t\n+\t\t\n \t{/snippet}\n \n \t<div class=\"w-full h-full grid place-items-center\">\n\n```\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -55,7 +55,7 @@\n \t\t\t>\n \t\t</form>\n \t\t\n-\t\t\n+\t\t<PromptBox>\n \t{/snippet}\n \n \t<div class=\"w-full h-full grid place-items-center\">\n\n```\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -55,7 +55,7 @@\n \t\t\t>\n \t\t</form>\n \t\t\n-\t\t<PromptBox>\n+\t\t<PromptBox />\n \t{/snippet}\n \n \t<div class=\"w-full h-full grid place-items-center\">\n\n```\n\n\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -54,7 +54,7 @@\n \t\t\t\t>Adjust</Button\n \t\t\t>\n \t\t</form>\n-\t\t\n+\n \t\t<PromptBox />\n \t{/snippet}\n \n\n```\n\nUser edited \"src/lib/components/ui/PromptBox.svelte\":\n```diff\n@@ -9,11 +9,7 @@\n \t// Utils\n \n \t// Props\n-\tconst {\n-\t\n-\t\n-\t\n-\t}: {} = $props()\n+\tconst {}: {} = $props()\n </script>\n \n <form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\n```\n\n\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -14,6 +14,7 @@\n \timport { zodClient } from 'sveltekit-superforms/adapters'\n \timport { inputSchema } from '../brand/schema'\n \timport { page } from '$app/state'\n+\timport PromptBox from '$components/ui/PromptBox.svelte'\n \n \t// Props\n \tconst { data }: PageProps = $props()\n\n```\n\nUser edited \"src/routes/(app)/[company_handle]/website/+page.svelte\":\n```diff\n@@ -56,7 +56,7 @@\n \t\t\t>\n \t\t</form>\n \n-\t\t<PromptBox />\n+\t\t<PromptBox {superFo/>\n \t{/snippet}\n \n \t<div class=\"w-full h-full grid place-items-center\">\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/routes/(app)/[company_handle]/website/+page.svelte\n\timport { browser } from '$app/environment'\n\timport { superForm } from 'sveltekit-superforms'\n\timport { zodClient } from 'sveltekit-superforms/adapters'\n\timport { inputSchema } from '../brand/schema'\n\timport { page } from '$app/state'\n\timport PromptBox from '$components/ui/PromptBox.svelte'\n\n\t// Props\n\tconst { data }: PageProps = $props()\n\n\tlet previewUrl = $derived(page.url.pathname + '/preview')\n\n\tasync function getPreviewUrl() {\n\t\tconst response = await fetch(previewUrl)\n\t\tconst url = response.url // get the final URL after any redirects\n\t\treturn url\n\t}\n\n\tconst superform = superForm(data.form, {\n\t\tvalidators: zodClient(inputSchema)\n\t})\n\n\tconst { submitting, enhance } = superform\n</script>\n\n<|editable_region_start|>\n<Canvas {data} --name=\"canvas-website\">\n\t{#snippet controls()}\n\t\t<form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\t\t\t<Field form={superform} name=\"changes\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\tclass=\"form-textarea grid-center shadow-xl ring-1 !pb-20 resize-none !bg-gray-100 !rounded-2xl\"\n\t\t\t\t\t\t\tplaceholder=\"Describe changes\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</textarea>\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<FieldErrors />\n\t\t\t</Field>\n\n\t\t\t<Button type=\"submit\" loading={$submitting} class=\"grid-center place-self-end m-2\"\n\t\t\t\t>Adjust</Button\n\t\t\t>\n\t\t</form>\n\n\t\t<PromptBox {superFo<|user_cursor_is_here|>/>\n\t{/snippet}\n\n\t<div class=\"w-full h-full grid place-items-center\">\n\t\t{#await getPreviewUrl()}\n\t\t\t<div class=\"grid grid-flow-col gap-3 place-items-center\">\n\t\t\t\t<Loader />\n\t\t\t\tStarting development environment\n\t\t\t</div>\n\t\t{:then previewUrl}\n\t\t\t<iframe class=\"w-full h-full overflow-scroll\" src={previewUrl} frameborder=\"0\"></iframe>\n<|editable_region_end|>\n\t\t{:catch}\n\t\t\t<p class=\"text-emphasis-medium\">\n\t\t\t\tFailed to load preview URL. Please try again or contact support if the issue persists.\n\t\t\t</p>\n\t\t{/await}\n\t</div>\n</Canvas>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/routes/(app)/[company_handle]/website/+page.svelte\n\timport { browser } from '$app/environment'\n\timport { superForm } from 'sveltekit-superforms'\n\timport { zodClient } from 'sveltekit-superforms/adapters'\n\timport { inputSchema } from '../brand/schema'\n\timport { page } from '$app/state'\n\timport PromptBox from '$components/ui/PromptBox.svelte'\n\n\t// Props\n\tconst { data }: PageProps = $props()\n\n\tlet previewUrl = $derived(page.url.pathname + '/preview')\n\n\tasync function getPreviewUrl() {\n\t\tconst response = await fetch(previewUrl)\n\t\tconst url = response.url // get the final URL after any redirects\n\t\treturn url\n\t}\n\n\tconst superform = superForm(data.form, {\n\t\tvalidators: zodClient(inputSchema)\n\t})\n\n\tconst { submitting, enhance } = superform\n</script>\n\n<|editable_region_start|>\n<Canvas {data} --name=\"canvas-website\">\n\t{#snippet controls()}\n\t\t<form use:enhance method=\"POST\" action=\"?\" class=\"grid w-full\">\n\t\t\t<Field form={superform} name=\"changes\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\tclass=\"form-textarea grid-center shadow-xl ring-1 !pb-20 resize-none !bg-gray-100 !rounded-2xl\"\n\t\t\t\t\t\t\tplaceholder=\"Describe changes\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t</textarea>\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<FieldErrors />\n\t\t\t</Field>\n\n\t\t\t<Button type=\"submit\" loading={$submitting} class=\"grid-center place-self-end m-2\"\n\t\t\t\t>Adjust</Button\n\t\t\t>\n\t\t</form>\n\n\t\t<PromptBox {superform} />\n\t{/snippet}\n\n\t<div class=\"w-full h-full grid place-items-center\">\n\t\t{#await getPreviewUrl()}\n\t\t\t<div class=\"grid grid-flow-col gap-3 place-items-center\">\n\t\t\t\t<Loader />\n\t\t\t\tStarting development environment\n\t\t\t</div>\n\t\t{:then previewUrl}\n\t\t\t<iframe class=\"w-full h-full overflow-scroll\" src={previewUrl} frameborder=\"0\"></iframe>\n<|editable_region_end|>\n\t\t{:catch}\n\t\t\t<p class=\"text-emphasis-medium\">\n\t\t\t\tFailed to load preview URL. Please try again or contact support if the issue persists.\n\t\t\t</p>\n\t\t{/await}\n\t</div>\n</Canvas>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -7977,7 +7977,7 @@\n                 if !selection.is_empty() && !line_mode {\n                     selection.goal = SelectionGoal::None;\n                 }\n-                let (cursor, gzoal) = movement::down_by_rows(\n+                let (cursor, gzzxoal) = movement::down_by_rows(\n                     map,\n                     selection.start,\n                     action.lines,\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -7977,7 +7977,7 @@\n                 if !selection.is_empty() && !line_mode {\n                     selection.goal = SelectionGoal::None;\n                 }\n-                let (cursor, gzzxoal) = movement::down_by_rows(\n+                let (cursor, goal) = movement::down_by_rows(\n                     map,\n                     selection.start,\n                     action.lines,\n\n```\n\nUser edited \"crates/editor/src/movement.rs\":\n```diff\n@@ -102,6 +102,7 @@\n     preserve_column_at_end: bool,\n     text_layout_details: &TextLayoutDetails,\n ) -> (DisplayPoint, SelectionGoal) {\n+    dbg!(start);\n     down_by_rows(\n         map,\n         start,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/movement.rs\n/// if that point is already at the end of line.\npub fn saturating_right(map: &DisplaySnapshot, mut point: DisplayPoint) -> DisplayPoint {\n    *point.column_mut() += 1;\n    map.clip_point(point, Bias::Right)\n}\n\n/// Returns a display point for the preceding displayed line (which might be a soft-wrapped line).\npub fn up(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    goal: SelectionGoal,\n    preserve_column_at_start: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    up_by_rows(\n        map,\n        start,\n        1,\n<|editable_region_start|>\n        goal,\n        preserve_column_at_start,\n        text_layout_details,\n    )\n}\n\n/// Returns a display point for the next displayed line (which might be a soft-wrapped line).\npub fn down(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    goal: SelectionGoal,\n    preserve_column_at_end: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    dbg!(start);\n    down_by_rows<|user_cursor_is_here|>(\n        map,\n        start,\n        1,\n        goal,\n        preserve_column_at_end,\n        text_layout_details,\n    )\n}\n\npub(crate) fn up_by_rows(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    row_count: u32,\n    goal: SelectionGoal,\n    preserve_column_at_start: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    let goal_x = match goal {\n        SelectionGoal::HorizontalPosition(x) => x.into(),\n<|editable_region_end|>\n        SelectionGoal::WrappedHorizontalPosition((_, x)) => x.into(),\n        SelectionGoal::HorizontalRange { end, .. } => end.into(),\n        _ => map.x_for_display_point(start, text_layout_details),\n    };\n\n    let prev_row = DisplayRow(start.row().0.saturating_sub(row_count));\n    let mut point = map.clip_point(\n        DisplayPoint::new(prev_row, map.line_len(prev_row)),\n        Bias::Left,\n    );\n    if point.row() < start.row() {\n        *point.column_mut() = map.display_column_for_x(point.row(), goal_x, text_layout_details)\n    } else if preserve_column_at_start {\n        return (start, goal);\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/movement.rs\n/// if that point is already at the end of line.\npub fn saturating_right(map: &DisplaySnapshot, mut point: DisplayPoint) -> DisplayPoint {\n    *point.column_mut() += 1;\n    map.clip_point(point, Bias::Right)\n}\n\n/// Returns a display point for the preceding displayed line (which might be a soft-wrapped line).\npub fn up(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    goal: SelectionGoal,\n    preserve_column_at_start: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    up_by_rows(\n        map,\n        start,\n        1,\n<|editable_region_start|>\n        goal,\n        preserve_column_at_start,\n        text_layout_details,\n    )\n}\n\n/// Returns a display point for the next displayed line (which might be a soft-wrapped line).\npub fn down(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    goal: SelectionGoal,\n    preserve_column_at_end: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    dbg!(start);\n    down_by_rows(\n        map,\n        start,\n        1,\n        goal,\n        preserve_column_at_end,\n        text_layout_details,\n    )\n}\n\npub(crate) fn up_by_rows(\n    map: &DisplaySnapshot,\n    start: DisplayPoint,\n    row_count: u32,\n    goal: SelectionGoal,\n    preserve_column_at_start: bool,\n    text_layout_details: &TextLayoutDetails,\n) -> (DisplayPoint, SelectionGoal) {\n    let goal_x = match goal {\n        SelectionGoal::HorizontalPosition(x) => x.into(),\n<|editable_region_end|>\n        SelectionGoal::WrappedHorizontalPosition((_, x)) => x.into(),\n        SelectionGoal::HorizontalRange { end, .. } => end.into(),\n        _ => map.x_for_display_point(start, text_layout_details),\n    };\n\n    let prev_row = DisplayRow(start.row().0.saturating_sub(row_count));\n    let mut point = map.clip_point(\n        DisplayPoint::new(prev_row, map.line_len(prev_row)),\n        Bias::Left,\n    );\n    if point.row() < start.row() {\n        *point.column_mut() = map.display_column_for_x(point.row(), goal_x, text_layout_details)\n    } else if preserve_column_at_start {\n        return (start, goal);\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -54,6 +54,7 @@\n     \"reveal\": \"always\",\n     \"hide\": \"never\",\n     \"shell\": {\n+      \n       \"program\": \"bun\",\n       \"args\": [\"run\", \"--watch\", \"$ZED_RELATIVE_FILE\"]\n     },\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n<|start_of_file|>\n// Static tasks configuration.\n<|editable_region_start|>\n[\n  // {\n  //   \"label\": \"Example task\",\n  //   \"command\": \"for i in {1..5}; do echo \\\"Hello $i/5\\\"; sleep 1; done\",\n  //   //\"args\": [],\n  //   // Env overrides for the command, will be appended to the terminal's environment from the settings.\n  //   \"env\": { \"foo\": \"bar\" },\n  //   // Current working directory to spawn the command into, defaults to current project root.\n  //   //\"cwd\": \"/path/to/working/directory\",\n  //   // Whether to use a new terminal tab or reuse the existing one to spawn the process, defaults to `false`.\n  //   \"use_new_terminal\": false,\n  //   // Whether to allow multiple instances of the same task to be run, or rather wait for the existing ones to finish, defaults to `false`.\n  //   \"allow_concurrent_runs\": false,\n  //   // What to do with the terminal pane and tab, after the command was started:\n  //   // * `always` \u2014 always show the task's pane, and focus the corresponding tab in it (default)\n  //   // * `no_focus` \u2014 always show the task's pane, add the task's tab in it, but don't focus it\n  //   // * `never` \u2014 do not alter focus, but still add/reuse the task's tab in its pane\n  //   \"reveal\": \"always\",\n  //   // Where to place the task's terminal item after starting the task:\n  //   // * `dock` \u2014 in the terminal dock, \"regular\" terminal items' place (default)\n  //   // * `center` \u2014 in the central pane group, \"main\" editor area\n  //   \"reveal_target\": \"dock\",\n  //   // What to do with the terminal pane and tab, after the command had finished:\n  //   // * `never` \u2014 Do nothing when the command finishes (default)\n  //   // * `always` \u2014 always hide the terminal tab, hide the pane also if it was the last tab in it\n  //   // * `on_success` \u2014 hide the terminal tab on task success only, otherwise behaves similar to `always`\n  //   \"hide\": \"never\",\n  //   // Which shell to use when running a task inside the terminal.\n  //   // May take 3 values:\n  //   // 1. (default) Use the system's default terminal configuration in /etc/passwd\n  //   //      \"shell\": \"system\"\n  //   // 2. A program:\n  //   //      \"shell\": {\n  //   //        \"program\": \"sh\"\n  //   //      }\n  //   // 3. A program with arguments:\n  //   //     \"shell\": {\n  //   //         \"with_arguments\": {\n  //   //           \"program\": \"/bin/bash\",\n  //   //           \"args\": [\"--login\"]\n  //   //         }\n  //   //     }\n  //   \"shell\": \"system\"\n  // },\n  {\n    \"label\": \"Bun run $ZED_RELATIVE_FILE (watch)\",\n    \"cwd\": \"$ZED_WORKTREE_ROOT\",\n    \"command\": \"bun run --watch \\\"$ZED_RELATIVE_FILE\\\"\",\n    \"tags\": [\"typescript-run\"],\n    \"env\": {},\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": true,\n    \"reveal\": \"always\",\n    \"hide\": \"never\",\n    \"shell\": {\n      <|user_cursor_is_here|>\n      \"program\": \"bun\",\n      \"args\": [\"run\", \"--watch\", \"$ZED_RELATIVE_FILE\"]\n<|editable_region_end|>\n    },\n    \"show_summary\": true,\n    \"show_output\": true\n  }\n]\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n<|start_of_file|>\n// Static tasks configuration.\n<|editable_region_start|>\n[\n  // {\n  //   \"label\": \"Example task\",\n  //   \"command\": \"for i in {1..5}; do echo \\\"Hello $i/5\\\"; sleep 1; done\",\n  //   //\"args\": [],\n  //   // Env overrides for the command, will be appended to the terminal's environment from the settings.\n  //   \"env\": { \"foo\": \"bar\" },\n  //   // Current working directory to spawn the command into, defaults to current project root.\n  //   //\"cwd\": \"/path/to/working/directory\",\n  //   // Whether to use a new terminal tab or reuse the existing one to spawn the process, defaults to `false`.\n  //   \"use_new_terminal\": false,\n  //   // Whether to allow multiple instances of the same task to be run, or rather wait for the existing ones to finish, defaults to `false`.\n  //   \"allow_concurrent_runs\": false,\n  //   // What to do with the terminal pane and tab, after the command was started:\n  //   // * `always` \u2014 always show the task's pane, and focus the corresponding tab in it (default)\n  //   // * `no_focus` \u2014 always show the task's pane, add the task's tab in it, but don't focus it\n  //   // * `never` \u2014 do not alter focus, but still add/reuse the task's tab in its pane\n  //   \"reveal\": \"always\",\n  //   // Where to place the task's terminal item after starting the task:\n  //   // * `dock` \u2014 in the terminal dock, \"regular\" terminal items' place (default)\n  //   // * `center` \u2014 in the central pane group, \"main\" editor area\n  //   \"reveal_target\": \"dock\",\n  //   // What to do with the terminal pane and tab, after the command had finished:\n  //   // * `never` \u2014 Do nothing when the command finishes (default)\n  //   // * `always` \u2014 always hide the terminal tab, hide the pane also if it was the last tab in it\n  //   // * `on_success` \u2014 hide the terminal tab on task success only, otherwise behaves similar to `always`\n  //   \"hide\": \"never\",\n  //   // Which shell to use when running a task inside the terminal.\n  //   // May take 3 values:\n  //   // 1. (default) Use the system's default terminal configuration in /etc/passwd\n  //   //      \"shell\": \"system\"\n  //   // 2. A program:\n  //   //      \"shell\": {\n  //   //        \"program\": \"sh\"\n  //   //      }\n  //   // 3. A program with arguments:\n  //   //     \"shell\": {\n  //   //         \"with_arguments\": {\n  //   //           \"program\": \"/bin/bash\",\n  //   //           \"args\": [\"--login\"]\n  //   //         }\n  //   //     }\n  //   \"shell\": \"system\"\n  // },\n  {\n    \"label\": \"Bun run $ZED_RELATIVE_FILE (watch)\",\n    \"cwd\": \"$ZED_WORKTREE_ROOT\",\n    \"command\": \"bun run --watch \\\"$ZED_RELATIVE_FILE\\\"\",\n    \"tags\": [\"typescript-run\"],\n    \"env\": {},\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": true,\n    \"reveal\": \"always\",\n    \"hide\": \"never\",\n    \"shell\": {\n      \"with_arguments\": {\n        \"program\": \"bun\",\n        \"args\": [\"run\", \"--watch\", \"$ZED_RELATIVE_FILE\"]\n      }\n<|editable_region_end|>\n    },\n    \"show_summary\": true,\n    \"show_output\": true\n  }\n]\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/bounds_tree.rs\":\n```diff\n@@ -6,6 +6,7 @@\n     roots: Vec<usize>,\n     /// The nodes of the tree.\n     nodes: Vec<Node<T>>,\n+    /// The stack of nodes to be processed.\n     stack: Vec<usize>,\n }\n \n\n```\n\nUser edited \"src/bounds_tree.rs\":\n```diff\n@@ -11,6 +11,7 @@\n }\n \n impl<T: Clone> BoundsTree<T> {\n+    /// Creates a new empty `BoundsTree`.\n     pub fn new() -> Self {\n         BoundsTree {\n             roots: Vec::new(),\n\n```\n\nUser edited \"src/bounds_tree.rs\":\n```diff\n@@ -20,6 +20,7 @@\n         }\n     }\n \n+    /\n     pub fn insert(&mut self, new_bounds: Bounds, data: T) -> Option<u32> {\n         // If the tree is empty, make the root the new leaf.\n         if self.roots.is_empty() {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```aabb/src/bounds_tree.rs\n<|start_of_file|>\nuse std::{cmp, fmt, iter};\n\n#[derive(Debug)]\npub struct BoundsTree<T> {\n    /// The root nodes of the tree.\n    roots: Vec<usize>,\n    /// The nodes of the tree.\n    nodes: Vec<Node<T>>,\n    /// The stack of nodes to be processed.\n    stack: Vec<usize>,\n}\n\nimpl<T: Clone> BoundsTree<T> {\n    /// Creates a new empty `BoundsTree`.\n    pub fn new() -> Self {\n<|editable_region_start|>\n        BoundsTree {\n            roots: Vec::new(),\n            nodes: Vec::new(),\n            stack: Vec::new(),\n        }\n    }\n\n    /<|user_cursor_is_here|>\n    pub fn insert(&mut self, new_bounds: Bounds, data: T) -> Option<u32> {\n        // If the tree is empty, make the root the new leaf.\n        if self.roots.is_empty() {\n            let new_node = self.push_leaf(new_bounds, data, 1);\n            self.roots.push(new_node);\n            return Some(new_node);\n        }\n\n        // Search for the best place to add the new leaf based on heuristics.\n        let mut max_intersecting_ordering = 0;\n        let mut index = self.roots[0];\n        while let Node::Internal {\n            left: left_index,\n            right: right_index,\n            bounds: node_bounds,\n            ..\n<|editable_region_end|>\n        } = self.node_mut(index)\n        {\n            let left = *left_index;\n            let right = *right_index;\n            *node_bounds = node_bounds.merge(new_bounds);\n            self.stack.push(index);\n\n            // Descend to the best-fit child, based on which one would increase\n            // the surface area the least. This attempts to keep the tree balanced\n            // in terms of surface area. If there is an intersection with the other child,\n            // add its keys to the intersections vector.\n            let left_cost = new_bounds.merge(self.node(left).bounds()).half_perimeter();\n            let right_cost = new_bounds.merge(self.node(right).bounds()).half_perimeter();\n            if left_cost < right_cost {\n                max_intersecting_ordering =\n                    self.collect_max_ordering(right, new_bounds, max_intersecting_ordering);\n                index = left;\n            } else {\n                max_intersecting_ordering =\n                    self.collect_max_ordering(left, new_bounds, max_intersecting_ordering);\n                index = right;\n            }\n        }\n\n        // We've found a leaf ('index' now refers to a leaf node).\n        // We'll insert a new parent node above the leaf and attach our new leaf to it.\n        let sibling = index;\n```"}, {"role": "assistant", "content": "Suggestion:\n```aabb/src/bounds_tree.rs\n<|start_of_file|>\nuse std::{cmp, fmt, iter};\n\n#[derive(Debug)]\npub struct BoundsTree<T> {\n    /// The root nodes of the tree.\n    roots: Vec<usize>,\n    /// The nodes of the tree.\n    nodes: Vec<Node<T>>,\n    /// The stack of nodes to be processed.\n    stack: Vec<usize>,\n}\n\nimpl<T: Clone> BoundsTree<T> {\n    /// Creates a new empty `BoundsTree`.\n    pub fn new() -> Self {\n<|editable_region_start|>\n        BoundsTree {\n            roots: Vec::new(),\n            nodes: Vec::new(),\n            stack: Vec::new(),\n        }\n    }\n\n    /// Inserts a new node into the tree.\n    pub fn insert(&mut self, new_bounds: Bounds, data: T) -> Option<u32> {\n        // If the tree is empty, make the root the new leaf.\n        if self.roots.is_empty() {\n            let new_node = self.push_leaf(new_bounds, data, 1);\n            self.roots.push(new_node);\n            return Some(new_node);\n        }\n\n        // Search for the best place to add the new leaf based on heuristics.\n        let mut max_intersecting_ordering = 0;\n        let mut index = self.roots[0];\n        while let Node::Internal {\n            left: left_index,\n            right: right_index,\n            bounds: node_bounds,\n            ..\n<|editable_region_end|>\n        } = self.node_mut(index)\n        {\n            let left = *left_index;\n            let right = *right_index;\n            *node_bounds = node_bounds.merge(new_bounds);\n            self.stack.push(index);\n\n            // Descend to the best-fit child, based on which one would increase\n            // the surface area the least. This attempts to keep the tree balanced\n            // in terms of surface area. If there is an intersection with the other child,\n            // add its keys to the intersections vector.\n            let left_cost = new_bounds.merge(self.node(left).bounds()).half_perimeter();\n            let right_cost = new_bounds.merge(self.node(right).bounds()).half_perimeter();\n            if left_cost < right_cost {\n                max_intersecting_ordering =\n                    self.collect_max_ordering(right, new_bounds, max_intersecting_ordering);\n                index = left;\n            } else {\n                max_intersecting_ordering =\n                    self.collect_max_ordering(left, new_bounds, max_intersecting_ordering);\n                index = right;\n            }\n        }\n\n        // We've found a leaf ('index' now refers to a leaf node).\n        // We'll insert a new parent node above the leaf and attach our new leaf to it.\n        let sibling = index;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -167,7 +167,7 @@\n \n impl LocalLspStore {\n     fn langage_server_for_id(&self, id: LanguageServerId) -> Option<LanguageServer> {\n-        self.language_servers.get()\n+        self.language_servers.get(&id)\n     }\n     \n     \n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -167,7 +167,7 @@\n \n impl LocalLspStore {\n     fn langage_server_for_id(&self, id: LanguageServerId) -> Option<LanguageServer> {\n-        self.language_servers.get(&id)\n+        let Some(language_serverself.language_servers.get(&id)\n     }\n     \n     \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/project/src/lsp_store.rs\n    languages: Arc<LanguageRegistry>,\n    language_server_ids: HashMap<(WorktreeId, LanguageServerName), LanguageServerId>,\n    yarn: Entity<YarnPathStore>,\n    pub language_servers: HashMap<LanguageServerId, LanguageServerState>,\n    buffers_being_formatted: HashSet<BufferId>,\n    last_workspace_edits_by_language_server: HashMap<LanguageServerId, ProjectTransaction>,\n    language_server_watched_paths: HashMap<LanguageServerId, LanguageServerWatchedPaths>,\n    language_server_paths_watched_for_rename:\n        HashMap<LanguageServerId, RenamePathsWatchedForServer>,\n    language_server_watcher_registrations:\n        HashMap<LanguageServerId, HashMap<String, Vec<FileSystemWatcher>>>,\n    supplementary_language_servers:\n        HashMap<LanguageServerId, (LanguageServerName, Arc<LanguageServer>)>,\n    prettier_store: Entity<PrettierStore>,\n    current_lsp_settings: HashMap<LanguageServerName, LspSettings>,\n    next_diagnostic_group_id: usize,\n    diagnostics: HashMap<\n        WorktreeId,\n        HashMap<\n            Arc<Path>,\n            Vec<(\n                LanguageServerId,\n                Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n            )>,\n        >,\n    >,\n    buffer_snapshots: HashMap<BufferId, HashMap<LanguageServerId, Vec<LspBufferSnapshot>>>, // buffer_id -> server_id -> vec of snapshots\n    _subscription: gpui::Subscription,\n    registered_buffers: HashMap<BufferId, usize>,\n}\n<|editable_region_start|>\n\nimpl LocalLspStore {\n    fn langage_server_for_id(&self, id: LanguageServerId) -> Option<LanguageServer> {\n        let Some(language_server<|user_cursor_is_here|>self.language_servers.get(&id)\n    }\n    \n    \n    fn start_language_server(\n        &mut self,\n        worktree_handle: &Entity<Worktree>,\n        delegate: Arc<LocalLspAdapterDelegate>,\n        adapter: Arc<CachedLspAdapter>,\n<|editable_region_end|>\n        cx: &mut Context<LspStore>,\n    ) {\n        let worktree = worktree_handle.read(cx);\n        let worktree_id = worktree.id();\n        let root_path = worktree.abs_path();\n        let key = (worktree_id, adapter.name.clone());\n\n        if self.language_server_ids.contains_key(&key) {\n            return;\n        }\n\n        let project_settings = ProjectSettings::get(\n            Some(SettingsLocation {\n                worktree_id,\n                path: Path::new(\"\"),\n            }),\n            cx,\n        );\n        let lsp = project_settings.lsp.get(&adapter.name);\n        let override_options = lsp.and_then(|s| s.initialization_options.clone());\n\n        let stderr_capture = Arc::new(Mutex::new(Some(String::new())));\n\n        let server_id = self.languages.next_language_server_id();\n        log::info!(\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/project/src/lsp_store.rs\n    languages: Arc<LanguageRegistry>,\n    language_server_ids: HashMap<(WorktreeId, LanguageServerName), LanguageServerId>,\n    yarn: Entity<YarnPathStore>,\n    pub language_servers: HashMap<LanguageServerId, LanguageServerState>,\n    buffers_being_formatted: HashSet<BufferId>,\n    last_workspace_edits_by_language_server: HashMap<LanguageServerId, ProjectTransaction>,\n    language_server_watched_paths: HashMap<LanguageServerId, LanguageServerWatchedPaths>,\n    language_server_paths_watched_for_rename:\n        HashMap<LanguageServerId, RenamePathsWatchedForServer>,\n    language_server_watcher_registrations:\n        HashMap<LanguageServerId, HashMap<String, Vec<FileSystemWatcher>>>,\n    supplementary_language_servers:\n        HashMap<LanguageServerId, (LanguageServerName, Arc<LanguageServer>)>,\n    prettier_store: Entity<PrettierStore>,\n    current_lsp_settings: HashMap<LanguageServerName, LspSettings>,\n    next_diagnostic_group_id: usize,\n    diagnostics: HashMap<\n        WorktreeId,\n        HashMap<\n            Arc<Path>,\n            Vec<(\n                LanguageServerId,\n                Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n            )>,\n        >,\n    >,\n    buffer_snapshots: HashMap<BufferId, HashMap<LanguageServerId, Vec<LspBufferSnapshot>>>, // buffer_id -> server_id -> vec of snapshots\n    _subscription: gpui::Subscription,\n    registered_buffers: HashMap<BufferId, usize>,\n}\n<|editable_region_start|>\n\nimpl LocalLspStore {\n    fn language_server_for_id(&self, id: LanguageServerId) -> Option<LanguageServer> {\n        let Some(language_server) = self.language_servers.get(&id) else {\n          return None\n        };\n        Some(language_server.clone())\n    }\n    \n    \n    fn start_language_server(\n        &mut self,\n        worktree_handle: &Entity<Worktree>,\n        delegate: Arc<LocalLspAdapterDelegate>,\n        adapter: Arc<CachedLspAdapter>,\n<|editable_region_end|>\n        cx: &mut Context<LspStore>,\n    ) {\n        let worktree = worktree_handle.read(cx);\n        let worktree_id = worktree.id();\n        let root_path = worktree.abs_path();\n        let key = (worktree_id, adapter.name.clone());\n\n        if self.language_server_ids.contains_key(&key) {\n            return;\n        }\n\n        let project_settings = ProjectSettings::get(\n            Some(SettingsLocation {\n                worktree_id,\n                path: Path::new(\"\"),\n            }),\n            cx,\n        );\n        let lsp = project_settings.lsp.get(&adapter.name);\n        let override_options = lsp.and_then(|s| s.initialization_options.clone());\n\n        let stderr_capture = Arc::new(Mutex::new(Some(String::new())));\n\n        let server_id = self.languages.next_language_server_id();\n        log::info!(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"packages/jobs/src/client.ts\":\n```diff\n@@ -105,6 +105,8 @@\n         jobConfig,\n       } as Worker<Schema, Type>);\n   }\n+  \n+  private \n \n   private async assertConnectionToChannel() {\n     if (!this.connection) {\n\n```\n\nUser edited \"packages/jobs/src/client.ts\":\n```diff\n@@ -106,7 +106,7 @@\n       } as Worker<Schema, Type>);\n   }\n   \n-  private \n+  private async \n \n   private async assertConnectionToChannel() {\n     if (!this.connection) {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```packages/jobs/src/client.ts\n      return () =>\n        ({\n          jobConfig,\n          startTask: async (taskPayload: z.infer<Schema>) => {\n            if (!payload) {\n              throw new Error(\"Payload schema is required for event workers\");\n            }\n\n            // This will throw before sending if the payload is bad\n            payload.parse(taskPayload);\n\n            await this.assertConnectionToChannel();\n\n            const stringifiedPayload = JSON.stringify(taskPayload);\n\n            this.channel?.assertQueue(name, {\n              durable: true,\n            });\n\n            this.channel?.sendToQueue(name, Buffer.from(stringifiedPayload), {\n              persistent: true,\n              ...options.publishOptions,\n            });\n          },\n        } as Worker<Schema, Type>);\n    }\n\n    return () =>\n      ({\n        jobConfig,\n      } as Worker<Schema, Type>);\n  }\n<|editable_region_start|>\n  \n  private async <|user_cursor_is_here|>\n\n  private async assertConnectionToChannel() {\n    if (!this.connection) {\n      this.connection = await amqp.connect(this.url);\n    }\n<|editable_region_end|>\n\n    if (!this.channel) {\n      this.channel = await this.connection.createChannel();\n    }\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: Doesn't matter at this point, its schema is defined from createWorker\n  async setupServer(jobs: Worker<any, WorkerType>[]) {\n    await this.assertConnectionToChannel();\n\n    for (const job of jobs) {\n      if (job.jobConfig.options.type === \"event\") {\n        this.channel?.assertQueue(job.jobConfig.name, {\n          durable: true,\n        });\n\n        this.channel?.consume(job.jobConfig.name, (msg) => {\n          if (msg) {\n            job.jobConfig.initTask(msg.content.toString());\n          }\n        });\n      } else {\n        CronJob.from({\n          cronTime: job.jobConfig.options.schedule,\n          onTick: async () => {\n            await (job.jobConfig.initTask as () => Promise<void>)();\n          },\n          start: true,\n```"}, {"role": "assistant", "content": "Suggestion:\n```packages/jobs/src/client.ts\n      return () =>\n        ({\n          jobConfig,\n          startTask: async (taskPayload: z.infer<Schema>) => {\n            if (!payload) {\n              throw new Error(\"Payload schema is required for event workers\");\n            }\n\n            // This will throw before sending if the payload is bad\n            payload.parse(taskPayload);\n\n            await this.assertConnectionToChannel();\n\n            const stringifiedPayload = JSON.stringify(taskPayload);\n\n            this.channel?.assertQueue(name, {\n              durable: true,\n            });\n\n            this.channel?.sendToQueue(name, Buffer.from(stringifiedPayload), {\n              persistent: true,\n              ...options.publishOptions,\n            });\n          },\n        } as Worker<Schema, Type>);\n    }\n\n    return () =>\n      ({\n        jobConfig,\n      } as Worker<Schema, Type>);\n  }\n<|editable_region_start|>\n\n  private async closeConnection() {\n    try {\n      this.channel?.close();\n      this.connection?.close();\n    } catch (error) {\n      console.error(\"Error closing connections:\", error);\n    }\n  }\n  \n  private async assertConnectionToChannel() {\n    if (!this.connection) {\n      this.connection = await amqp.connect(this.url);\n    }\n<|editable_region_end|>\n\n    if (!this.channel) {\n      this.channel = await this.connection.createChannel();\n    }\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: Doesn't matter at this point, its schema is defined from createWorker\n  async setupServer(jobs: Worker<any, WorkerType>[]) {\n    await this.assertConnectionToChannel();\n\n    for (const job of jobs) {\n      if (job.jobConfig.options.type === \"event\") {\n        this.channel?.assertQueue(job.jobConfig.name, {\n          durable: true,\n        });\n\n        this.channel?.consume(job.jobConfig.name, (msg) => {\n          if (msg) {\n            job.jobConfig.initTask(msg.content.toString());\n          }\n        });\n      } else {\n        CronJob.from({\n          cronTime: job.jobConfig.options.schedule,\n          onTick: async () => {\n            await (job.jobConfig.initTask as () => Promise<void>)();\n          },\n          start: true,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -132,6 +132,7 @@\n         let buffer_snapshot = buffer.read(cx).snapshot(cx);\n         let crease_map = CreaseMap::new(&buffer_snapshot);\n         let (inlay_map, snapshot) = InlayMap::new(buffer_snapshot);\n+        /// !!!!\n         let (fold_map, snapshot) = FoldMap::new(snapshot);\n         let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n         let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -136,6 +136,7 @@\n         let (fold_map, snapshot) = FoldMap::new(snapshot);\n         let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n         let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n+        /// now here!\n         let block_map = BlockMap::new(\n             snapshot,\n             show_excerpt_controls,\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -132,8 +132,8 @@\n         let buffer_snapshot = buffer.read(cx).snapshot(cx);\n         let crease_map = CreaseMap::new(&buffer_snapshot);\n         let (inlay_map, snapshot) = InlayMap::new(buffer_snapshot);\n-        /// !!!!\n         let (fold_map, snapshot) = FoldMap::new(snapshot);\n+        /// we're here!!!!\n         let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n         let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n         /// now here!\n\n```\n\nUser edited \"crates/editor/src/display_map.rs\":\n```diff\n@@ -133,7 +133,7 @@\n         let crease_map = CreaseMap::new(&buffer_snapshot);\n         let (inlay_map, snapshot) = InlayMap::new(buffer_snapshot);\n         let (fold_map, snapshot) = FoldMap::new(snapshot);\n-        /// we're here!!!!\n+        ///^^^ we're here!!!!\n         let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n         let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n         /// now here!\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/editor/src/display_map.rs\n    block_map: BlockMap,\n    /// Regions of text that should be highlighted.\n    text_highlights: TextHighlights,\n    /// Regions of inlays that should be highlighted.\n    inlay_highlights: InlayHighlights,\n    /// A container for explicitly foldable ranges, which supersede indentation based fold range suggestions.\n    crease_map: CreaseMap,\n    pub(crate) fold_placeholder: FoldPlaceholder,\n    pub clip_at_line_ends: bool,\n    pub(crate) masked: bool,\n}\n\nimpl DisplayMap {\n    #[allow(clippy::too_many_arguments)]\n<|editable_region_start|>\n    pub fn new(\n        buffer: Entity<MultiBuffer>,\n        font: Font,\n        font_size: Pixels,\n        wrap_width: Option<Pixels>,\n        show_excerpt_controls: bool,\n        buffer_header_height: u32,\n        excerpt_header_height: u32,\n        excerpt_footer_height: u32,\n        fold_placeholder: FoldPlaceholder,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let buffer_subscription = buffer.update(cx, |buffer, _| buffer.subscribe());\n\n        let tab_size = Self::tab_size(&buffer, cx);\n        let buffer_snapshot = buffer.read(cx).snapshot(cx);\n        let crease_map = CreaseMap::new(&buffer_snapshot);\n        let (inlay_map, snapshot) = InlayMap::new(buffer_snapshot);\n        let (fold_map, snapshot) = FoldMap::new(snapshot);\n        ///^^^<|user_cursor_is_here|> we're here!!!!\n        let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n        let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n        /// now here!\n        let block_map = BlockMap::new(\n            snapshot,\n            show_excerpt_controls,\n            buffer_header_height,\n            excerpt_header_height,\n            excerpt_footer_height,\n        );\n\n        cx.observe(&wrap_map, |_, _, cx| cx.notify()).detach();\n\n        DisplayMap {\n            buffer,\n            buffer_subscription,\n            fold_map,\n            inlay_map,\n<|editable_region_end|>\n            tab_map,\n            wrap_map,\n            block_map,\n            crease_map,\n            fold_placeholder,\n            text_highlights: Default::default(),\n            inlay_highlights: Default::default(),\n            clip_at_line_ends: false,\n            masked: false,\n        }\n    }\n\n    pub fn snapshot(&mut self, cx: &mut Context<Self>) -> DisplaySnapshot {\n        let buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n        let edits = self.buffer_subscription.consume().into_inner();\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/editor/src/display_map.rs\n    block_map: BlockMap,\n    /// Regions of text that should be highlighted.\n    text_highlights: TextHighlights,\n    /// Regions of inlays that should be highlighted.\n    inlay_highlights: InlayHighlights,\n    /// A container for explicitly foldable ranges, which supersede indentation based fold range suggestions.\n    crease_map: CreaseMap,\n    pub(crate) fold_placeholder: FoldPlaceholder,\n    pub clip_at_line_ends: bool,\n    pub(crate) masked: bool,\n}\n\nimpl DisplayMap {\n    #[allow(clippy::too_many_arguments)]\n<|editable_region_start|>\n    pub fn new(\n        buffer: Entity<MultiBuffer>,\n        font: Font,\n        font_size: Pixels,\n        wrap_width: Option<Pixels>,\n        show_excerpt_controls: bool,\n        buffer_header_height: u32,\n        excerpt_header_height: u32,\n        excerpt_footer_height: u32,\n        fold_placeholder: FoldPlaceholder,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let buffer_subscription = buffer.update(cx, |buffer, _| buffer.subscribe());\n\n        let tab_size = Self::tab_size(&buffer, cx);\n        let buffer_snapshot = buffer.read(cx).snapshot(cx);\n        let crease_map = CreaseMap::new(&buffer_snapshot);\n        let (inlay_map, snapshot) = InlayMap::new(buffer_snapshot);\n        let (fold_map, snapshot) = FoldMap::new(snapshot);\n        ///^^^ we're here!!!!\n        let (tab_map, snapshot) = TabMap::new(snapshot, tab_size);\n        let (wrap_map, snapshot) = WrapMap::new(snapshot, font, font_size, wrap_width, cx);\n        ///^^^ now here!\n        let block_map = BlockMap::new(\n            snapshot,\n            show_excerpt_controls,\n            buffer_header_height,\n            excerpt_header_height,\n            excerpt_footer_height,\n        );\n\n        cx.observe(&wrap_map, |_, _, cx| cx.notify()).detach();\n\n        DisplayMap {\n            buffer,\n            buffer_subscription,\n            fold_map,\n            inlay_map,\n<|editable_region_end|>\n            tab_map,\n            wrap_map,\n            block_map,\n            crease_map,\n            fold_placeholder,\n            text_highlights: Default::default(),\n            inlay_highlights: Default::default(),\n            clip_at_line_ends: false,\n            masked: false,\n        }\n    }\n\n    pub fn snapshot(&mut self, cx: &mut Context<Self>) -> DisplaySnapshot {\n        let buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n        let edits = self.buffer_subscription.consume().into_inner();\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"apps/business-web/app/lib/jobs.server.ts\":\n```diff\n@@ -275,5 +275,5 @@\n export const Jobs = {\n   initializePlatform: initializePlatformJob.startTask,\n   unsubUserFromMembership: unsubUserFromMembershipJob.startTask,\n-  updateUserSubPrice: updateUserSubPrice.startTask,\n+  updateUserSubPrice: updateUserSubPriceJob.startTask,\n };\n\n```\n\nUser edited \"apps/business-web/app/lib/jobs.server.ts\":\n```diff\n@@ -261,7 +261,7 @@\n });\n \n export async function startJobsServer() {\n-  Logger.info(\"\u2139\ufe0f Initializing Jobs Server\");\n+  Logger.info(\" Initializing Jobs Server\");\n \n   jobsClient.setupServer([\n     initializePlatformJob,\n\n```\n\nUser edited \"apps/business-web/app/lib/jobs.server.ts\":\n```diff\n@@ -261,7 +261,7 @@\n });\n \n export async function startJobsServer() {\n-  Logger.info(\" Initializing Jobs Server\");\n+  Logger.info(\"\ud83d\ude80 Initializing Jobs Server\");\n \n   jobsClient.setupServer([\n     initializePlatformJob,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```apps/business-web/app/lib/jobs.server.ts\n      ],\n    });\n\n    await Database.update(schema.memberships)\n      .set({ priceId: payload.priceId })\n      .where(eq(schema.memberships.id, payload.membershipId));\n\n    if (membership.userEmail) {\n      const oldPriceFormat = `${currencySymbol[oldPrice.currency]}${\n        oldPrice.amount * 100\n      }${\n        oldPrice.intervalCount\n          ? ` every ${oldPrice.intervalCount} ${oldPrice.interval}${\n<|editable_region_start|>\n              oldPrice.intervalCount !== 1 ? \"s\" : \"\"\n            }`\n          : \"\"\n      }`;\n      const priceFormat = `${currencySymbol[price.currency]}${\n        price.amount * 100\n      }${\n        price.intervalCount\n          ? ` every ${price.intervalCount} ${price.interval}${\n              price.intervalCount !== 1 ? \"s\" : \"\"\n            }`\n          : \"\"\n      }`;\n\n      await Email.send({\n        to: membership.userEmail,\n        from: \"Bordsy<no-reply@bordsy.com>\",\n        subject: \"Your Membership Pricing Changed\",\n        react: TransactionEmail({\n          heading: \"Membership Updated\",\n          body: `Your membership has been changed.\nYour previous membership price was ${oldPriceFormat} and your new membership price is ${priceFormat}.\nIf you have any questions, please contact support.`,\n        }),\n      });\n    }\n\n    await Database.insert(schema.notifications).values({\n      userId: payload.userId,\n      title: \"Membership Updated\",\n      body: \"Your membership has been cancelled. If you have any questions, please contact support.\",\n    });\n  },\n});\n\nexport async function startJobsServer() {\n  Logger.info(\"\ud83d\ude80<|user_cursor_is_here|> Initializing Jobs Server\");\n\n  jobsClient.setupServer([\n    initializePlatformJob,\n    unsubUserFromMembershipJob,\n    updateUserSubPriceJob,\n  ]);\n\n  Logger.info(\"\u2705 Jobs Server Started\");\n}\n\nexport const Jobs = {\n<|editable_region_end|>\n  initializePlatform: initializePlatformJob.startTask,\n  unsubUserFromMembership: unsubUserFromMembershipJob.startTask,\n  updateUserSubPrice: updateUserSubPriceJob.startTask,\n};\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```apps/business-web/app/lib/jobs.server.ts\n      ],\n    });\n\n    await Database.update(schema.memberships)\n      .set({ priceId: payload.priceId })\n      .where(eq(schema.memberships.id, payload.membershipId));\n\n    if (membership.userEmail) {\n      const oldPriceFormat = `${currencySymbol[oldPrice.currency]}${\n        oldPrice.amount * 100\n      }${\n        oldPrice.intervalCount\n          ? ` every ${oldPrice.intervalCount} ${oldPrice.interval}${\n<|editable_region_start|>\n              oldPrice.intervalCount !== 1 ? \"s\" : \"\"\n            }`\n          : \"\"\n      }`;\n      const priceFormat = `${currencySymbol[price.currency]}${\n        price.amount * 100\n      }${\n        price.intervalCount\n          ? ` every ${price.intervalCount} ${price.interval}${\n              price.intervalCount !== 1 ? \"s\" : \"\"\n            }`\n          : \"\"\n      }`;\n\n      await Email.send({\n        to: membership.userEmail,\n        from: \"Bordsy<no-reply@bordsy.com>\",\n        subject: \"Your Membership Pricing Changed\",\n        react: TransactionEmail({\n          heading: \"Membership Updated\",\n          body: `Your membership has been changed.\nYour previous membership price was ${oldPriceFormat} and your new membership price is ${priceFormat}.\nIf you have any questions, please contact support.`,\n        }),\n      });\n    }\n\n    await Database.insert(schema.notifications).values({\n      userId: payload.userId,\n      title: \"Membership Updated\",\n      body: \"Your membership has been cancelled. If you have any questions, please contact support.\",\n    });\n  },\n});\n\nexport async function startJobsServer() {\n  Logger.info(\"\ud83d\ude80 Initializing Jobs Server\");\n\n  jobsClient.setupServer([\n    initializePlatformJob,\n    unsubUserFromMembershipJob,\n    updateUserSubPriceJob,\n  ]);\n\n  Logger.info(\"\u2705 Jobs Server Started\");\n}\n\nexport const Jobs = {\n<|editable_region_end|>\n  initializePlatform: initializePlatformJob.startTask,\n  unsubUserFromMembership: unsubUserFromMembershipJob.startTask,\n  updateUserSubPrice: updateUserSubPriceJob.startTask,\n};\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"workspace-cli/src/cli.rs\":\n```diff\n@@ -14,7 +14,7 @@\n use group::{cli_group, GroupCommands};\n use key::{cli_key, KeyCommands};\n use minion::{cli_minion, MinionCommands};\n-use settings::cli_settings;\n+use settings::{cli_settings, SettingsCommands};\n use user::{cli_user, UserCommands};\n use version::cli_version;\n use workspace_config::ResaltConfig;\n\n```\n\nUser edited \"workspace-config/src/lib.rs\":\n```diff\n@@ -55,7 +55,7 @@\n             ResaltConfigKey::DatabaseHost => \"docs/docker/filesdb\",\n             ResaltConfigKey::DatabasePassword => \"resalt\",\n             ResaltConfigKey::DatabasePort => \"6379\",\n-            ResaltConfigKey::DatabaseType => \"files\",\n+            ResaltConfigKey::DatabaseType => \"redis\",\n             ResaltConfigKey::DatabaseUsername => \"default\",\n             ResaltConfigKey::HttpPort => \"8000\",\n             ResaltConfigKey::OAuthClientId => panic!(\"OAuth client ID is required\"),\n\n```\n\nUser edited \"workspace-config/src/lib.rs\":\n```diff\n@@ -52,7 +52,7 @@\n             ResaltConfigKey::AuthTokenMonitor => panic!(\"Auth Token Monitor is required\"),\n             ResaltConfigKey::AuthTokenSalt => panic!(\"Auth Token Salt is required\"),\n             ResaltConfigKey::DatabaseDatabase => \"0\",\n-            ResaltConfigKey::DatabaseHost => \"docs/docker/filesdb\",\n+            ResaltConfigKey::DatabaseHost => \"\n             ResaltConfigKey::DatabasePassword => \"resalt\",\n             ResaltConfigKey::DatabasePort => \"6379\",\n             ResaltConfigKey::DatabaseType => \"redis\",\n\n```\n\nUser edited \"workspace-config/src/lib.rs\":\n```diff\n@@ -52,7 +52,7 @@\n             ResaltConfigKey::AuthTokenMonitor => panic!(\"Auth Token Monitor is required\"),\n             ResaltConfigKey::AuthTokenSalt => panic!(\"Auth Token Salt is required\"),\n             ResaltConfigKey::DatabaseDatabase => \"0\",\n-            ResaltConfigKey::DatabaseHost => \"\n+            ResaltConfigKey::DatabaseHost => \"redis\n             ResaltConfigKey::DatabasePassword => \"resalt\",\n             ResaltConfigKey::DatabasePort => \"6379\",\n             ResaltConfigKey::DatabaseType => \"redis\",\n\n```\n\nUser edited \"workspace-config/src/lib.rs\":\n```diff\n@@ -52,7 +52,7 @@\n             ResaltConfigKey::AuthTokenMonitor => panic!(\"Auth Token Monitor is required\"),\n             ResaltConfigKey::AuthTokenSalt => panic!(\"Auth Token Salt is required\"),\n             ResaltConfigKey::DatabaseDatabase => \"0\",\n-            ResaltConfigKey::DatabaseHost => \"redis\n+            ResaltConfigKey::DatabaseHost => \"redis\"\n             ResaltConfigKey::DatabasePassword => \"resalt\",\n             ResaltConfigKey::DatabasePort => \"6379\",\n             ResaltConfigKey::DatabaseType => \"redis\",\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```workspace-config/src/lib.rs\n}\n\nimpl ResaltConfigKey {\n    fn key(&self) -> &'static str {\n        match self {\n            ResaltConfigKey::AuthSessionLifespan => \"RESALT_AUTH_SESSION_LIFESPAN\",\n            ResaltConfigKey::AuthTokenCLI => \"RESALT_AUTH_TOKEN_CLI\",\n            ResaltConfigKey::AuthTokenMonitor => \"RESALT_AUTH_TOKEN_MONITOR\",\n            ResaltConfigKey::AuthTokenSalt => \"RESALT_AUTH_TOKEN_SALT\",\n            ResaltConfigKey::DatabaseDatabase => \"RESALT_DATABASE_DATABASE\",\n            ResaltConfigKey::DatabaseHost => \"RESALT_DATABASE_HOST\",\n            ResaltConfigKey::DatabasePassword => \"RESALT_DATABASE_PASSWORD\",\n            ResaltConfigKey::DatabasePort => \"RESALT_DATABASE_PORT\",\n            ResaltConfigKey::DatabaseType => \"RESALT_DATABASE_TYPE\",\n            ResaltConfigKey::DatabaseUsername => \"RESALT_DATABASE_USERNAME\",\n            ResaltConfigKey::HttpPort => \"RESALT_HTTP_PORT\",\n            ResaltConfigKey::OAuthClientId => \"RESALT_OAUTH_CLIENT_ID\",\n            ResaltConfigKey::OAuthClientSecret => \"RESALT_OAUTH_CLIENT_SECRET\",\n            ResaltConfigKey::OAuthIssuer => \"RESALT_OAUTH_ISSUER\",\n            ResaltConfigKey::OAuthRedirectUrl => \"RESALT_OAUTH_REDIRECT_URL\",\n            ResaltConfigKey::SaltApiUrl => \"RESALT_SALT_API_URL\",\n            ResaltConfigKey::SaltPkiPath => \"RESALT_SALT_PKI_PATH\",\n        }\n    }\n\n    #[allow(clippy::match_same_arms)]\n    fn fallback(&self) -> &'static str {\n        match self {\n            ResaltConfigKey::AuthSessionLifespan => \"43200\",\n            ResaltConfigKey::AuthTokenCLI => panic!(\"Auth Token CLI is required\"),\n<|editable_region_start|>\n            ResaltConfigKey::AuthTokenMonitor => panic!(\"Auth Token Monitor is required\"),\n            ResaltConfigKey::AuthTokenSalt => panic!(\"Auth Token Salt is required\"),\n            ResaltConfigKey::DatabaseDatabase => \"0\",\n            ResaltConfigKey::DatabaseHost => \"redis\"<|user_cursor_is_here|>\n            ResaltConfigKey::DatabasePassword => \"resalt\",\n            ResaltConfigKey::DatabasePort => \"6379\",\n            ResaltConfigKey::DatabaseType => \"redis\",\n            ResaltConfigKey::DatabaseUsername => \"default\",\n            ResaltConfigKey::HttpPort => \"8000\",\n            ResaltConfigKey::OAuthClientId => panic!(\"OAuth client ID is required\"),\n            ResaltConfigKey::OAuthClientSecret => panic!(\"OAuth client secret is required\"),\n            ResaltConfigKey::OAuthIssuer => panic!(\"OAuth issuer is required\"),\n            ResaltConfigKey::OAuthRedirectUrl => panic!(\"OAuth redirect URL is required\"),\n            ResaltConfigKey::SaltApiUrl => \"http://localhost:8080\",\n            ResaltConfigKey::SaltPkiPath => \"/etc/salt/pki\",\n        }\n    }\n}\n\n<|editable_region_end|>\n#[must_use]\n#[allow(clippy::needless_pass_by_value)]\nfn conf<T: std::str::FromStr>(rck: ResaltConfigKey) -> T\nwhere\n    T::Err: std::fmt::Debug,\n{\n    // Check if key_FILE env variable is set\n    let key = rck.key();\n    let key_file = format!(\"{key}_FILE\");\n    let key_file = std::env::var(key_file).ok();\n    if let Some(key_file) = key_file {\n        if !key_file.is_empty() {\n            let data = match std::fs::read_to_string(strip_quotes(&key_file)) {\n                Ok(data) => data,\n                Err(e) => {\n                    panic!(\"Error reading {}: {}\", &key_file, e);\n                }\n            };\n```"}, {"role": "assistant", "content": "Suggestion:\n```workspace-config/src/lib.rs\n}\n\nimpl ResaltConfigKey {\n    fn key(&self) -> &'static str {\n        match self {\n            ResaltConfigKey::AuthSessionLifespan => \"RESALT_AUTH_SESSION_LIFESPAN\",\n            ResaltConfigKey::AuthTokenCLI => \"RESALT_AUTH_TOKEN_CLI\",\n            ResaltConfigKey::AuthTokenMonitor => \"RESALT_AUTH_TOKEN_MONITOR\",\n            ResaltConfigKey::AuthTokenSalt => \"RESALT_AUTH_TOKEN_SALT\",\n            ResaltConfigKey::DatabaseDatabase => \"RESALT_DATABASE_DATABASE\",\n            ResaltConfigKey::DatabaseHost => \"RESALT_DATABASE_HOST\",\n            ResaltConfigKey::DatabasePassword => \"RESALT_DATABASE_PASSWORD\",\n            ResaltConfigKey::DatabasePort => \"RESALT_DATABASE_PORT\",\n            ResaltConfigKey::DatabaseType => \"RESALT_DATABASE_TYPE\",\n            ResaltConfigKey::DatabaseUsername => \"RESALT_DATABASE_USERNAME\",\n            ResaltConfigKey::HttpPort => \"RESALT_HTTP_PORT\",\n            ResaltConfigKey::OAuthClientId => \"RESALT_OAUTH_CLIENT_ID\",\n            ResaltConfigKey::OAuthClientSecret => \"RESALT_OAUTH_CLIENT_SECRET\",\n            ResaltConfigKey::OAuthIssuer => \"RESALT_OAUTH_ISSUER\",\n            ResaltConfigKey::OAuthRedirectUrl => \"RESALT_OAUTH_REDIRECT_URL\",\n            ResaltConfigKey::SaltApiUrl => \"RESALT_SALT_API_URL\",\n            ResaltConfigKey::SaltPkiPath => \"RESALT_SALT_PKI_PATH\",\n        }\n    }\n\n    #[allow(clippy::match_same_arms)]\n    fn fallback(&self) -> &'static str {\n        match self {\n            ResaltConfigKey::AuthSessionLifespan => \"43200\",\n            ResaltConfigKey::AuthTokenCLI => panic!(\"Auth Token CLI is required\"),\n<|editable_region_start|>\n            ResaltConfigKey::AuthTokenMonitor => panic!(\"Auth Token Monitor is required\"),\n            ResaltConfigKey::AuthTokenSalt => panic!(\"Auth Token Salt is required\"),\n            ResaltConfigKey::DatabaseDatabase => \"0\",\n            ResaltConfigKey::DatabaseHost => \"redis\",\n            ResaltConfigKey::DatabasePassword => \"resalt\",\n            ResaltConfigKey::DatabasePort => \"6379\",\n            ResaltConfigKey::DatabaseType => \"redis\",\n            ResaltConfigKey::DatabaseUsername => \"default\",\n            ResaltConfigKey::HttpPort => \"8000\",\n            ResaltConfigKey::OAuthClientId => panic!(\"OAuth client ID is required\"),\n            ResaltConfigKey::OAuthClientSecret => panic!(\"OAuth client secret is required\"),\n            ResaltConfigKey::OAuthIssuer => panic!(\"OAuth issuer is required\"),\n            ResaltConfigKey::OAuthRedirectUrl => panic!(\"OAuth redirect URL is required\"),\n            ResaltConfigKey::SaltApiUrl => \"http://localhost:8080\",\n            ResaltConfigKey::SaltPkiPath => \"/etc/salt/pki\",\n        }\n    }\n}\n\n<|editable_region_end|>\n#[must_use]\n#[allow(clippy::needless_pass_by_value)]\nfn conf<T: std::str::FromStr>(rck: ResaltConfigKey) -> T\nwhere\n    T::Err: std::fmt::Debug,\n{\n    // Check if key_FILE env variable is set\n    let key = rck.key();\n    let key_file = format!(\"{key}_FILE\");\n    let key_file = std::env::var(key_file).ok();\n    if let Some(key_file) = key_file {\n        if !key_file.is_empty() {\n            let data = match std::fs::read_to_string(strip_quotes(&key_file)) {\n                Ok(data) => data,\n                Err(e) => {\n                    panic!(\"Error reading {}: {}\", &key_file, e);\n                }\n            };\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -219,6 +219,7 @@\n     \"shell\": { \"program\": \"sh\" },\n     \"show_summary\": false,\n     \"show_output\": true,\n+    \n     \"when\": {\n       \"file_extensions\": [\"sh\", \"ts\", \"js\", \"tsx\", \"jsx\", \"ts.md\"]\n     }\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```\n{\n  \"context\": \"Workspace\",\n  \"bindings\": {\n    \"alt-g\": [\n      \"task::Spawn\",\n      { \"task_name\": \"start lazygit\", \"reveal_target\": \"center\" }\n    ]\n  }\n}\n\n```\n\n## Binding runnable tags to task templates\n\nZed supports overriding default action for inline runnable indicators via workspace-local and global `tasks.json` file with the following precedence hierarchy:\n- Workspace `tasks.json`\n- Global `tasks.json`\n- Language-provided tag bindings (default).\n\nTo tag a task, add the runnable tag name to `tags` field on task template:\n\n```\n{\n  \"label\": \"echo current file's path\",\n  \"command\": \"echo $ZED_FILE\",\n  \"tags\": [\"rust-test\"]\n}\n\n```\n\nIn doing so, you can change which task is shown in runnables indicator.\n*/\n[\n  {\n    \"label\": \"Bun run $ZED_RELATIVE_FILE (watch)\",\n    \"cwd\": \"$ZED_WORKTREE_ROOT\",\n    \"command\": \"bun\",\n    \"args\": [\"run\", \"--watch\", \"$ZED_RELATIVE_FILE\"],\n    \"tags\": [\"typescript-run\"],\n    \"env\": {},\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": true,\n    \"reveal\": \"always\",\n<|editable_region_start|>\n    \"hide\": \"never\",\n    \"shell\": { \"program\": \"sh\" },\n    \"show_summary\": false,\n    \"show_output\": true,\n    <|user_cursor_is_here|>\n    \"when\": {\n      \"file_extensions\": [\"sh\", \"ts\", \"js\", \"tsx\", \"jsx\", \"ts.md\"]\n    }\n  },\n  {\n    \"label\": \"darwin-rebuild switch\",\n    \"command\": \"darwin-rebuild switch\",\n    \"tags\": [\"nix\"],\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": false,\n    \"reveal\": \"always\",\n<|editable_region_end|>\n    \"hide\": \"never\",\n    \"shell\": { \"program\": \"sh\" },\n    \"show_summary\": true,\n    \"show_output\": true\n  }\n]\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```\n{\n  \"context\": \"Workspace\",\n  \"bindings\": {\n    \"alt-g\": [\n      \"task::Spawn\",\n      { \"task_name\": \"start lazygit\", \"reveal_target\": \"center\" }\n    ]\n  }\n}\n\n```\n\n## Binding runnable tags to task templates\n\nZed supports overriding default action for inline runnable indicators via workspace-local and global `tasks.json` file with the following precedence hierarchy:\n- Workspace `tasks.json`\n- Global `tasks.json`\n- Language-provided tag bindings (default).\n\nTo tag a task, add the runnable tag name to `tags` field on task template:\n\n```\n{\n  \"label\": \"echo current file's path\",\n  \"command\": \"echo $ZED_FILE\",\n  \"tags\": [\"rust-test\"]\n}\n\n```\n\nIn doing so, you can change which task is shown in runnables indicator.\n*/\n[\n  {\n    \"label\": \"Bun run $ZED_RELATIVE_FILE (watch)\",\n    \"cwd\": \"$ZED_WORKTREE_ROOT\",\n    \"command\": \"bun\",\n    \"args\": [\"run\", \"--watch\", \"$ZED_RELATIVE_FILE\"],\n    \"tags\": [\"typescript-run\"],\n    \"env\": {},\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": true,\n    \"reveal\": \"always\",\n<|editable_region_start|>\n    \"hide\": \"never\",\n    \"shell\": { \"program\": \"sh\" },\n    \"show_summary\": false,\n    \"show_output\": true,\n    \n    \"when\": {\n      \"file_extensions\": [\"sh\", \"ts\", \"js\", \"tsx\", \"jsx\", \"ts.md\"]\n    }\n  },\n  {\n    \"label\": \"darwin-rebuild switch\",\n    \"command\": \"darwin-rebuild switch\",\n    \"tags\": [\"nix\"],\n    \"use_new_terminal\": false,\n    \"allow_concurrent_runs\": false,\n    \"reveal\": \"always\",\n<|editable_region_end|>\n    \"hide\": \"never\",\n    \"shell\": { \"program\": \"sh\" },\n    \"show_summary\": true,\n    \"show_output\": true\n  }\n]\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"\":\n```diff\n@@ -46,7 +46,7 @@\n     \"border_size\": 0.0,\n     // Opacity of the inactive panes. 0 means transparent, 1 means opaque.\n     // Values are clamped to the [0.0, 1.0] range.\n-    \"inactive_opacity\": 0.6\n+    \"inactive_opacity\": 0.4\n   },\n   \"preview_tabs\": {\n     // Whether preview tabs should be enabled.\n\n```\n\nUser edited \"src/shared/components/commons/BinapsTable.vue\":\n```diff\n@@ -102,6 +102,7 @@\n       size: 100,\n       minSize: 100,\n     },\n+    \n     columnResizeMode: 'onChange',\n     columnResizeDirection: 'ltr',\n     enableColumnResizing: true,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/shared/components/commons/BinapsTable.vue\n  useVueTable,\n  FlexRender,\n  getCoreRowModel,\n  getSortedRowModel,\n  getFilteredRowModel,\n  type SortingState,\n  type ColumnDef,\n  type Header,\n} from '@tanstack/vue-table';\nimport { computed, ref, watch, type PropType } from 'vue';\nimport type { Column } from '@/features/reports/ui/components/basic/SmartTableComponent.vue';\n\nconst props = defineProps({\n  data: {\n    type: Array as PropType<unknown[]>,\n    required: true,\n  },\n  columns: {\n<|editable_region_start|>\n    type: Array as PropType<Column[]>,\n    required: true,\n  },\n});\n\nconst sorting = ref<SortingState>([]);\nconst filter = ref('');\n\n// TODO: understand why this is working only with computed\nconst table = computed(() =>\n  useVueTable({\n    defaultColumn: {\n      size: 100,\n      minSize: 100,\n    },\n    <|user_cursor_is_here|>\n    columnResizeMode: 'onChange',\n    columnResizeDirection: 'ltr',\n    enableColumnResizing: true,\n    debugTable: true,\n    debugHeaders: true,\n    debugColumns: true,\n    data: props.data ?? [],\n    columns: props.columns as ColumnDef<unknown, unknown>[],\n    getCoreRowModel: getCoreRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    state: {\n      get sorting() {\n        return sorting.value;\n      },\n      get globalFilter() {\n        return filter.value;\n      },\n    },\n<|editable_region_end|>\n    onSortingChange: (updaterOrValue) => {\n      sorting.value =\n        typeof updaterOrValue === 'function'\n          ? updaterOrValue(sorting.value)\n          : updaterOrValue;\n    },\n  }),\n);\n\n// (property) onMousedown?: ((payload: MouseEvent) => void) | undefined\nconst mousedownEvent = (\n  event: MouseEvent,\n  header: Header<unknown, unknown>,\n) => {\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/shared/components/commons/BinapsTable.vue\n  useVueTable,\n  FlexRender,\n  getCoreRowModel,\n  getSortedRowModel,\n  getFilteredRowModel,\n  type SortingState,\n  type ColumnDef,\n  type Header,\n} from '@tanstack/vue-table';\nimport { computed, ref, watch, type PropType } from 'vue';\nimport type { Column } from '@/features/reports/ui/components/basic/SmartTableComponent.vue';\n\nconst props = defineProps({\n  data: {\n    type: Array as PropType<unknown[]>,\n    required: true,\n  },\n  columns: {\n<|editable_region_start|>\n    type: Array as PropType<Column[]>,\n    required: true,\n  },\n});\n\nconst sorting = ref<SortingState>([]);\nconst filter = ref('');\n\n// TODO: understand why this is working only with computed\nconst table = computed(() =>\n  useVueTable({\n    defaultColumn: {\n      size: 100,\n      minSize: 100,\n    },\n    \n    columnResizeMode: 'onChange',\n    columnResizeDirection: 'ltr',\n    enableColumnResizing: true,\n    debugTable: true,\n    debugHeaders: true,\n    debugColumns: true,\n    data: props.data ?? [],\n    columns: props.columns as ColumnDef<unknown, unknown>[],\n    getCoreRowModel: getCoreRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    state: {\n      get sorting() {\n        return sorting.value;\n      },\n      get globalFilter() {\n        return filter.value;\n      },\n    },\n<|editable_region_end|>\n    onSortingChange: (updaterOrValue) => {\n      sorting.value =\n        typeof updaterOrValue === 'function'\n          ? updaterOrValue(sorting.value)\n          : updaterOrValue;\n    },\n  }),\n);\n\n// (property) onMousedown?: ((payload: MouseEvent) => void) | undefined\nconst mousedownEvent = (\n  event: MouseEvent,\n  header: Header<unknown, unknown>,\n) => {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"lib/utils.ts\":\n```diff\n@@ -31,10 +31,18 @@\n \n // loop through object properties and check if any of them is empty\n export function objectHasIncompleteData(obj: Record<string, unknown>) {\n-  const optional_fields = []\n-  \n-  \n-  \n+  const optional_fields = [\"phone\", \"email\"];\n+  for (const key in obj) {\n+    if (\n+      obj[key] === null ||\n+      obj[key] === undefined ||\n+      obj[key] === \"\" ||\n+      (optional_fields.includes(key) && obj[key] === \"N/A\")\n+    ) {\n+      return true;\n+    }\n+  }\n+  return false;\n }\n \n export function objectToString(obj: Record<string, any>): string {\n\n```\n\nUser edited \"lib/utils.ts\":\n```diff\n@@ -31,6 +31,7 @@\n \n // loop through object properties and check if any of them is empty\n export function objectHasIncompleteData(obj: Record<string, unknown>) {\n+  re\n   const optional_fields = [\"phone\", \"email\"];\n   for (const key in obj) {\n     if (\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```lib/utils.ts\nimport { toast } from \"@/components/ui/use-toast\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { MessageType, Submission } from \"./generics\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function generateOTPCode() {\n<|editable_region_start|>\n  const code = Math.floor(100000 + Math.random() * 900000);\n  return code.toString();\n}\n\nexport function getInitials(name: string) {\n  const [firstName, lastName] = name.split(\" \");\n  return `${firstName.charAt(0)}${lastName ? lastName.charAt(0) : \"\"}`;\n}\n\nexport function copyToClipboard(str: string) {\n  navigator.clipboard.writeText(str);\n  toast({\n    description: \"Copied to clipboard\",\n  });\n}\n\nexport function sanitizePhone(phone: string) {\n  // remove spaces and special characters\n  return phone.replace(/[^0-9]/g, \"\");\n}\n\n// loop through object properties and check if any of them is empty\nexport function objectHasIncompleteData(obj: Record<string, unknown>) {\n  re<|user_cursor_is_here|>\n  const optional_fields = [\"phone\", \"email\"];\n  for (const key in obj) {\n    if (\n      obj[key] === null ||\n      obj[key] === undefined ||\n      obj[key] === \"\" ||\n      (optional_fields.includes(key) && obj[key] === \"N/A\")\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function objectToString(obj: Record<string, any>): string {\n  return Object.entries(obj)\n    .map(([key, value]) => `${key.replaceAll(\"_\", \" \")}: ${value}`)\n    .join(\"\\n\");\n}\n\nexport function getMessageContentFromMessageType(props: {\n  type: MessageType;\n  submissionId?: string | number;\n  submissionData?: Submission;\n  toAdmin?: boolean;\n  content?: string;\n}) {\n  if (\n    props.toAdmin &&\n    props.submissionData &&\n    props.type === MessageType.SubmissionUploaded\n<|editable_region_end|>\n  ) {\n    return `You\u2019ve successfully submitted your song to Crux. We\u2019ll let you know as soon as your song is live and ready to share with your world. \\n\\n${process.env.NEXT_PUBLIC_SITE_URL}/dashboard/my-music/${props.submissionId}. \\n\\n${objectToString(props.submissionData as unknown as Record<string, string>)}`;\n```"}, {"role": "assistant", "content": "Suggestion:\n```lib/utils.ts\nimport { toast } from \"@/components/ui/use-toast\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\nimport { MessageType, Submission } from \"./generics\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function generateOTPCode() {\n<|editable_region_start|>\n  const code = Math.floor(100000 + Math.random() * 900000);\n  return code.toString();\n}\n\nexport function getInitials(name: string) {\n  const [firstName, lastName] = name.split(\" \");\n  return `${firstName.charAt(0)}${lastName ? lastName.charAt(0) : \"\"}`;\n}\n\nexport function copyToClipboard(str: string) {\n  navigator.clipboard.writeText(str);\n  toast({\n    description: \"Copied to clipboard\",\n  });\n}\n\nexport function sanitizePhone(phone: string) {\n  // remove spaces and special characters\n  return phone.replace(/[^0-9]/g, \"\");\n}\n\n// loop through object properties and check if any of them is empty\nexport function objectHasIncompleteData(obj: Record<string, unknown>) {\n  return false;\n  const optional_fields = [\"phone\", \"email\"];\n  for (const key in obj) {\n    if (\n      obj[key] === null ||\n      obj[key] === undefined ||\n      obj[key] === \"\" ||\n      (optional_fields.includes(key) && obj[key] === \"N/A\")\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function objectToString(obj: Record<string, any>): string {\n  return Object.entries(obj)\n    .map(([key, value]) => `${key.replaceAll(\"_\", \" \")}: ${value}`)\n    .join(\"\\n\");\n}\n\nexport function getMessageContentFromMessageType(props: {\n  type: MessageType;\n  submissionId?: string | number;\n  submissionData?: Submission;\n  toAdmin?: boolean;\n  content?: string;\n}) {\n  if (\n    props.toAdmin &&\n    props.submissionData &&\n    props.type === MessageType.SubmissionUploaded\n<|editable_region_end|>\n  ) {\n    return `You\u2019ve successfully submitted your song to Crux. We\u2019ll let you know as soon as your song is live and ready to share with your world. \\n\\n${process.env.NEXT_PUBLIC_SITE_URL}/dashboard/my-music/${props.submissionId}. \\n\\n${objectToString(props.submissionData as unknown as Record<string, string>)}`;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4801,6 +4801,7 @@\n         match &active_inline_completion.completion {\n             InlineCompletion::Move { target, .. } => {\n                 let target = *target;\n+                // Note that this is also done in \n                 self.change_selections(Some(Autoscroll::newest()), window, cx, |selections| {\n                     selections.select_anchor_ranges([target..target]);\n                 });\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4801,7 +4801,7 @@\n         match &active_inline_completion.completion {\n             InlineCompletion::Move { target, .. } => {\n                 let target = *target;\n-                // Note that this is also done in \n+                // Note that this is also done in vim's tab handler.\n                 self.change_selections(Some(Autoscroll::newest()), window, cx, |selections| {\n                     selections.select_anchor_ranges([target..target]);\n                 });\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4801,7 +4801,7 @@\n         match &active_inline_completion.completion {\n             InlineCompletion::Move { target, .. } => {\n                 let target = *target;\n-                // Note that this is also done in vim's tab handler.\n+                // Note that this is also done in vim's handler of the Tab action.\n                 self.change_selections(Some(Autoscroll::newest()), window, cx, |selections| {\n                     selections.select_anchor_ranges([target..target]);\n                 });\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```~/.rustup/toolchains/1.81-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs\n    pub fn push_within_capacity(&mut self, value: T) -> Result<(), T> {\n        if self.len == self.buf.capacity() {\n            return Err(value);\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n        Ok(())\n    }\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// If you'd like to pop the first element, consider using\n    /// [`VecDeque::pop_front`] instead.\n    ///\n    /// [`VecDeque::pop_front`]: crate::collections::VecDeque::pop_front\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n<|editable_region_start|>\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// Takes *O*(1) time.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn <|user_cursor_is_here|>pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                core::hint::assert_unchecked(self.len < self.capacity());\n                Some(ptr::read(self.as_ptr().add(self.len())))\n            }\n        }\n    }\n\n<|editable_region_end|>\n    /// Removes and returns the last element in a vector if the predicate\n    /// returns `true`, or [`None`] if the predicate returns false or the vector\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_pop_if)]\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// let pred = |x: &mut i32| *x % 2 == 0;\n    ///\n    /// assert_eq!(vec.pop_if(pred), Some(4));\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// assert_eq!(vec.pop_if(pred), None);\n    /// ```\n    #[unstable(feature = \"vec_pop_if\", issue = \"122741\")]\n    pub fn pop_if<F>(&mut self, f: F) -> Option<T>\n    where\n        F: FnOnce(&mut T) -> bool,\n    {\n        let last = self.last_mut()?;\n```"}, {"role": "assistant", "content": "Suggestion:\n```~/.rustup/toolchains/1.81-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs\n    pub fn push_within_capacity(&mut self, value: T) -> Result<(), T> {\n        if self.len == self.buf.capacity() {\n            return Err(value);\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n        Ok(())\n    }\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// If you'd like to pop the first element, consider using\n    /// [`VecDeque::pop_front`] instead.\n    ///\n    /// [`VecDeque::pop_front`]: crate::collections::VecDeque::pop_front\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n<|editable_region_start|>\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// Takes *O*(1) time.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                core::hint::assert_unchecked(self.len < self.capacity());\n                Some(ptr::read(self.as_ptr().add(self.len())))\n            }\n        }\n    }\n\n<|editable_region_end|>\n    /// Removes and returns the last element in a vector if the predicate\n    /// returns `true`, or [`None`] if the predicate returns false or the vector\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_pop_if)]\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// let pred = |x: &mut i32| *x % 2 == 0;\n    ///\n    /// assert_eq!(vec.pop_if(pred), Some(4));\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// assert_eq!(vec.pop_if(pred), None);\n    /// ```\n    #[unstable(feature = \"vec_pop_if\", issue = \"122741\")]\n    pub fn pop_if<F>(&mut self, f: F) -> Option<T>\n    where\n        F: FnOnce(&mut T) -> bool,\n    {\n        let last = self.last_mut()?;\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/diff/src/diff.rs\":\n```diff\n@@ -685,6 +685,7 @@\n         );\n \n         buffer.edit([(0..0, \"point five\\n\")]);\n+        \n         diff.update(&diff_base_rope, &buffer);\n         assert_hunks(\n             diff.hunks(&buffer),\n\n```\n\nUser edited \"crates/diff/src/diff.rs\":\n```diff\n@@ -685,7 +685,7 @@\n         );\n \n         buffer.edit([(0..0, \"point five\\n\")]);\n-        \n+        dif\n         diff.update(&diff_base_rope, &buffer);\n         assert_hunks(\n             diff.hunks(&buffer),\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/diff/src/diff.rs\n    use super::*;\n    use text::{Buffer, BufferId};\n<|editable_region_start|>\n    use unindent::Unindent as _;\n\n    #[test]\n    fn test_buffer_diff_simple() {\n        let diff_base = \"\n            one\n            two\n            three\n        \"\n        .unindent();\n        let diff_base_rope = Rope::from(diff_base.clone());\n\n        let buffer_text = \"\n            one\n            HELLO\n            three\n        \"\n        .unindent();\n\n        let mut buffer = Buffer::new(0, BufferId::new(1).unwrap(), buffer_text);\n        let mut diff = BufferDiffSnapshot::new(&buffer);\n        diff.update(&diff_base_rope, &buffer);\n        assert_hunks(\n            diff.hunks(&buffer),\n            &buffer,\n            &diff_base,\n            &[(1..2, \"two\\n\", \"HELLO\\n\")],\n        );\n\n        buffer.edit([(0..0, \"point five\\n\")]);\n        dif<|user_cursor_is_here|>\n        diff.update(&diff_base_rope, &buffer);\n        assert_hunks(\n            diff.hunks(&buffer),\n            &buffer,\n            &diff_base,\n            &[(0..1, \"\", \"point five\\n\"), (2..3, \"two\\n\", \"HELLO\\n\")],\n        );\n<|editable_region_end|>\n\n        diff.clear(&buffer);\n        assert_hunks(diff.hunks(&buffer), &buffer, &diff_base, &[]);\n    }\n\n    #[test]\n    fn test_buffer_diff_range() {\n        let diff_base = \"\n            one\n            two\n            three\n            four\n            five\n            six\n            seven\n            eight\n            nine\n            ten\n        \"\n        .unindent();\n        let diff_base_rope = Rope::from(diff_base.clone());\n\n        let buffer_text = \"\n            A\n            one\n            B\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/diff/src/diff.rs\n    use super::*;\n    use text::{Buffer, BufferId};\n<|editable_region_start|>\n    use unindent::Unindent as _;\n\n    #[test]\n    fn test_buffer_diff_simple() {\n        let diff_base = \"\n            one\n            two\n            three\n        \"\n        .unindent();\n        let diff_base_rope = Rope::from(diff_base.clone());\n\n        let buffer_text = \"\n            one\n            HELLO\n            three\n        \"\n        .unindent();\n\n        let mut buffer = Buffer::new(0, BufferId::new(1).unwrap(), buffer_text);\n        let mut diff = BufferDiffSnapshot::new(&buffer);\n        diff.update(&diff_base_rope, &buffer);\n        assert_hunks(\n            diff.hunks(&buffer),\n            &buffer,\n            &diff_base,\n            &[(1..2, \"two\\n\", \"HELLO\\n\")],\n        );\n\n        buffer.edit([(0..0, \"point five\\n\")]);\n        diff.\n        diff.update(&diff_base_rope, &buffer);\n        assert_hunks(\n            diff.hunks(&buffer),\n            &buffer,\n            &diff_base,\n            &[(0..1, \"\", \"point five\\n\"), (2..3, \"two\\n\", \"HELLO\\n\")],\n        );\n<|editable_region_end|>\n\n        diff.clear(&buffer);\n        assert_hunks(diff.hunks(&buffer), &buffer, &diff_base, &[]);\n    }\n\n    #[test]\n    fn test_buffer_diff_range() {\n        let diff_base = \"\n            one\n            two\n            three\n            four\n            five\n            six\n            seven\n            eight\n            nine\n            ten\n        \"\n        .unindent();\n        let diff_base_rope = Rope::from(diff_base.clone());\n\n        let buffer_text = \"\n            A\n            one\n            B\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -1,4 +1,5 @@\n pub mod image_info;\n+mod image_viewer_settings;\n \n use anyhow::Context as _;\n use editor::items::entry_git_aware_label_color;\n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -14,7 +14,6 @@\n use std::path::PathBuf;\n use theme::Theme;\n use ui::prelude::*;\n-\n use project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\n use settings::Settings;\n use util::paths::PathExt;\n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -22,6 +22,8 @@\n     ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n };\n \n+pub use crate::image\n+\n const IMAGE_VIEWER_KIND: &str = \"ImageView\";\n \n pub struct ImageView {\n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -22,7 +22,7 @@\n     ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n };\n \n-pub use crate::image\n+pub use crate::image_viewer_settings::\n \n const IMAGE_VIEWER_KIND: &str = \"ImageView\";\n \n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -11,18 +11,18 @@\n };\n use image_info::ImageViewerSettings;\n use persistence::IMAGE_VIEWER;\n+use project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\n+use settings::Settings;\n use std::path::PathBuf;\n use theme::Theme;\n use ui::prelude::*;\n-use project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\n-use settings::Settings;\n use util::paths::PathExt;\n use workspace::{\n     item::{BreadcrumbText, Item, ProjectItem, SerializableItem, TabContentParams},\n     ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n };\n \n-pub use crate::image_viewer_settings::\n+pub use crate::image_viewer_settings::*;\n \n const IMAGE_VIEWER_KIND: &str = \"ImageView\";\n \n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -9,7 +9,6 @@\n     EventEmitter, FocusHandle, Focusable, InteractiveElement, IntoElement, ObjectFit,\n     ParentElement, Render, Styled, Task, WeakEntity, Window,\n };\n-use image_info::ImageViewerSettings;\n use persistence::IMAGE_VIEWER;\n use project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\n use settings::Settings;\n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -1,4 +1,4 @@\n-pub mod image_info;\n+mod image_info;\n mod image_viewer_settings;\n \n use anyhow::Context as _;\n\n```\n\nUser edited \"crates/image_viewer/src/image_viewer.rs\":\n```diff\n@@ -21,6 +21,7 @@\n     ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n };\n \n+p\n pub use crate::image_viewer_settings::*;\n \n const IMAGE_VIEWER_KIND: &str = \"ImageView\";\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/image_viewer/src/image_viewer.rs\n<|start_of_file|>\nmod image_info;\nmod image_viewer_settings;\n\nuse anyhow::Context as _;\nuse editor::items::entry_git_aware_label_color;\nuse file_icons::FileIcons;\nuse gpui::{\n    canvas, div, fill, img, opaque_grey, point, size, AnyElement, App, Bounds, Context, Entity,\n    EventEmitter, FocusHandle, Focusable, InteractiveElement, IntoElement, ObjectFit,\n    ParentElement, Render, Styled, Task, WeakEntity, Window,\n};\nuse persistence::IMAGE_VIEWER;\n<|editable_region_start|>\nuse project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\nuse settings::Settings;\nuse std::path::PathBuf;\nuse theme::Theme;\nuse ui::prelude::*;\nuse util::paths::PathExt;\nuse workspace::{\n    item::{BreadcrumbText, Item, ProjectItem, SerializableItem, TabContentParams},\n    ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n};\n\np<|user_cursor_is_here|>\npub use crate::image_viewer_settings::*;\n\nconst IMAGE_VIEWER_KIND: &str = \"ImageView\";\n\npub struct ImageView {\n    image_item: Entity<ImageItem>,\n    project: Entity<Project>,\n    focus_handle: FocusHandle,\n}\n\nimpl ImageView {\n    pub fn new(\n        image_item: Entity<ImageItem>,\n        project: Entity<Project>,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        cx.subscribe(&image_item, Self::on_image_event).detach();\n        Self {\n            image_item,\n            project,\n            focus_handle: cx.focus_handle(),\n        }\n    }\n\n<|editable_region_end|>\n    fn on_image_event(\n        &mut self,\n        _: Entity<ImageItem>,\n        event: &ImageItemEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            ImageItemEvent::MetadataUpdated\n            | ImageItemEvent::FileHandleChanged\n            | ImageItemEvent::Reloaded => {\n                println!(\"Received event: {:?}\", event);\n                cx.emit(ImageViewEvent::TitleChanged);\n                cx.notify();\n            }\n            ImageItemEvent::ReloadNeeded => {}\n        }\n    }\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/image_viewer/src/image_viewer.rs\n<|start_of_file|>\nmod image_info;\nmod image_viewer_settings;\n\nuse anyhow::Context as _;\nuse editor::items::entry_git_aware_label_color;\nuse file_icons::FileIcons;\nuse gpui::{\n    canvas, div, fill, img, opaque_grey, point, size, AnyElement, App, Bounds, Context, Entity,\n    EventEmitter, FocusHandle, Focusable, InteractiveElement, IntoElement, ObjectFit,\n    ParentElement, Render, Styled, Task, WeakEntity, Window,\n};\nuse persistence::IMAGE_VIEWER;\n<|editable_region_start|>\nuse project::{image_store::ImageItemEvent, ImageItem, Project, ProjectPath};\nuse settings::Settings;\nuse std::path::PathBuf;\nuse theme::Theme;\nuse ui::prelude::*;\nuse util::paths::PathExt;\nuse workspace::{\n    item::{BreadcrumbText, Item, ProjectItem, SerializableItem, TabContentParams},\n    ItemId, ItemSettings, ToolbarItemLocation, Workspace, WorkspaceId,\n};\n\npub use crate::image_info::*;\npub use crate::image_viewer_settings::*;\n\nconst IMAGE_VIEWER_KIND: &str = \"ImageView\";\n\npub struct ImageView {\n    image_item: Entity<ImageItem>,\n    project: Entity<Project>,\n    focus_handle: FocusHandle,\n}\n\nimpl ImageView {\n    pub fn new(\n        image_item: Entity<ImageItem>,\n        project: Entity<Project>,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        cx.subscribe(&image_item, Self::on_image_event).detach();\n        Self {\n            image_item,\n            project,\n            focus_handle: cx.focus_handle(),\n        }\n    }\n\n<|editable_region_end|>\n    fn on_image_event(\n        &mut self,\n        _: Entity<ImageItem>,\n        event: &ImageItemEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            ImageItemEvent::MetadataUpdated\n            | ImageItemEvent::FileHandleChanged\n            | ImageItemEvent::Reloaded => {\n                println!(\"Received event: {:?}\", event);\n                cx.emit(ImageViewEvent::TitleChanged);\n                cx.notify();\n            }\n            ImageItemEvent::ReloadNeeded => {}\n        }\n    }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -2079,6 +2079,8 @@\n             image_store.open_image(path.into(), cx)\n         });\n \n+        dbg!(\"here\");\n+\n         let task = cx.spawn(move |_, mut cx| async move {\n             let image_item = image_task.await?;\n             let project = weak_project\n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -2082,6 +2082,7 @@\n         dbg!(\"here\");\n \n         let task = cx.spawn(move |_, mut cx| async move {\n+            \n             let image_item = image_task.await?;\n             let project = weak_project\n                 .upgrade()\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```zed/crates/project/src/project.rs\n            let mut remotely_created_models = self.remotely_created_models.lock();\n            if remotely_created_models.retain_count > 0 {\n                remotely_created_models.buffers.push(buffer.clone())\n            }\n        }\n\n        self.request_buffer_diff_recalculation(buffer, cx);\n\n        cx.subscribe(buffer, |this, buffer, event, cx| {\n            this.on_buffer_event(buffer, event, cx);\n        })\n        .detach();\n\n        Ok(())\n    }\n\n    pub fn open_image(\n        &mut self,\n        path: impl Into<ProjectPath>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<ImageItem>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        let weak_project = cx.entity().downgrade();\n        let image_task = self.image_store.update(cx, |image_store, cx| {\n            image_store.open_image(path.into(), cx)\n        });\n\n<|editable_region_start|>\n        dbg!(\"here\");\n\n        let task = cx.spawn(move |_, mut cx| async move {\n            <|user_cursor_is_here|>\n            let image_item = image_task.await?;\n            let project = weak_project\n                .upgrade()\n                .ok_or_else(|| anyhow!(\"Project dropped\"))?;\n\n            let metadata = ImageItem::image_info(image_item.clone(), project, &mut cx).await?;\n            image_item.update(&mut cx, |image_item, cx| {\n                image_item.image_metadata = Some(metadata);\n                cx.emit(ImageItemEvent::MetadataUpdated);\n            })?;\n\n            Ok(image_item)\n        });\n\n        task\n    }\n\n    async fn send_buffer_ordered_messages(\n        this: WeakEntity<Self>,\n        rx: UnboundedReceiver<BufferOrderedMessage>,\n<|editable_region_end|>\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        const MAX_BATCH_SIZE: usize = 128;\n\n        let mut operations_by_buffer_id = HashMap::default();\n        async fn flush_operations(\n            this: &WeakEntity<Project>,\n            operations_by_buffer_id: &mut HashMap<BufferId, Vec<proto::Operation>>,\n            needs_resync_with_host: &mut bool,\n            is_local: bool,\n            cx: &mut AsyncApp,\n        ) -> Result<()> {\n            for (buffer_id, operations) in operations_by_buffer_id.drain() {\n```"}, {"role": "assistant", "content": "Suggestion:\n```zed/crates/project/src/project.rs\n            let mut remotely_created_models = self.remotely_created_models.lock();\n            if remotely_created_models.retain_count > 0 {\n                remotely_created_models.buffers.push(buffer.clone())\n            }\n        }\n\n        self.request_buffer_diff_recalculation(buffer, cx);\n\n        cx.subscribe(buffer, |this, buffer, event, cx| {\n            this.on_buffer_event(buffer, event, cx);\n        })\n        .detach();\n\n        Ok(())\n    }\n\n    pub fn open_image(\n        &mut self,\n        path: impl Into<ProjectPath>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<ImageItem>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        let weak_project = cx.entity().downgrade();\n        let image_task = self.image_store.update(cx, |image_store, cx| {\n            image_store.open_image(path.into(), cx)\n        });\n\n<|editable_region_start|>\n        dbg!(\"here\");\n\n        let task = cx.spawn(move |_, mut cx| async move {\n            dbg!(\"here\");\n            let image_item = image_task.await?;\n            let project = weak_project\n                .upgrade()\n                .ok_or_else(|| anyhow!(\"Project dropped\"))?;\n\n            let metadata = ImageItem::image_info(image_item.clone(), project, &mut cx).await?;\n            image_item.update(&mut cx, |image_item, cx| {\n                image_item.image_metadata = Some(metadata);\n                cx.emit(ImageItemEvent::MetadataUpdated);\n            })?;\n\n            Ok(image_item)\n        });\n\n        task\n    }\n\n    async fn send_buffer_ordered_messages(\n        this: WeakEntity<Self>,\n        rx: UnboundedReceiver<BufferOrderedMessage>,\n<|editable_region_end|>\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        const MAX_BATCH_SIZE: usize = 128;\n\n        let mut operations_by_buffer_id = HashMap::default();\n        async fn flush_operations(\n            this: &WeakEntity<Project>,\n            operations_by_buffer_id: &mut HashMap<BufferId, Vec<proto::Operation>>,\n            needs_resync_with_host: &mut bool,\n            is_local: bool,\n            cx: &mut AsyncApp,\n        ) -> Result<()> {\n            for (buffer_id, operations) in operations_by_buffer_id.drain() {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"app/queries/recon.py\":\n```diff\n@@ -393,6 +393,7 @@\n     def download_recon_file(\n         cls, session: Session, org_id: str, recon_id: int\n     ) -> io.BytesIO:\n+        \n         job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()\n         storage = OrgStorage(org_id)\n         buffer = storage.download(job.result_location)  # type: ignore\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```app/queries/recon.py\n        for col in columns:\n            sub_df = df[col]\n            sub_a = sub_df[\"A\"]\n            sub_b = sub_df[\"B\"]\n            data.append(\n                ReconColumnData(\n                    field_name=col,\n                    value_a=list(sub_a),\n                    value_b=list(sub_b),\n                    matches=list(sub_a == sub_b),\n                )\n            )\n\n        return ReconDetails(\n            pk_name=job.config.pk_a.name, pk_data=list(df.index), fields=data\n        )\n<|editable_region_start|>\n\n    @classmethod\n    def patch_config(cls, session: Session, recon_id: int, patch: ReconPatch):\n        if patch.scheduled and patch.schedule is None:\n            raise HTTPException(\n                422,\n                [\n                    make_error(\n                        \"schedule\", \"schedule is required if schedule_run is true\"\n                    )\n                ],\n            )\n\n        if (\n            patch.scheduled\n            and patch.schedule\n            and not (re.match(r\"^\\d+[HD]$\", patch.schedule))\n        ):\n            raise HTTPException(\n                422,\n                [make_error(\"schedule\", \"schedule must be <number>D or <number>H\")],\n            )\n\n        config = cls._config_by_job_id(session, recon_id)\n        config.schedule = patch.scheduled\n        config.schedule_run = patch.schedule\n        session.commit()\n\n    @classmethod\n    def download_recon_file(\n        cls, session: Session, org_id: str, recon_id: int\n    ) -> io.BytesIO:\n        <|user_cursor_is_here|>\n        job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()\n        storage = OrgStorage(org_id)\n        buffer = storage.download(job.result_location)  # type: ignore\n        df = pd.read_parquet(buffer)\n        df.drop([\"_exclusive\"], axis=1, level=0, inplace=True)\n        buffer = io.BytesIO()\n        df.to_csv(buffer)\n        buffer.seek(0)\n        return buffer\n\n    @classmethod\n    def _config_by_job_id(cls, session: Session, recon_id: int) -> ReconConfig:\n        query = session.query(ReconJob).filter(ReconJob.id == recon_id)\n        result: ReconJob = query.one()\n        config: ReconConfig = result.config\n        return config\n\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```app/queries/recon.py\n        for col in columns:\n            sub_df = df[col]\n            sub_a = sub_df[\"A\"]\n            sub_b = sub_df[\"B\"]\n            data.append(\n                ReconColumnData(\n                    field_name=col,\n                    value_a=list(sub_a),\n                    value_b=list(sub_b),\n                    matches=list(sub_a == sub_b),\n                )\n            )\n\n        return ReconDetails(\n            pk_name=job.config.pk_a.name, pk_data=list(df.index), fields=data\n        )\n<|editable_region_start|>\n\n    @classmethod\n    def patch_config(cls, session: Session, recon_id: int, patch: ReconPatch):\n        if patch.scheduled and patch.schedule is None:\n            raise HTTPException(\n                422,\n                [\n                    make_error(\n                        \"schedule\", \"schedule is required if schedule_run is true\"\n                    )\n                ],\n            )\n\n        if (\n            patch.scheduled\n            and patch.schedule\n            and not (re.match(r\"^\\d+[HD]$\", patch.schedule))\n        ):\n            raise HTTPException(\n                422,\n                [make_error(\"schedule\", \"schedule must be <number>D or <number>H\")],\n            )\n\n        config = cls._config_by_job_id(session, recon_id)\n        config.schedule = patch.scheduled\n        config.schedule_run = patch.schedule\n        session.commit()\n\n    @classmethod\n    def download_recon_file(\n        cls, session: Session, org_id: str, recon_id: int\n    ) -> io.BytesIO:\n        \n        job: ReconJob = session.query(ReconJob).filter(ReconJob.id == recon_id).one()\n        storage = OrgStorage(org_id)\n        buffer = storage.download(job.result_location)  # type: ignore\n        df = pd.read_parquet(buffer)\n        df.drop([\"_exclusive\"], axis=1, level=0, inplace=True)\n        buffer = io.BytesIO()\n        df.to_csv(buffer)\n        buffer.seek(0)\n        return buffer\n\n    @classmethod\n    def _config_by_job_id(cls, session: Session, recon_id: int) -> ReconConfig:\n        query = session.query(ReconJob).filter(ReconJob.id == recon_id)\n        result: ReconJob = query.one()\n        config: ReconConfig = result.config\n        return config\n\n<|editable_region_end|>\n```"}]}
