{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/quicksort.rs\":\n\n```diff\n@@ -7,4 +7,5 @@\n     }\n\n     let pivot_index = partition(arr);\n+    \n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/quicksort.rs\nuse std::cmp::Ord;\n<|editable_region_start|>\n\npub fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n\n    let pivot_index = partition(arr);\n    <|user_cursor_is_here|>\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/quicksort.rs\nuse std::cmp::Ord;\n<|editable_region_start|>\n\npub fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n\n    let pivot_index = partition(arr);\n    quicksort(&mut arr[..pivot_index]);\n    quicksort(&mut arr[pivot_index..]);\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/quicksort.rs\":\n\n```diff\n@@ -6,4 +6,4 @@\n         return;\n     }\n\n-    let p\n+    let pivot = partit\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/quicksort.rs\nuse std::cmp::Ord;\n<|editable_region_start|>\n\npub fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n\n    let pivot = partit<|user_cursor_is_here|>\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/quicksort.rs\nuse std::cmp::Ord;\n<|editable_region_start|>\n\npub fn quicksort<T: Ord>(arr: &mut [T]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n\n    let pivot = partition(arr);\n}\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/quicksort.rs\":\n\n```diff\n@@ -1,2 +1,3 @@\n fn main() {\n+    thread::sleep(Duration::from_secs(1));\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/quicksort.rs\n<|start_of_file|>\n<|editable_region_start|>\nfn main() {<|user_cursor_is_here|>\n    thread::sleep(Duration::from_secs(1));\n}\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/quicksort.rs\n<|start_of_file|>\n<|editable_region_start|>\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::sleep(Duration::from_secs(1));\n}\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,4 +1,4 @@\n fn main() {\n-    let root_directory = \"/tmp\";\n+    let dir = \"/tmp\";\n     let glob_pattern = format!(\"{}/**/*.rs\", root_directory);\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"/tmp\";<|user_cursor_is_here|>\n    let glob_pattern = format!(\"{}/**/*.rs\", root_directory);\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"/tmp\";\n    let glob_pattern = format!(\"{}/**/*.rs\", dir);\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,3 +1,4 @@\n fn main() {\n+    let dir = \"/tmp\";\n     let glob_pattern = format!(\"{}/**/*.rs\", \"/tmp\");\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"/tmp\";<|user_cursor_is_here|>\n    let glob_pattern = format!(\"{}/**/*.rs\", \"/tmp\");\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"/tmp\";\n    let glob_pattern = format!(\"{}/**/*.rs\", dir);\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,3 +1,4 @@\n fn main() {\n+    let dir = \";\n     let glob_pattern = format!(\"{}/**/*.rs\", \"/tmp\");\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"<|user_cursor_is_here|>\n    let glob_pattern = format!(\"{}/**/*.rs\", \"/tmp\");\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let dir = \"/tmp\";\n    let glob_pattern = format!(\"{}/**/*.rs\", dir);\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,4 +1,6 @@\n fn main() {\n+    let args = std::env::args();\n+    let \n     let root_directory = \"/tmp\";\n     let glob_pattern = format!(\"{}/{}\", root_directory, \"**/*.rs\");\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let args = std::env::args();\n    let <|user_cursor_is_here|>\n    let root_directory = \"/tmp\";\n    let glob_pattern = format!(\"{}/{}\", root_directory, \"**/*.rs\");\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let args = std::env::args();\n    let root_directory = args.nth(1).unwrap_or_else(|| \"/tmp\".into());\n    let glob_pattern = format!(\"{}/{}\", root_directory, \"**/*.rs\");\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,5 +1,5 @@\n fn main() {\n-    let word = \"hello\";\n+    let words = vec![\"hello\";\n     for ch in word.chars() {\n         dbg!(ch);\n     }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let words = vec![<|user_cursor_is_here|>\"hello\";\n    for ch in word.chars() {\n        dbg!(ch);\n    }\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfn main() {\n<|editable_region_start|>\n    let words = vec![\"hello\"];\n    for word in words {\n        for ch in word.chars() {\n            dbg!(ch);\n        }\n    }\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -8,9 +8,10 @@\n \tc.state.Token = update.Token\n \tc.state.Endpoint = *update.Endpoint\n\n+\tgo fun\n \tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n \tdefer cancel()\n \tif err := c.gateway.Open(ctx, c.state); err != nil {\n-\t\tc.config.Logger.Error(\"error opening voice gateway\", slog.Any(\"err\", err))\n+\t\tc.config.Logger.Error(\"error opening voice gateway\", slog.Any(\"err\", err))\n \t}\n }\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nfunc (c *connImpl) HandleVoiceServerUpdate(update botgateway.EventVoiceServerUpdate) {\n<|editable_region_start|>\n\tc.stateMu.Lock()\n\tdefer c.stateMu.Unlock()\n\tif update.GuildID != c.state.GuildID || update.Endpoint == nil {\n\t\treturn\n\t}\n\n\tc.state.Token = update.Token\n\tc.state.Endpoint = *update.Endpoint\n\n\tgo fun<|user_cursor_is_here|>\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tif err := c.gateway.Open(ctx, c.state); err != nil {\n\t\tc.config.Logger.Error(\"error opening voice gateway\", slog.Any(\"err\", err))\n\t}\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nfunc (c *connImpl) HandleVoiceServerUpdate(update botgateway.EventVoiceServerUpdate) {\n<|editable_region_start|>\n\tc.stateMu.Lock()\n\tdefer c.stateMu.Unlock()\n\tif update.GuildID != c.state.GuildID || update.Endpoint == nil {\n\t\treturn\n\t}\n\n\tc.state.Token = update.Token\n\tc.state.Endpoint = *update.Endpoint\n\n\tgo func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\tif err := c.gateway.Open(ctx, c.state); err != nil {\n\t\t\tc.config.Logger.Error(\"error opening voice gateway\", slog.Any(\"err\", err))\n\t\t}\n\t}()\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,5 +1,5 @@\n struct Canvas {\n-    pixels: Vec<u8>,\n+    pub pixels: Vec<u8>,\n     stride: u8,\n     size: Size<u8>,\n     format: Format\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nstruct Canvas {\n<|editable_region_start|>\n    pub <|user_cursor_is_here|>pixels: Vec<u8>,\n    stride: u8,\n    size: Size<u8>,\n    format: Format\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nstruct Canvas {\n<|editable_region_start|>\n    pub pixels: Vec<u8>,\n    pub stride: u8,\n    pub size: Size<u8>,\n    pub format: Format\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,5 +1,5 @@\n struct Canvas {\n-    pub pixels: Vec<u8>,\n+    pixels: Vec<u8>,\n     pub stride: u8,\n     pub size: Size<u8>,\n     pub format: Format\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nstruct Canvas {\n<|editable_region_start|>\n    <|user_cursor_is_here|>pixels: Vec<u8>,\n    pub stride: u8,\n    pub size: Size<u8>,\n    pub format: Format\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nstruct Canvas {\n<|editable_region_start|>\n    pixels: Vec<u8>,\n    stride: u8,\n    size: Size<u8>,\n    format: Format\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"src/main.rs\":\n\n```diff\n@@ -1,6 +1,6 @@\n struct Element {\n     height: usize,\n-    width: usize,\n+    wedge: usize,\n     layout: Layout,\n     bg_color: Color,\n     fg_color: Color\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/main.rs\nstruct Element {\n<|editable_region_start|>\n    height: usize,\n    wedge<|user_cursor_is_here|>: usize,\n    layout: Layout,\n    bg_color: Color,\n    fg_color: Color\n}\n\nimpl Element {\n    fn height(&self) -> usize {\n        self.height\n    }\n\n    fn width(&self) -> usize {\n        self.width\n    }\n<|editable_region_end|>\n}\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/main.rs\nstruct Element {\n<|editable_region_start|>\n    height: usize,\n    wedge: usize,\n    layout: Layout,\n    bg_color: Color,\n    fg_color: Color\n}\n\nimpl Element {\n    fn height(&self) -> usize {\n        self.height\n    }\n\n    fn wedge(&self) -> usize {\n        self.wedge\n    }\n<|editable_region_end|>\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"crates/cli/src/main.rs\":\n\n```diff\n@@ -59,6 +59,8 @@\n     /// Run zed in dev-server mode\n     #[arg(long)]\n     dev_server_token: Option<String>,\n+    /// Only update the Zed instance\n+    \n }\n\n fn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/cli/src/main.rs\n    /// Use `path:line:row` syntax to open a file at a specific location.\n<|editable_region_start|>\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    paths_with_position: Vec<String>,\n    /// Print Zed's version and the app path.\n    #[arg(short, long)]\n    version: bool,\n    /// Run zed in the foreground (useful for debugging)\n    #[arg(long)]\n    foreground: bool,\n    /// Custom path to Zed.app or the zed binary\n    #[arg(long)]\n    zed: Option<PathBuf>,\n    /// Run zed in dev-server mode\n    #[arg(long)]\n    dev_server_token: Option<String>,\n    /// Only update the Zed instance\n    <|user_cursor_is_here|>\n}\n\nfn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n    let canonicalized = match Path::new(argument_str).canonicalize() {\n        Ok(existing_path) => PathWithPosition::from_path(existing_path),\n        Err(_) => {\n            let path = PathWithPosition::parse_str(argument_str);\n            let curdir = env::current_dir().context(\"reteiving current directory\")?;\n            path.map_path(|path| match fs::canonicalize(&path) {\n                Ok(path) => Ok(path),\n                Err(e) => {\n<|editable_region_end|>\n                    if let Some(mut parent) = path.parent() {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/cli/src/main.rs\n    /// Use `path:line:row` syntax to open a file at a specific location.\n<|editable_region_start|>\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    paths_with_position: Vec<String>,\n    /// Print Zed's version and the app path.\n    #[arg(short, long)]\n    version: bool,\n    /// Run zed in the foreground (useful for debugging)\n    #[arg(long)]\n    foreground: bool,\n    /// Custom path to Zed.app or the zed binary\n    #[arg(long)]\n    zed: Option<PathBuf>,\n    /// Run zed in dev-server mode\n    #[arg(long)]\n    dev_server_token: Option<String>,\n    /// Only update the Zed instance\n    #[arg(long)]\n    update: bool,\n}\n\nfn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n    let canonicalized = match Path::new(argument_str).canonicalize() {\n        Ok(existing_path) => PathWithPosition::from_path(existing_path),\n        Err(_) => {\n            let path = PathWithPosition::parse_str(argument_str);\n            let curdir = env::current_dir().context(\"reteiving current directory\")?;\n            path.map_path(|path| match fs::canonicalize(&path) {\n                Ok(path) => Ok(path),\n                Err(e) => {\n<|editable_region_end|>\n                    if let Some(mut parent) = path.parent() {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"crates/cli/src/main.rs\":\n\n```diff\n@@ -59,6 +59,8 @@\n     /// Run zed in dev-server mode\n     #[arg(long)]\n     dev_server_token: Option<String>,\n+    /// Only update the Zed instance\n+    \n }\n\n fn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n```\n\nUser edited file: \"crates/cli/src/main.rs\":\n\n```diff\n@@ -59,6 +59,8 @@\n     /// Run zed in dev-server mode\n     #[arg(long)]\n     dev_server_token: Option<String>,\n     /// Only update the Zed instance\n-    \n+    #[arg(long)]\n+    update: bool,\n }\n\n fn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n```\n\nUser edited file: \"crates/cli/src/main.rs\":\n\n```diff\n@@ -122,6 +122,8 @@\n         return Ok(());\n     }\n \n+    if\n+\n     let (server, server_name) =\n         IpcOneShotServer::<IpcHandshake>::new().context(\"Handshake before Zed spawn\")?;\n     let url = format!(\"zed-cli://{server_name}\");\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/cli/src/main.rs\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n<|editable_region_start|>\n    let args = flatpak::set_bin_if_no_escape(args);\n\n    let app = Detect::detect(args.zed.as_deref()).context(\"Bundle detection\")?;\n\n    if args.version {\n        println!(\"{}\", app.zed_version_string());\n        return Ok(());\n    }\n\n    if<|user_cursor_is_here|>\n\n    let (server, server_name) =\n        IpcOneShotServer::<IpcHandshake>::new().context(\"Handshake before Zed spawn\")?;\n    let url = format!(\"zed-cli://{server_name}\");\n\n    let open_new_workspace = if args.new {\n        Some(true)\n    } else if args.add {\n        Some(false)\n<|editable_region_end|>\n    } else {\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/cli/src/main.rs\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n<|editable_region_start|>\n    let args = flatpak::set_bin_if_no_escape(args);\n\n    let app = Detect::detect(args.zed.as_deref()).context(\"Bundle detection\")?;\n\n    if args.version {\n        println!(\"{}\", app.zed_version_string());\n        return Ok(());\n    }\n\n    if args.update {\n        \n    }\n\n    let (server, server_name) =\n        IpcOneShotServer::<IpcHandshake>::new().context(\"Handshake before Zed spawn\")?;\n    let url = format!(\"zed-cli://{server_name}\");\n\n    let open_new_workspace = if args.new {\n        Some(true)\n    } else if args.add {\n        Some(false)\n<|editable_region_end|>\n    } else {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n \tELSE     = \"ELSE\"\n \tRETURN   = \"RETURN\"\n \tMACRO    = \"MACRO\"\n+\tWHILE\n )\n\n type Token struct {\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```token/token.go\n\t// Keywords\n<|editable_region_start|>\n\tFUNCTION = \"FUNCTION\"\n\tLET      = \"LET\"\n\tTRUE     = \"TRUE\"\n\tFALSE    = \"FALSE\"\n\tIF       = \"IF\"\n\tELSE     = \"ELSE\"\n\tRETURN   = \"RETURN\"\n\tMACRO    = \"MACRO\"\n\tWHILE<|user_cursor_is_here|>\n)\n\ntype Token struct {\n\tType    TokenType\n\tLiteral string\n}\n\nvar keywords = map[string]TokenType{\n\t\"fn\":     FUNCTION,\n\t\"let\":    LET,\n\t\"true\":   TRUE,\n\t\"false\":  FALSE,\n<|editable_region_end|>\n\t\"if\":     IF,\n```"}, {"role": "assistant", "content": "Suggestion:\n```token/token.go\n\t// Keywords\n<|editable_region_start|>\n\tFUNCTION = \"FUNCTION\"\n\tLET      = \"LET\"\n\tTRUE     = \"TRUE\"\n\tFALSE    = \"FALSE\"\n\tIF       = \"IF\"\n\tELSE     = \"ELSE\"\n\tRETURN   = \"RETURN\"\n\tMACRO    = \"MACRO\"\n\tWHILE    = \"WHILE\"\n)\n\ntype Token struct {\n\tType    TokenType\n\tLiteral string\n}\n\nvar keywords = map[string]TokenType{\n\t\"fn\":     FUNCTION,\n\t\"let\":    LET,\n\t\"true\":   TRUE,\n\t\"false\":  FALSE,\n<|editable_region_end|>\n\t\"if\":     IF,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n \tELSE     = \"ELSE\"\n \tRETURN   = \"RETURN\"\n \tMACRO    = \"MACRO\"\n+\tWHILE\n )\n\n type Token struct {\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```token/token.go\n\t// Keywords\n<|editable_region_start|>\n\tFUNCTION = \"FUNCTION\"\n\tLET      = \"LET\"\n\tTRUE     = \"TRUE\"\n\tFALSE    = \"FALSE\"\n\tIF       = \"IF\"\n\tELSE     = \"ELSE\"\n\tRETURN   = \"RETURN\"\n\tMACRO    = \"MACRO\"\n\tWHILE<|user_cursor_is_here|>\n)\n\ntype Token struct {\n\tType    TokenType\n\tLiteral string\n}\n\nvar keywords = map[string]TokenType{\n\t\"fn\":     FUNCTION,\n\t\"let\":    LET,\n\t\"true\":   TRUE,\n\t\"false\":  FALSE,\n\t\"if\":     IF,\n\t\"else\":   ELSE,\n\t\"return\": RETURN,\n\t\"macro\":  MACRO,\n}\n<|editable_region_end|>\n\n```"}, {"role": "assistant", "content": "Suggestion:\n```token/token.go\n\t// Keywords\n<|editable_region_start|>\n\tFUNCTION = \"FUNCTION\"\n\tLET      = \"LET\"\n\tTRUE     = \"TRUE\"\n\tFALSE    = \"FALSE\"\n\tIF       = \"IF\"\n\tELSE     = \"ELSE\"\n\tRETURN   = \"RETURN\"\n\tMACRO    = \"MACRO\"\n\tWHILE    = \"WHILE\"\n)\n\ntype Token struct {\n\tType    TokenType\n\tLiteral string\n}\n\nvar keywords = map[string]TokenType{\n\t\"fn\":     FUNCTION,\n\t\"let\":    LET,\n\t\"true\":   TRUE,\n\t\"false\":  FALSE,\n\t\"if\":     IF,\n\t\"else\":   ELSE,\n\t\"return\": RETURN,\n\t\"macro\":  MACRO,\n\t\"while\":  WHILE,\n}\n<|editable_region_end|>\n\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n   \tELSE     = \"ELSE\"\n   \tRETURN   = \"RETURN\"\n   \tMACRO    = \"MACRO\"\n+  \tWHILE\n    )\n\n    type Token struct {\n```\n\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n   \tELSE     = \"ELSE\"\n   \tRETURN   = \"RETURN\"\n   \tMACRO    = \"MACRO\"\n+  \tWHILE    = \"WHILE\"\n    )\n\n    type Token struct {\n```\n\nUser edited file: \"ast/ast.go\":\n\n```diff\n@@ -49,6 +49,9 @@\n }\n \n // Statements\n+type WhileStatement struct {\n+\t\n+}\n type LetStatement struct {\n \tToken token.Token // the token.LET token\n \tName  *Identifier\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```ast/ast.go\n\t\tout.WriteString(s.String())\n<|editable_region_start|>\n\t}\n\n\treturn out.String()\n}\n\n// Statements\ntype WhileStatement struct {\n\t<|user_cursor_is_here|>\n}\ntype LetStatement struct {\n\tToken token.Token // the token.LET token\n\tName  *Identifier\n\tValue Expression\n}\n\nfunc (ls *LetStatement) statementNode()       {}\nfunc (ls *LetStatement) TokenLiteral() string { return ls.Token.Literal }\n<|editable_region_end|>\nfunc (ls *LetStatement) String() string {\n```"}, {"role": "assistant", "content": "Suggestion:\n```ast/ast.go\n\t\tout.WriteString(s.String())\n<|editable_region_start|>\n\t}\n\n\treturn out.String()\n}\n\n// Statements\ntype WhileStatement struct {\n\tToken      token.Token // the token.WHILE token\n\tCondition  Expression\n\tBody       BlockStatement\n}\n\ntype LetStatement struct {\n\tToken token.Token // the token.LET token\n\tName  *Identifier\n\tValue Expression\n}\n\nfunc (ls *LetStatement) statementNode()       {}\nfunc (ls *LetStatement) TokenLiteral() string { return ls.Token.Literal }\n<|editable_region_end|>\nfunc (ls *LetStatement) String() string {\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n   \tELSE     = \"ELSE\"\n   \tRETURN   = \"RETURN\"\n   \tMACRO    = \"MACRO\"\n+  \tWHILE\n    )\n\n    type Token struct {\n```\n\nUser edited file: \"token/token.go\":\n\n```diff\n@@ -46,6 +46,7 @@\n   \tELSE     = \"ELSE\"\n   \tRETURN   = \"RETURN\"\n   \tMACRO    = \"MACRO\"\n+  \tWHILE    = \"WHILE\"\n    )\n\n    type Token struct {\n```\n\nUser edited file: \"ast/ast.go\":\n\n```diff\n@@ -49,6 +49,9 @@\n }\n \n // Statements\n+type WhileStatement struct {\n+\t\n+}\n type LetStatement struct {\n \tToken token.Token // the token.LET token\n \tName  *Identifier\n```\n\nUser edited file: \"ast/ast.go\":\n\n```diff\n@@ -49,6 +49,9 @@\n }\n \n // Statements\n type WhileStatement struct {\n-\t\n+\tToken      token.Token // the token.WHILE token\n+\tCondition  Expression\n+\tBody       BlockStatement\n }\n\n type LetStatement struct {\n \tToken token.Token // the token.LET token\n \tName  *Identifier\n```\n\nUser edited file: \"parser/parser_test.go\":\n\n```diff\n@@ -8,6 +8,10 @@\n \t\"github.com/mrnugget/monkey/lexer\"\n )\n \n+func TestWhileStatements(t *testing.T) {\n+\t\n+}\n+\n func TestLetStatements(t *testing.T) {\n \ttests := []struct {\n \t\tinput              string\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```parser/parser_test.go\n<|start_of_file|>\npackage parser\n<|editable_region_start|>\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/mrnugget/monkey/ast\"\n\t\"github.com/mrnugget/monkey/lexer\"\n)\n\nfunc TestWhileStatements(t *testing.T) {\n\t<|user_cursor_is_here|>\n}\n\nfunc TestLetStatements(t *testing.T) {\n\ttests := []struct {\n<|editable_region_end|>\n\t\tinput              string"}, {"role": "assistant", "content": "Suggestion:\n```parser/parser_test.go\n<|start_of_file|>\npackage parser\n<|editable_region_start|>\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/mrnugget/monkey/ast\"\n\t\"github.com/mrnugget/monkey/lexer\"\n)\n\nfunc TestWhileStatements(t *testing.T) {\n\ttests := []struct {\n\t\tinput              string\n\t\texpectedCondition  string\n\t\texpectedBody       string\n\t}{\n\t\t{\"while (x < y) { x + 1; }\", \"(x < y)\", \"(x + 1)\"},\n\t\t{\"while (true) { 5; }\", \"true\", \"5\"},\n\t\t{\"while (false) { return 10; }\", \"false\", \"return 10;\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tl := lexer.New(tt.input)\n\t\tp := New(l)\n\t\tprogram := p.ParseProgram()\n\t\tcheckParserErrors(t, p)\n\n\t\tif len(program.Statements) != 1 {\n\t\t\tt.Fatalf(\"program.Statements does not contain 1 statement. got=%d\",\n\t\t\tlen(program.Statements))\n\t\t}\n\n\t\tstmt, ok := program.Statements[0].(*ast.ExpressionStatement)\n\t\tif !ok {\n\t  \tt.Fatalf(\"program.Statements[0] is not ast.ExpressionStatement. got=%T\",\n\t  \tprogram.Statements[0])\n\t\t}\n\n\t\twhileExp, ok := stmt.Expression.(*ast.WhileExpression)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"stmt.Expression is not ast.WhileExpression. got=%T\",\n\t\t\tstmt.Expression)\n\t\t}\n\n\t\tif whileExp.Condition.String() != tt.expectedCondition {\n\t\t\tt.Errorf(\"condition is not %q. got=%q\",\n\t\t\ttt.expectedCondition, whileExp.Condition.String())\n\t\t}\n\n\t\tif len(whileExp.Body.Statements) != 1 {\n\t\t\tt.Errorf(\"while body is not 1 statement. got=%d\\n\",\n\t\t\tlen(whileExp.Body.Statements))\n\t\t\tcontinue\n\t\t}\n\n\t\tif whileExp.Body.String() != tt.expectedBody {\n\t\t\tt.Errorf(\"body is not %q. got=%q\",\n\t\t\ttt.expectedBody, whileExp.Body.String())\n\t\t}\n\t}\n}\n\nfunc TestLetStatements(t *testing.T) {\n\ttests := []struct {\n<|editable_region_end|>\n\t\tinput              string"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -8,7 +8,7 @@\n \n use settings::Settings;\n use theme::ThemeSettings;\n-use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor, Tooltip};\n+use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor};\n use workspace::{ModalView, Workspace};\n \n actions!(\n@@ -154,6 +154,27 @@\n         cx.notify();\n     }\n \n+    fn thumbs_down(&mut self, _: &ThumbsDown, cx: &mut ViewContext<Self>) {\n+        self.zeta.update(cx, |zeta, cx| {\n+            let completion = zeta\n+                .recent_completions()\n+                .skip(self.selected_index)\n+                .next()\n+                .cloned();\n+\n+            if let Some(completion) = completion {\n+                zeta.rate_completion(\n+                    &completion,\n+                    InlineCompletionRating::Negative,\n+                    \"\".to_string(),\n+                    cx,\n+                );\n+            }\n+        });\n+        self.select_next_edit(&Default::default(), cx);\n+        cx.notify();\n+    }\n+\n     fn thumbs_up_active(&mut self, _: &ThumbsUpActiveCompletion, cx: &mut ViewContext<Self>) {\n         self.zeta.update(cx, |zeta, cx| {\n             if let Some(active) = &self.active_completion {\n@@ -178,20 +199,16 @@\n     }\n \n     fn thumbs_down_active(&mut self, _: &ThumbsDownActiveCompletion, cx: &mut ViewContext<Self>) {\n-        if let Some(active) = &self.active_completion {\n-            if active.feedback_editor.read(cx).text(cx).is_empty() {\n-                return;\n-            }\n-\n-            self.zeta.update(cx, |zeta, cx| {\n+        self.zeta.update(cx, |zeta, cx| {\n+            if let Some(active) = &self.active_completion {\n                 zeta.rate_completion(\n                     &active.completion,\n                     InlineCompletionRating::Negative,\n                     active.feedback_editor.read(cx).text(cx),\n                     cx,\n                 );\n-            });\n-        }\n+            }\n+        });\n \n         let current_completion = self\n             .active_completion\n@@ -275,7 +292,7 @@\n                 editor.set_show_wrap_guides(false, cx);\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n-                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n+                editor.set_placeholder_text(\"Add your feedback about this completion\u2026\", cx);\n                 if focus {\n                     cx.focus_self();\n                 }\n@@ -344,11 +361,6 @@\n         };\n \n         let rated = self.zeta.read(cx).is_completion_rated(completion_id);\n-        let feedback_empty = active_completion\n-            .feedback_editor\n-            .read(cx)\n-            .text(cx)\n-            .is_empty();\n \n         let border_color = cx.theme().colors().border;\n         let bg_color = cx.theme().colors().editor_background;\n@@ -418,12 +430,7 @@\n                                         .icon_size(IconSize::Small)\n                                         .icon_position(IconPosition::Start)\n                                         .icon_color(Color::Error)\n-                                        .disabled(rated || feedback_empty)\n-                                        .when(feedback_empty, |this| {\n-                                            this.tooltip(|cx| {\n-                                                Tooltip::text(\"Explain why this completion is bad before reporting it\", cx)\n-                                            })\n-                                        })\n+                                        .disabled(rated)\n                                         .on_click(cx.listener(move |this, _, cx| {\n                                             this.thumbs_down_active(\n                                                 &ThumbsDownActiveCompletion,\n@@ -468,6 +475,7 @@\n             .on_action(cx.listener(Self::select_first))\n             .on_action(cx.listener(Self::select_last))\n             .on_action(cx.listener(Self::thumbs_up))\n+            .on_action(cx.listener(Self::thumbs_down))\n             .on_action(cx.listener(Self::thumbs_up_active))\n             .on_action(cx.listener(Self::thumbs_down_active))\n             .on_action(cx.listener(Self::focus_completions))\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -6,9 +6,7 @@\n use client::Client;\n use collections::{HashMap, HashSet, VecDeque};\n use futures::AsyncReadExt;\n-use gpui::{\n-    actions, AppContext, Context, EntityId, Global, Model, ModelContext, Subscription, Task,\n-};\n+use gpui::{actions, AppContext, Context, Global, Model, ModelContext, Subscription, Task};\n use http_client::{HttpClient, Method};\n use language::{\n     language_settings::all_language_settings, Anchor, Buffer, BufferSnapshot, OffsetRangeExt,\n@@ -835,16 +833,11 @@\n             }\n         }\n     }\n-}\n-\n-struct CurrentInlineCompletion {\n-    buffer_id: EntityId,\n-    completion: InlineCompletion,\n }\n \n pub struct ZetaInlineCompletionProvider {\n     zeta: Model<Zeta>,\n-    current_completion: Option<CurrentInlineCompletion>,\n+    current_completion: Option<InlineCompletion>,\n     pending_refresh: Task<()>,\n }\n \n@@ -885,34 +878,28 @@\n         debounce: bool,\n         cx: &mut ModelContext<Self>,\n     ) {\n-        self.pending_refresh =\n-            cx.spawn(|this, mut cx| async move {\n-                if debounce {\n-                    cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n-                }\n+        self.pending_refresh = cx.spawn(|this, mut cx| async move {\n+            if debounce {\n+                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n+            }\n \n-                let completion_request = this.update(&mut cx, |this, cx| {\n-                    this.zeta.update(cx, |zeta, cx| {\n-                        zeta.request_completion(&buffer, position, cx)\n-                    })\n-                });\n+            let completion_request = this.update(&mut cx, |this, cx| {\n+                this.zeta.update(cx, |zeta, cx| {\n+                    zeta.request_completion(&buffer, position, cx)\n+                })\n+            });\n \n-                let mut completion = None;\n-                if let Ok(completion_request) = completion_request {\n-                    completion = completion_request.await.log_err().map(|completion| {\n-                        CurrentInlineCompletion {\n-                            buffer_id: buffer.entity_id(),\n-                            completion,\n-                        }\n-                    });\n-                }\n+            let mut completion = None;\n+            if let Ok(completion_request) = completion_request {\n+                completion = completion_request.await.log_err();\n+            }\n \n-                this.update(&mut cx, |this, cx| {\n-                    this.current_completion = completion;\n-                    cx.notify();\n-                })\n-                .ok();\n-            });\n+            this.update(&mut cx, |this, cx| {\n+                this.current_completion = completion;\n+                cx.notify();\n+            })\n+            .ok();\n+        });\n     }\n \n     fn cycle(\n@@ -937,16 +924,7 @@\n         cursor_position: language::Anchor,\n         cx: &mut ModelContext<Self>,\n     ) -> Option<inline_completion::InlineCompletion> {\n-        let CurrentInlineCompletion {\n-            buffer_id,\n-            completion,\n-        } = self.current_completion.as_mut()?;\n-\n-        // Invalidate previous completion if it was generated for a different buffer.\n-        if *buffer_id != buffer.entity_id() {\n-            self.current_completion.take();\n-            return None;\n-        }\n+        let completion = self.current_completion.as_mut()?;\n \n         let buffer = buffer.read(cx);\n         let Some(edits) = completion.interpolate(buffer.snapshot()) else {\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -6,7 +6,9 @@\n use client::Client;\n use collections::{HashMap, HashSet, VecDeque};\n use futures::AsyncReadExt;\n-use gpui::{actions, AppContext, Context, Global, Model, ModelContext, Subscription, Task};\n+use gpui::{\n+    actions, AppContext, Context, EntityId, Global, Model, ModelContext, Subscription, Task,\n+};\n use http_client::{HttpClient, Method};\n use language::{\n     language_settings::all_language_settings, Anchor, Buffer, BufferSnapshot, OffsetRangeExt,\n@@ -835,9 +837,14 @@\n     }\n }\n \n+struct CurrentInlineCompletion {\n+    buffer_id: EntityId,\n+    completion: InlineCompletion,\n+}\n+\n pub struct ZetaInlineCompletionProvider {\n     zeta: Model<Zeta>,\n-    current_completion: Option<InlineCompletion>,\n+    current_completion: Option<CurrentInlineCompletion>,\n     pending_refresh: Task<()>,\n }\n \n@@ -878,28 +885,34 @@\n         debounce: bool,\n         cx: &mut ModelContext<Self>,\n     ) {\n-        self.pending_refresh = cx.spawn(|this, mut cx| async move {\n-            if debounce {\n-                cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n-            }\n+        self.pending_refresh =\n+            cx.spawn(|this, mut cx| async move {\n+                if debounce {\n+                    cx.background_executor().timer(Self::DEBOUNCE_TIMEOUT).await;\n+                }\n+\n+                let completion_request = this.update(&mut cx, |this, cx| {\n+                    this.zeta.update(cx, |zeta, cx| {\n+                        zeta.request_completion(&buffer, position, cx)\n+                    })\n+                });\n+\n+                let mut completion = None;\n+                if let Ok(completion_request) = completion_request {\n+                    completion = completion_request.await.log_err().map(|completion| {\n+                        CurrentInlineCompletion {\n+                            buffer_id: buffer.entity_id(),\n+                            completion,\n+                        }\n+                    });\n+                }\n \n-            let completion_request = this.update(&mut cx, |this, cx| {\n-                this.zeta.update(cx, |zeta, cx| {\n-                    zeta.request_completion(&buffer, position, cx)\n+                this.update(&mut cx, |this, cx| {\n+                    this.current_completion = completion;\n+                    cx.notify();\n                 })\n+                .ok();\n             });\n-\n-            let mut completion = None;\n-            if let Ok(completion_request) = completion_request {\n-                completion = completion_request.await.log_err();\n-            }\n-\n-            this.update(&mut cx, |this, cx| {\n-                this.current_completion = completion;\n-                cx.notify();\n-            })\n-            .ok();\n-        });\n     }\n \n     fn cycle(\n@@ -924,7 +937,16 @@\n         cursor_position: language::Anchor,\n         cx: &mut ModelContext<Self>,\n     ) -> Option<inline_completion::InlineCompletion> {\n-        let completion = self.current_completion.as_mut()?;\n+        let CurrentInlineCompletion {\n+            buffer_id,\n+            completion,\n+        } = self.current_completion.as_mut()?;\n+\n+        // Invalidate previous completion if it was generated for a different buffer.\n+        if *buffer_id != buffer.entity_id() {\n+            self.current_completion.take();\n+            return None;\n+        }\n \n         let buffer = buffer.read(cx);\n         let Some(edits) = completion.interpolate(buffer.snapshot()) else {\n\n```\n\nUser edited \"assets/keymaps/default-macos.json\":\n```diff\n@@ -795,10 +795,9 @@\n     \"use_key_equivalents\": true,\n     \"bindings\": {\n       \"cmd-enter\": \"zeta::ThumbsUp\",\n-      \"cmd-delete\": \"zeta::ThumbsDown\",\n       \"shift-down\": \"zeta::NextEdit\",\n       \"shift-up\": \"zeta::PreviousEdit\",\n-      \"space\": \"zeta::PreviewCompletion\"\n+      \"right\": \"zeta::PreviewCompletion\"\n     }\n   },\n   {\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -8,7 +8,7 @@\n \n use settings::Settings;\n use theme::ThemeSettings;\n-use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor};\n+use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor, Tooltip};\n use workspace::{ModalView, Workspace};\n \n actions!(\n@@ -154,27 +154,6 @@\n         cx.notify();\n     }\n \n-    fn thumbs_down(&mut self, _: &ThumbsDown, cx: &mut ViewContext<Self>) {\n-        self.zeta.update(cx, |zeta, cx| {\n-            let completion = zeta\n-                .recent_completions()\n-                .skip(self.selected_index)\n-                .next()\n-                .cloned();\n-\n-            if let Some(completion) = completion {\n-                zeta.rate_completion(\n-                    &completion,\n-                    InlineCompletionRating::Negative,\n-                    \"\".to_string(),\n-                    cx,\n-                );\n-            }\n-        });\n-        self.select_next_edit(&Default::default(), cx);\n-        cx.notify();\n-    }\n-\n     fn thumbs_up_active(&mut self, _: &ThumbsUpActiveCompletion, cx: &mut ViewContext<Self>) {\n         self.zeta.update(cx, |zeta, cx| {\n             if let Some(active) = &self.active_completion {\n@@ -199,16 +178,20 @@\n     }\n \n     fn thumbs_down_active(&mut self, _: &ThumbsDownActiveCompletion, cx: &mut ViewContext<Self>) {\n-        self.zeta.update(cx, |zeta, cx| {\n-            if let Some(active) = &self.active_completion {\n+        if let Some(active) = &self.active_completion {\n+            if active.feedback_editor.read(cx).text(cx).is_empty() {\n+                return;\n+            }\n+\n+            self.zeta.update(cx, |zeta, cx| {\n                 zeta.rate_completion(\n                     &active.completion,\n                     InlineCompletionRating::Negative,\n                     active.feedback_editor.read(cx).text(cx),\n                     cx,\n                 );\n-            }\n-        });\n+            });\n+        }\n \n         let current_completion = self\n             .active_completion\n@@ -292,7 +275,7 @@\n                 editor.set_show_wrap_guides(false, cx);\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n-                editor.set_placeholder_text(\"Add your feedback about this completion\u2026\", cx);\n+                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n                 if focus {\n                     cx.focus_self();\n                 }\n@@ -361,6 +344,11 @@\n         };\n \n         let rated = self.zeta.read(cx).is_completion_rated(completion_id);\n+        let feedback_empty = active_completion\n+            .feedback_editor\n+            .read(cx)\n+            .text(cx)\n+            .is_empty();\n \n         let border_color = cx.theme().colors().border;\n         let bg_color = cx.theme().colors().editor_background;\n@@ -430,7 +418,12 @@\n                                         .icon_size(IconSize::Small)\n                                         .icon_position(IconPosition::Start)\n                                         .icon_color(Color::Error)\n-                                        .disabled(rated)\n+                                        .disabled(rated || feedback_empty)\n+                                        .when(feedback_empty, |this| {\n+                                            this.tooltip(|cx| {\n+                                                Tooltip::text(\"Explain why this completion is bad before reporting it\", cx)\n+                                            })\n+                                        })\n                                         .on_click(cx.listener(move |this, _, cx| {\n                                             this.thumbs_down_active(\n                                                 &ThumbsDownActiveCompletion,\n@@ -475,7 +468,6 @@\n             .on_action(cx.listener(Self::select_first))\n             .on_action(cx.listener(Self::select_last))\n             .on_action(cx.listener(Self::thumbs_up))\n-            .on_action(cx.listener(Self::thumbs_down))\n             .on_action(cx.listener(Self::thumbs_up_active))\n             .on_action(cx.listener(Self::thumbs_down_active))\n             .on_action(cx.listener(Self::focus_completions))\n\n```\n\nUser edited \"assets/keymaps/default-macos.json\":\n```diff\n@@ -795,9 +795,10 @@\n     \"use_key_equivalents\": true,\n     \"bindings\": {\n       \"cmd-enter\": \"zeta::ThumbsUp\",\n+      \"cmd-delete\": \"zeta::ThumbsDown\",\n       \"shift-down\": \"zeta::NextEdit\",\n       \"shift-up\": \"zeta::PreviousEdit\",\n-      \"right\": \"zeta::PreviewCompletion\"\n+      \"space\": \"zeta::PreviewCompletion\"\n     }\n   },\n   {\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -8,7 +8,7 @@\n \n use settings::Settings;\n use theme::ThemeSettings;\n-use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor, Tooltip};\n+use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor};\n use workspace::{ModalView, Workspace};\n \n actions!(\n@@ -154,6 +154,27 @@\n         cx.notify();\n     }\n \n+    fn thumbs_down(&mut self, _: &ThumbsDown, cx: &mut ViewContext<Self>) {\n+        self.zeta.update(cx, |zeta, cx| {\n+            let completion = zeta\n+                .recent_completions()\n+                .skip(self.selected_index)\n+                .next()\n+                .cloned();\n+\n+            if let Some(completion) = completion {\n+                zeta.rate_completion(\n+                    &completion,\n+                    InlineCompletionRating::Negative,\n+                    \"\".to_string(),\n+                    cx,\n+                );\n+            }\n+        });\n+        self.select_next_edit(&Default::default(), cx);\n+        cx.notify();\n+    }\n+\n     fn thumbs_up_active(&mut self, _: &ThumbsUpActiveCompletion, cx: &mut ViewContext<Self>) {\n         self.zeta.update(cx, |zeta, cx| {\n             if let Some(active) = &self.active_completion {\n@@ -178,20 +199,16 @@\n     }\n \n     fn thumbs_down_active(&mut self, _: &ThumbsDownActiveCompletion, cx: &mut ViewContext<Self>) {\n-        if let Some(active) = &self.active_completion {\n-            if active.feedback_editor.read(cx).text(cx).is_empty() {\n-                return;\n-            }\n-\n-            self.zeta.update(cx, |zeta, cx| {\n+        self.zeta.update(cx, |zeta, cx| {\n+            if let Some(active) = &self.active_completion {\n                 zeta.rate_completion(\n                     &active.completion,\n                     InlineCompletionRating::Negative,\n                     active.feedback_editor.read(cx).text(cx),\n                     cx,\n                 );\n-            });\n-        }\n+            }\n+        });\n \n         let current_completion = self\n             .active_completion\n@@ -275,7 +292,7 @@\n                 editor.set_show_wrap_guides(false, cx);\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n-                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n+                editor.set_placeholder_text(\"Add your feedback about this completion\u2026\", cx);\n                 if focus {\n                     cx.focus_self();\n                 }\n@@ -344,11 +361,6 @@\n         };\n \n         let rated = self.zeta.read(cx).is_completion_rated(completion_id);\n-        let feedback_empty = active_completion\n-            .feedback_editor\n-            .read(cx)\n-            .text(cx)\n-            .is_empty();\n \n         let border_color = cx.theme().colors().border;\n         let bg_color = cx.theme().colors().editor_background;\n@@ -418,12 +430,7 @@\n                                         .icon_size(IconSize::Small)\n                                         .icon_position(IconPosition::Start)\n                                         .icon_color(Color::Error)\n-                                        .disabled(rated || feedback_empty)\n-                                        .when(feedback_empty, |this| {\n-                                            this.tooltip(|cx| {\n-                                                Tooltip::text(\"Explain why this completion is bad before reporting it\", cx)\n-                                            })\n-                                        })\n+                                        .disabled(rated)\n                                         .on_click(cx.listener(move |this, _, cx| {\n                                             this.thumbs_down_active(\n                                                 &ThumbsDownActiveCompletion,\n@@ -468,6 +475,7 @@\n             .on_action(cx.listener(Self::select_first))\n             .on_action(cx.listener(Self::select_last))\n             .on_action(cx.listener(Self::thumbs_up))\n+            .on_action(cx.listener(Self::thumbs_down))\n             .on_action(cx.listener(Self::thumbs_up_active))\n             .on_action(cx.listener(Self::thumbs_down_active))\n             .on_action(cx.listener(Self::focus_completions))\n\n```\n\nUser edited \"assets/keymaps/default-macos.json\":\n```diff\n@@ -795,10 +795,9 @@\n     \"use_key_equivalents\": true,\n     \"bindings\": {\n       \"cmd-enter\": \"zeta::ThumbsUp\",\n-      \"cmd-delete\": \"zeta::ThumbsDown\",\n       \"shift-down\": \"zeta::NextEdit\",\n       \"shift-up\": \"zeta::PreviousEdit\",\n-      \"space\": \"zeta::PreviewCompletion\"\n+      \"right\": \"zeta::PreviewCompletion\"\n     }\n   },\n   {\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -8,7 +8,7 @@\n \n use settings::Settings;\n use theme::ThemeSettings;\n-use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor};\n+use ui::{prelude::*, List, ListItem, ListItemSpacing, TintColor, Tooltip};\n use workspace::{ModalView, Workspace};\n \n actions!(\n@@ -154,27 +154,6 @@\n         cx.notify();\n     }\n \n-    fn thumbs_down(&mut self, _: &ThumbsDown, cx: &mut ViewContext<Self>) {\n-        self.zeta.update(cx, |zeta, cx| {\n-            let completion = zeta\n-                .recent_completions()\n-                .skip(self.selected_index)\n-                .next()\n-                .cloned();\n-\n-            if let Some(completion) = completion {\n-                zeta.rate_completion(\n-                    &completion,\n-                    InlineCompletionRating::Negative,\n-                    \"\".to_string(),\n-                    cx,\n-                );\n-            }\n-        });\n-        self.select_next_edit(&Default::default(), cx);\n-        cx.notify();\n-    }\n-\n     fn thumbs_up_active(&mut self, _: &ThumbsUpActiveCompletion, cx: &mut ViewContext<Self>) {\n         self.zeta.update(cx, |zeta, cx| {\n             if let Some(active) = &self.active_completion {\n@@ -199,16 +178,20 @@\n     }\n \n     fn thumbs_down_active(&mut self, _: &ThumbsDownActiveCompletion, cx: &mut ViewContext<Self>) {\n-        self.zeta.update(cx, |zeta, cx| {\n-            if let Some(active) = &self.active_completion {\n+        if let Some(active) = &self.active_completion {\n+            if active.feedback_editor.read(cx).text(cx).is_empty() {\n+                return;\n+            }\n+\n+            self.zeta.update(cx, |zeta, cx| {\n                 zeta.rate_completion(\n                     &active.completion,\n                     InlineCompletionRating::Negative,\n                     active.feedback_editor.read(cx).text(cx),\n                     cx,\n                 );\n-            }\n-        });\n+            });\n+        }\n \n         let current_completion = self\n             .active_completion\n@@ -292,7 +275,7 @@\n                 editor.set_show_wrap_guides(false, cx);\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n-                editor.set_placeholder_text(\"Add your feedback about this completion\u2026\", cx);\n+                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n                 if focus {\n                     cx.focus_self();\n                 }\n@@ -361,6 +344,11 @@\n         };\n \n         let rated = self.zeta.read(cx).is_completion_rated(completion_id);\n+        let feedback_empty = active_completion\n+            .feedback_editor\n+            .read(cx)\n+            .text(cx)\n+            .is_empty();\n \n         let border_color = cx.theme().colors().border;\n         let bg_color = cx.theme().colors().editor_background;\n@@ -430,7 +418,12 @@\n                                         .icon_size(IconSize::Small)\n                                         .icon_position(IconPosition::Start)\n                                         .icon_color(Color::Error)\n-                                        .disabled(rated)\n+                                        .disabled(rated || feedback_empty)\n+                                        .when(feedback_empty, |this| {\n+                                            this.tooltip(|cx| {\n+                                                Tooltip::text(\"Explain why this completion is bad before reporting it\", cx)\n+                                            })\n+                                        })\n                                         .on_click(cx.listener(move |this, _, cx| {\n                                             this.thumbs_down_active(\n                                                 &ThumbsDownActiveCompletion,\n@@ -475,7 +468,6 @@\n             .on_action(cx.listener(Self::select_first))\n             .on_action(cx.listener(Self::select_last))\n             .on_action(cx.listener(Self::thumbs_up))\n-            .on_action(cx.listener(Self::thumbs_down))\n             .on_action(cx.listener(Self::thumbs_up_active))\n             .on_action(cx.listener(Self::thumbs_down_active))\n             .on_action(cx.listener(Self::focus_completions))\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,6 +273,7 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n+                editor.set\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/zeta/src/rate_completion_modal.rs\n                        cx.focus_view(&prev_completion.feedback_editor);\n<|editable_region_start|>\n                    }\n                    return;\n                }\n            }\n        }\n\n        self.active_completion = completion.map(|completion| ActiveCompletion {\n            completion,\n            feedback_editor: cx.new_view(|cx| {\n                let mut editor = Editor::multi_line(cx);\n                editor.set_soft_wrap_mode(language_settings::SoftWrap::EditorWidth, cx);\n                editor.set_show_line_numbers(false, cx);\n                editor.set_show_git_diff_gutter(false, cx);\n                editor.set_show_code_actions(false, cx);\n                editor.set_show_runnables(false, cx);\n                editor.set_show_wrap_guides(false, cx);\n                editor.set<|user_cursor_is_here|>\n                editor.set_show_indent_guides(false, cx);\n                editor.set_show_inline_completions(Some(false), cx);\n                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n                if focus {\n                    cx.focus_self();\n                }\n                editor\n            }),\n        });\n        cx.notify();\n    }\n\n    fn render_active_completion(&mut self, cx: &mut ViewContext<Self>) -> Option<impl IntoElement> {\n        let active_completion = self.active_completion.as_ref()?;\n        let completion_id = active_completion.completion.id;\n\n<|editable_region_end|>\n        let mut diff = active_completion\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/zeta/src/rate_completion_modal.rs\n                        cx.focus_view(&prev_completion.feedback_editor);\n<|editable_region_start|>\n                    }\n                    return;\n                }\n            }\n        }\n\n        self.active_completion = completion.map(|completion| ActiveCompletion {\n            completion,\n            feedback_editor: cx.new_view(|cx| {\n                let mut editor = Editor::multi_line(cx);\n                editor.set_soft_wrap_mode(language_settings::SoftWrap::EditorWidth, cx);\n                editor.set_show_line_numbers(false, cx);\n                editor.set_show_git_diff_gutter(false, cx);\n                editor.set_show_code_actions(false, cx);\n                editor.set_show_runnables(false, cx);\n                editor.set_show_wrap_guides(false, cx);\n                editor.set\n                editor.set_show_indent_guides(false, cx);\n                editor.set_show_inline_completions(Some(false), cx);\n                editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n                if focus {\n                    cx.focus_self();\n                }\n                editor\n            }),\n        });\n        cx.notify();\n    }\n\n    fn render_active_completion(&mut self, cx: &mut ViewContext<Self>) -> Option<impl IntoElement> {\n        let active_completion = self.active_completion.as_ref()?;\n        let completion_id = active_completion.completion.id;\n\n<|editable_region_end|>\n        let mut diff = active_completion\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,6 +273,7 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n+                editor.set\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,7 +273,7 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n-                editor.set\n+                editor.set_show\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,7 +273,7 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n-                editor.set_show\n+                editor.set_show_\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,7 +273,7 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n-                editor.set_show_\n+                editor.set_show_w\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -273,7 +273,6 @@\n                 editor.set_show_code_actions(false, cx);\n                 editor.set_show_runnables(false, cx);\n                 editor.set_show_wrap_guides(false, cx);\n-                editor.set_show_w\n                 editor.set_show_indent_guides(false, cx);\n                 editor.set_show_inline_completions(Some(false), cx);\n                 editor.set_placeholder_text(\"Add your feedback about this completion\u2026 (Negative feedback requires an explanation for why it was bad, and what you expected instead.)\", cx);\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -288,6 +288,8 @@\n     fn render_active_completion(&mut self, cx: &mut ViewContext<Self>) -> Option<impl IntoElement> {\n         let active_completion = self.active_completion.as_ref()?;\n         let completion_id = active_completion.completion.id;\n+        \n+        let \n \n         let mut diff = active_completion\n             .completion\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -289,8 +289,6 @@\n         let active_completion = self.active_completion.as_ref()?;\n         let completion_id = active_completion.completion.id;\n         \n-        let \n-\n         let mut diff = active_completion\n             .completion\n             .snapshot\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -289,6 +289,7 @@\n         let active_completion = self.active_completion.as_ref()?;\n         let completion_id = active_completion.completion.id;\n         \n+        let \n         let mut diff = active_completion\n             .completion\n             .snapshot\n\n```\n\nUser edited \"crates/zeta/src/rate_completion_modal.rs\":\n```diff\n@@ -289,7 +289,6 @@\n         let active_completion = self.active_completion.as_ref()?;\n         let completion_id = active_completion.completion.id;\n         \n-        let \n         let mut diff = active_completion\n             .completion\n             .snapshot\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4629,8 +4629,7 @@\n         let offset_selection = selection.map(|endpoint| endpoint.to_offset(&multibuffer));\n         let excerpt_id = cursor.excerpt_id;\n \n-        if self.context_menu.read().is_some()\n-            || (!self.completion_tasks.is_empty() && !self.has_active_inline_completion())\n+        if \n             || !offset_selection.is_empty()\n             || self\n                 .active_inline_completion\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/editor.rs\n    fn take_active_inline_completion(\n<|editable_region_start|>\n        &mut self,\n        cx: &mut ViewContext<Self>,\n    ) -> Option<InlineCompletion> {\n        let active_inline_completion = self.active_inline_completion.take()?;\n        self.splice_inlays(active_inline_completion.inlay_ids, Default::default(), cx);\n        self.clear_highlights::<InlineCompletionHighlight>(cx);\n        Some(active_inline_completion.completion)\n    }\n\n    fn update_visible_inline_completion(&mut self, cx: &mut ViewContext<Self>) -> Option<()> {\n        let selection = self.selections.newest_anchor();\n        let cursor = selection.head();\n        let multibuffer = self.buffer.read(cx).snapshot(cx);\n        let offset_selection = selection.map(|endpoint| endpoint.to_offset(&multibuffer));\n        let excerpt_id = cursor.excerpt_id;\n\n        if <|user_cursor_is_here|>\n            || !offset_selection.is_empty()\n            || self\n                .active_inline_completion\n                .as_ref()\n                .map_or(false, |completion| {\n                    let invalidation_range = completion.invalidation_range.to_offset(&multibuffer);\n                    let invalidation_range = invalidation_range.start..=invalidation_range.end;\n                    !invalidation_range.contains(&offset_selection.head())\n                })\n        {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        self.take_active_inline_completion(cx);\n        let provider = self.inline_completion_provider()?;\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/editor.rs\n    fn take_active_inline_completion(\n<|editable_region_start|>\n        &mut self,\n        cx: &mut ViewContext<Self>,\n    ) -> Option<InlineCompletion> {\n        let active_inline_completion = self.active_inline_completion.take()?;\n        self.splice_inlays(active_inline_completion.inlay_ids, Default::default(), cx);\n        self.clear_highlights::<InlineCompletionHighlight>(cx);\n        Some(active_inline_completion.completion)\n    }\n\n    fn update_visible_inline_completion(&mut self, cx: &mut ViewContext<Self>) -> Option<()> {\n        let selection = self.selections.newest_anchor();\n        let cursor = selection.head();\n        let multibuffer = self.buffer.read(cx).snapshot(cx);\n        let offset_selection = selection.map(|endpoint| endpoint.to_offset(&multibuffer));\n        let excerpt_id = cursor.excerpt_id;\n\n        if !offset_selection.is_empty()\n            || self\n                .active_inline_completion\n                .as_ref()\n                .map_or(false, |completion| {\n                    let invalidation_range = completion.invalidation_range.to_offset(&multibuffer);\n                    let invalidation_range = invalidation_range.start..=invalidation_range.end;\n                    !invalidation_range.contains(&offset_selection.head())\n                })\n        {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        self.take_active_inline_completion(cx);\n        let provider = self.inline_completion_provider()?;\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"untitled\":\n```diff\n@@ -12,7 +12,7 @@\n \n * [ ] [@conrad @max] DiffMap rewrite\n * [ ] [@mikayla @cole] Git status entries\n-* [*] [@kirill @michael] Spike on creating a commit\n+* [*] [@kirill] Spike on creating a commit\n \n ## Exigencies\n \n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,6 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n+        let mut diff_cursor\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,7 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor\n+        let mut diff_cursor = self.diff\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,7 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor = self.diff\n+        let mut diff_cursor = self.diff_transforms.\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4206,6 +4206,7 @@\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n         let mut diff_cursor = self.diff_transforms.\n+            \n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,8 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor = self.diff_transforms.\n-            \n+        let mut diff_cursor = self.diff_transforms.cursor::<DiffSummary>(&());\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,7 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor = self.diff_transforms.cursor::<DiffSummary>(&());\n+        let mut diff_cursor = self.diff_transforms.cursor::<Diff>(&());\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,7 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor = self.diff_transforms.cursor::<Diff>(&());\n+        let mut diff_cursor = self.diff_transforms.cursor::<Difftsu<D>>(&());\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -4205,7 +4205,7 @@\n     {\n         let mut anchors = anchors.into_iter().peekable();\n         let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let mut diff_cursor = self.diff_transforms.cursor::<Difftsu<D>>(&());\n+        let mut diff_cursor = self.diff_transforms.cursor::<Difft>(&());\n         let mut summaries = Vec::new();\n         while let Some(anchor) = anchors.peek() {\n             let excerpt_id = anchor.excerpt_id;\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/multi_buffer/src/multi_buffer.rs\n<|editable_region_start|>\n        cursor.seek(&Some(locator), Bias::Left, &());\n        if cursor.item().is_none() {\n            cursor.next(&());\n        }\n\n        let mut position = cursor.start().1;\n        if let Some(excerpt) = cursor.item() {\n            if excerpt.id == anchor.excerpt_id {\n                let excerpt_buffer_start = excerpt\n                    .buffer\n                    .offset_for_anchor(&excerpt.range.context.start);\n                let excerpt_buffer_end =\n                    excerpt.buffer.offset_for_anchor(&excerpt.range.context.end);\n                let buffer_position = cmp::min(\n                    excerpt_buffer_end,\n                    excerpt.buffer.offset_for_anchor(&anchor.text_anchor),\n                );\n                if buffer_position > excerpt_buffer_start {\n                    position += buffer_position - excerpt_buffer_start;\n                }\n            }\n        }\n        ExcerptOffset::new(position)\n    }\n\n    pub fn summaries_for_anchors<'a, D, I>(&'a self, anchors: I) -> Vec<D>\n    where\n        D: TextDimension + Ord + Sub<D, Output = D>,\n        I: 'a + IntoIterator<Item = &'a Anchor>,\n    {\n        let mut anchors = anchors.into_iter().peekable();\n        let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n        let mut diff_cursor = self.diff_transforms.cursor::<Difft<|user_cursor_is_here|>>(&());\n        let mut summaries = Vec::new();\n        while let Some(anchor) = anchors.peek() {\n            let excerpt_id = anchor.excerpt_id;\n            let excerpt_anchors = iter::from_fn(|| {\n                let anchor = anchors.peek()?;\n                if anchor.excerpt_id == excerpt_id {\n                    Some(&anchors.next().unwrap().text_anchor)\n                } else {\n                    None\n                }\n            });\n\n            let locator = self.excerpt_locator_for_id(excerpt_id);\n            cursor.seek_forward(locator, Bias::Left, &());\n            if cursor.item().is_none() {\n                cursor.next(&());\n            }\n\n            let position = D::from_text_summary(&cursor.start().text);\n            if let Some(excerpt) = cursor.item() {\n                if excerpt.id == excerpt_id {\n                    let excerpt_buffer_start =\n                        excerpt.range.context.start.summary::<D>(&excerpt.buffer);\n                    let excerpt_buffer_end =\n                        excerpt.range.context.end.summary::<D>(&excerpt.buffer);\n                    summaries.extend(\n                        excerpt\n                            .buffer\n                            .summaries_for_anchors::<D, _>(excerpt_anchors)\n                            .map(move |summary| {\n                                let summary = cmp::min(excerpt_buffer_end.clone(), summary);\n                                let mut position = position.clone();\n<|editable_region_end|>\n                                let excerpt_buffer_start = excerpt_buffer_start.clone();\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/multi_buffer/src/multi_buffer.rs\n<|editable_region_start|>\n        cursor.seek(&Some(locator), Bias::Left, &());\n        if cursor.item().is_none() {\n            cursor.next(&());\n        }\n\n        let mut position = cursor.start().1;\n        if let Some(excerpt) = cursor.item() {\n            if excerpt.id == anchor.excerpt_id {\n                let excerpt_buffer_start = excerpt\n                    .buffer\n                    .offset_for_anchor(&excerpt.range.context.start);\n                let excerpt_buffer_end =\n                    excerpt.buffer.offset_for_anchor(&excerpt.range.context.end);\n                let buffer_position = cmp::min(\n                    excerpt_buffer_end,\n                    excerpt.buffer.offset_for_anchor(&anchor.text_anchor),\n                );\n                if buffer_position > excerpt_buffer_start {\n                    position += buffer_position - excerpt_buffer_start;\n                }\n            }\n        }\n        ExcerptOffset::new(position)\n    }\n\n    pub fn summaries_for_anchors<'a, D, I>(&'a self, anchors: I) -> Vec<D>\n    where\n        D: TextDimension + Ord + Sub<D, Output = D>,\n        I: 'a + IntoIterator<Item = &'a Anchor>,\n    {\n        let mut anchors = anchors.into_iter().peekable();\n        let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n        let mut diff_cursor = self.diff_transforms.cursor::<DiffTransformSummary>(&());\n        let mut summaries = Vec::new();\n        while let Some(anchor) = anchors.peek() {\n            let excerpt_id = anchor.excerpt_id;\n            let excerpt_anchors = iter::from_fn(|| {\n                let anchor = anchors.peek()?;\n                if anchor.excerpt_id == excerpt_id {\n                    Some(&anchors.next().unwrap().text_anchor)\n                } else {\n                    None\n                }\n            });\n\n            let locator = self.excerpt_locator_for_id(excerpt_id);\n            cursor.seek_forward(locator, Bias::Left, &());\n            if cursor.item().is_none() {\n                cursor.next(&());\n            }\n\n            let position = D::from_text_summary(&cursor.start().text);\n            if let Some(excerpt) = cursor.item() {\n                if excerpt.id == excerpt_id {\n                    let excerpt_buffer_start =\n                        excerpt.range.context.start.summary::<D>(&excerpt.buffer);\n                    let excerpt_buffer_end =\n                        excerpt.range.context.end.summary::<D>(&excerpt.buffer);\n                    summaries.extend(\n                        excerpt\n                            .buffer\n                            .summaries_for_anchors::<D, _>(excerpt_anchors)\n                            .map(move |summary| {\n                                let summary = cmp::min(excerpt_buffer_end.clone(), summary);\n                                let mut position = position.clone();\n<|editable_region_end|>\n                                let excerpt_buffer_start = excerpt_buffer_start.clone();\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -180,7 +180,7 @@\n                 })\n             })?;\n \n-            cx.new_view(|cx| {\n+            cx.new_view(|window, cx| {\n                 let mut this = Self::new(\n                     project,\n                     weak_workspace,\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -205,7 +205,7 @@\n     ) -> Self {\n         let buffer = channel_buffer.read(cx).buffer();\n         let this = cx.view().downgrade();\n-        let editor = window.new_view(cx, |cx| {\n+        let editor = window.new_view(cx, |window, cx| {\n             let mut editor = Editor::for_buffer(buffer, None, window, cx);\n             editor.set_collaboration_hub(Box::new(ChannelBufferCollaborationHub(\n                 channel_buffer.clone(),\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -347,7 +347,7 @@\n \n     fn handle_channel_buffer_event(\n         &mut self,\n-        _: Model<ChannelBuffer>,\n+        _: &Model<ChannelBuffer>,\n         event: &ChannelBufferEvent,\n         window: &mut Window,\n         cx: &mut ModelContext<Self>,\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -437,7 +437,7 @@\n         }\n     }\n \n-    fn tab_icon(&self, window: &mut Window, cx: &mut AppContext) -> Option<Icon> {\n+    fn tab_icon(&self, window: &Window, cx: &AppContext) -> Option<Icon> {\n         let channel = self.channel(cx)?;\n         let icon = match channel.visibility {\n             ChannelVisibility::Public => IconName::Public,\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -450,8 +450,8 @@\n     fn tab_content(\n         &self,\n         params: TabContentParams,\n-        window: &mut Window,\n-        cx: &mut AppContext,\n+        window: &Window,\n+        cx: &AppContext,\n     ) -> gpui::AnyElement {\n         let (channel_name, status) = if let Some(channel) = self.channel(cx) {\n             let status = match (\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -561,8 +561,8 @@\n \n     fn to_state_proto(\n         &self,\n-        window: &mut Window,\n-        cx: &mut AppContext,\n+        window: &Window,\n+        cx: &AppContext,\n     ) -> Option<proto::view::Variant> {\n         let channel_buffer = self.channel_buffer.read(cx);\n         if !channel_buffer.is_connected() {\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -559,11 +559,7 @@\n         self.remote_id\n     }\n \n-    fn to_state_proto(\n-        &self,\n-        window: &Window,\n-        cx: &AppContext,\n-    ) -> Option<proto::view::Variant> {\n+    fn to_state_proto(&self, window: &Window, cx: &AppContext) -> Option<proto::view::Variant> {\n         let channel_buffer = self.channel_buffer.read(cx);\n         if !channel_buffer.is_connected() {\n             return None;\n@@ -587,8 +583,8 @@\n         workspace: Model<workspace::Workspace>,\n         remote_id: workspace::ViewId,\n         state: &mut Option<proto::view::Variant>,\n-        window: &mut Window,\n-        cx: &mut AppContext,\n+        window: &Window,\n+        cx: &AppContext,\n     ) -> Option<gpui::Task<anyhow::Result<Model<Self>>>> {\n         let Some(proto::view::Variant::ChannelView(_)) = state else {\n             return None;\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -583,7 +583,7 @@\n         workspace: Model<workspace::Workspace>,\n         remote_id: workspace::ViewId,\n         state: &mut Option<proto::view::Variant>,\n-        window: &Window,\n+        window: &mut Window,\n         cx: &AppContext,\n     ) -> Option<gpui::Task<anyhow::Result<Model<Self>>>> {\n         let Some(proto::view::Variant::ChannelView(_)) = state else {\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -584,7 +584,7 @@\n         remote_id: workspace::ViewId,\n         state: &mut Option<proto::view::Variant>,\n         window: &mut Window,\n-        cx: &AppContext,\n+        cx: &mut AppContext,\n     ) -> Option<gpui::Task<anyhow::Result<Model<Self>>>> {\n         let Some(proto::view::Variant::ChannelView(_)) = state else {\n             return None;\n\n```\n\nUser edited \"crates/collab_ui/src/channel_view.rs\":\n```diff\n@@ -634,8 +634,8 @@\n         &self,\n         event: &EditorEvent,\n         update: &mut Option<proto::update_view::Variant>,\n-        window: &mut Window,\n-        cx: &mut AppContext,\n+        window: &Window,\n+        cx: &AppContext,\n     ) -> bool {\n         self.editor\n             .read(cx)\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/collab_ui/src/channel_view.rs\n        Some(proto::view::Variant::ChannelView(\n<|editable_region_start|>\n            proto::view::ChannelView {\n                channel_id: channel_buffer.channel_id.0,\n                editor: if let Some(proto::view::Variant::Editor(proto)) =\n                    self.editor.read(cx).to_state_proto(window, cx)\n                {\n                    Some(proto)\n                } else {\n                    None\n                },\n            },\n        ))\n    }\n\n    fn from_state_proto(\n        workspace: Model<workspace::Workspace>,\n        remote_id: workspace::ViewId,\n        state: &mut Option<proto::view::Variant>,\n        window: &mut Window,\n        cx: &mut AppContext,\n    ) -> Option<gpui::Task<anyhow::Result<Model<Self>>>> {\n        let Some(proto::view::Variant::ChannelView(_)) = state else {\n            return None;\n        };\n        let Some(proto::view::Variant::ChannelView(state)) = state.take() else {\n            unreachable!()\n        };\n\n        let open = ChannelView::load(ChannelId(state.channel_id), workspace, window, cx);\n\n        Some(window.spawn(cx, |mut cx| async move {\n            let this = open.await?;\n\n            let task = this.update<|user_cursor_is_here|>(&mut cx, |this, cx| {\n                this.remote_id = Some(remote_id);\n\n                if let Some(state) = state.editor {\n                    Some(this.editor.update(cx, |editor, cx| {\n                        editor.apply_update_proto(\n                            &this.project,\n                            proto::update_view::Variant::Editor(proto::update_view::Editor {\n                                selections: state.selections,\n                                pending_selection: state.pending_selection,\n                                scroll_top_anchor: state.scroll_top_anchor,\n                                scroll_x: state.scroll_x,\n                                scroll_y: state.scroll_y,\n                                ..Default::default()\n                            }),\n                            window,\n                            cx,\n                        )\n                    }))\n                } else {\n                    None\n                }\n            })?;\n\n            if let Some(task) = task {\n                task.await?;\n            }\n\n            Ok(this)\n        }))\n    }\n\n    fn add_event_to_update_proto(\n<|editable_region_end|>\n        &self,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/collab_ui/src/channel_view.rs\n        Some(proto::view::Variant::ChannelView(\n<|editable_region_start|>\n            proto::view::ChannelView {\n                channel_id: channel_buffer.channel_id.0,\n                editor: if let Some(proto::view::Variant::Editor(proto)) =\n                    self.editor.read(cx).to_state_proto(window, cx)\n                {\n                    Some(proto)\n                } else {\n                    None\n                },\n            },\n        ))\n    }\n\n    fn from_state_proto(\n        workspace: Model<workspace::Workspace>,\n        remote_id: workspace::ViewId,\n        state: &mut Option<proto::view::Variant>,\n        window: &mut Window,\n        cx: &mut AppContext,\n    ) -> Option<gpui::Task<anyhow::Result<Model<Self>>>> {\n        let Some(proto::view::Variant::ChannelView(_)) = state else {\n            return None;\n        };\n        let Some(proto::view::Variant::ChannelView(state)) = state.take() else {\n            unreachable!()\n        };\n\n        let open = ChannelView::load(ChannelId(state.channel_id), workspace, window, cx);\n\n        Some(window.spawn(cx, |mut cx| async move {\n            let this = open.await?;\n\n            let task = this.update(&mut cx, |this, cx| {\n                this.remote_id = Some(remote_id);\n\n                if let Some(state) = state.editor {\n                    Some(this.editor.update(cx, |editor, cx| {\n                        editor.apply_update_proto(\n                            &this.project,\n                            proto::update_view::Variant::Editor(proto::update_view::Editor {\n                                selections: state.selections,\n                                pending_selection: state.pending_selection,\n                                scroll_top_anchor: state.scroll_top_anchor,\n                                scroll_x: state.scroll_x,\n                                scroll_y: state.scroll_y,\n                                ..Default::default()\n                            }),\n                            window,\n                            cx,\n                        )\n                    }))\n                } else {\n                    None\n                }\n            })?;\n\n            if let Some(task) = task {\n                task.await?;\n            }\n\n            Ok(this)\n        }))\n    }\n\n    fn add_event_to_update_proto(\n<|editable_region_end|>\n        &self,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -12473,8 +12473,7 @@\n                         .entry(buffer)\n                         .or_insert((Vec::new(), None))\n                         .0\n-                        // TODO kb wrong row used, has to be buffer offset\n-                        .push(start_offset..start_offset)\n+                        .push(buffer_offset..buffer_offset)\n                 }\n             }\n             None => {\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -12464,7 +12464,6 @@\n             }\n             Some(JumpData::MultiBufferRow(row)) => {\n                 let point = MultiBufferPoint::new(row.0, 0);\n-                dbg!(row);\n                 if let Some((buffer, buffer_point, _)) =\n                     self.buffer.read(cx).point_to_buffer_point(point, cx)\n                 {\n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -597,7 +597,6 @@\n                 .snapshot\n                 .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)\n                 .row;\n-            dbg!(multi_buffer_row,);\n             if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {\n                 if hit_box.contains(&event.position) {\n                     editor.open_excerpts_common(\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,7 @@\n \n+\n+co-authored-by: Agus Zubiaga <agus@zed.dev>\n+\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-\n+Fix navigation bugs\n \n co-authored-by: Agus Zubiaga <agus@zed.dev>\n \n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -609,7 +609,7 @@\n             }\n         }\n \n-        cx.stop_propagation();\n+        \n     }\n \n     fn mouse_right_down(\n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -608,8 +608,6 @@\n                 }\n             }\n         }\n-\n-        \n     }\n \n     fn mouse_right_down(\n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -589,6 +589,7 @@\n                     cx,\n                 );\n             }\n+            cx.stop_propagation();\n         } else {\n             let display_row = (((event.position - gutter_hitbox.bounds.origin).y\n                 + position_map.scroll_pixel_position.y)\n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -591,6 +591,7 @@\n             }\n             cx.stop_propagation();\n         } else {\n+            // TODO kb belongs to a methods\n             let display_row = (((event.position - gutter_hitbox.bounds.origin).y\n                 + position_map.scroll_pixel_position.y)\n                 / position_map.line_height) as u32;\n\n```\n\nUser edited \"crates/editor/src/element.rs\":\n```diff\n@@ -591,7 +591,7 @@\n             }\n             cx.stop_propagation();\n         } else {\n-            // TODO kb belongs to a methods\n+            // TODO kb extract common code around this module into method/functi\n             let display_row = (((event.position - gutter_hitbox.bounds.origin).y\n                 + position_map.scroll_pixel_position.y)\n                 / position_map.line_height) as u32;\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/element.rs\n                        goal_column: point_for_position.exact_unclipped.column(),\n<|editable_region_start|>\n                    },\n                    cx,\n                );\n            } else if modifiers.shift\n                && !modifiers.control\n                && !modifiers.alt\n                && !modifiers.secondary()\n            {\n                editor.select(\n                    SelectPhase::Extend {\n                        position,\n                        click_count,\n                    },\n                    cx,\n                );\n            } else {\n                let multi_cursor_setting = EditorSettings::get_global(cx).multi_cursor_modifier;\n                let multi_cursor_modifier = match multi_cursor_setting {\n                    MultiCursorModifier::Alt => modifiers.alt,\n                    MultiCursorModifier::CmdOrCtrl => modifiers.secondary(),\n                };\n                editor.select(\n                    SelectPhase::Begin {\n                        position,\n                        add: multi_cursor_modifier,\n                        click_count,\n                    },\n                    cx,\n                );\n            }\n            cx.stop_propagation();\n        } else {\n            // TODO kb extract common code around this module into method/functi<|user_cursor_is_here|>\n            let display_row = (((event.position - gutter_hitbox.bounds.origin).y\n                + position_map.scroll_pixel_position.y)\n                / position_map.line_height) as u32;\n            let multi_buffer_row = position_map\n                .snapshot\n                .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)\n                .row;\n            if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {\n                if hit_box.contains(&event.position) {\n                    editor.open_excerpts_common(\n                        Some(JumpData::MultiBufferRow(MultiBufferRow(multi_buffer_row))),\n                        modifiers.alt == true,\n                        cx,\n                    );\n                    cx.stop_propagation();\n                }\n            }\n        }\n    }\n\n    fn mouse_right_down(\n        editor: &mut Editor,\n        event: &MouseDownEvent,\n        position_map: &PositionMap,\n        text_hitbox: &Hitbox,\n        cx: &mut ViewContext<Editor>,\n    ) {\n        if !text_hitbox.is_hovered(cx) {\n            return;\n        }\n        let point_for_position =\n            position_map.point_for_position(text_hitbox.bounds, event.position);\n<|editable_region_end|>\n        mouse_context_menu::deploy_context_menu(\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/element.rs\n                        goal_column: point_for_position.exact_unclipped.column(),\n<|editable_region_start|>\n                    },\n                    cx,\n                );\n            } else if modifiers.shift\n                && !modifiers.control\n                && !modifiers.alt\n                && !modifiers.secondary()\n            {\n                editor.select(\n                    SelectPhase::Extend {\n                        position,\n                        click_count,\n                    },\n                    cx,\n                );\n            } else {\n                let multi_cursor_setting = EditorSettings::get_global(cx).multi_cursor_modifier;\n                let multi_cursor_modifier = match multi_cursor_setting {\n                    MultiCursorModifier::Alt => modifiers.alt,\n                    MultiCursorModifier::CmdOrCtrl => modifiers.secondary(),\n                };\n                editor.select(\n                    SelectPhase::Begin {\n                        position,\n                        add: multi_cursor_modifier,\n                        click_count,\n                    },\n                    cx,\n                );\n            }\n            cx.stop_propagation();\n        } else {\n            // TODO kb extract common code around this module into method/function\n            let display_row = (((event.position - gutter_hitbox.bounds.origin).y\n                + position_map.scroll_pixel_position.y)\n                / position_map.line_height) as u32;\n            let multi_buffer_row = position_map\n                .snapshot\n                .display_point_to_point(DisplayPoint::new(DisplayRow(display_row), 0), Bias::Right)\n                .row;\n            if let Some(hit_box) = line_numbers_hitboxes.get(&MultiBufferRow(multi_buffer_row)) {\n                if hit_box.contains(&event.position) {\n                    editor.open_excerpts_common(\n                        Some(JumpData::MultiBufferRow(MultiBufferRow(multi_buffer_row))),\n                        modifiers.alt == true,\n                        cx,\n                    );\n                    cx.stop_propagation();\n                }\n            }\n        }\n    }\n\n    fn mouse_right_down(\n        editor: &mut Editor,\n        event: &MouseDownEvent,\n        position_map: &PositionMap,\n        text_hitbox: &Hitbox,\n        cx: &mut ViewContext<Editor>,\n    ) {\n        if !text_hitbox.is_hovered(cx) {\n            return;\n        }\n        let point_for_position =\n            position_map.point_for_position(text_hitbox.bounds, event.position);\n<|editable_region_end|>\n        mouse_context_menu::deploy_context_menu(\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,7 +4571,7 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n-        let mut selections = self.selections.newest_adjusted(cx);\n+        let mut selections = self.selections.all_adjusted(cx);\n         if inside_leading_indent {\n             self.tab();\n             return;\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,7 +4571,7 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n-        let mut selections = self.selections.all_adjusted(cx);\n+        let mut selections = self.selections.newe(cx);\n         if inside_leading_indent {\n             self.tab();\n             return;\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,7 +4571,7 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n-        let mut selections = self.selections.newe(cx);\n+        let mut selections = self.selections.newest_adjusted(cx);\n         if inside_leading_indent {\n             self.tab();\n             return;\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,7 +4571,8 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n-        let mut selections = self.selections.newest_adjusted(cx);\n+        let mut selection = self.selections.newest_adjusted(cx);\n+        if selection.is_empty() && \n         if inside_leading_indent {\n             self.tab();\n             return;\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,6 +4571,8 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n+    let buffer = self.buffer.read(cx);\n+    let snapshot = buffer.snapshot(cx);\n         let mut selection = self.selections.newest_adjusted(cx);\n         if selection.is_empty() && \n         if inside_leading_indent {\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4574,6 +4574,8 @@\n     let buffer = self.buffer.read(cx);\n     let snapshot = buffer.snapshot(cx);\n         let mut selection = self.selections.newest_adjusted(cx);\n+        let cursor = selection.head();\n+        let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && \n         if inside_leading_indent {\n             self.tab();\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4577,6 +4577,7 @@\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && \n+        \n         if inside_leading_indent {\n             self.tab();\n             return;\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4576,7 +4576,7 @@\n         let mut selection = self.selections.newest_adjusted(cx);\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n-        if selection.is_empty() && \n+        if selection.is_empty() && cursor.column >= current_indent.len\n         \n         if inside_leading_indent {\n             self.tab();\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4576,7 +4576,7 @@\n         let mut selection = self.selections.newest_adjusted(cx);\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n-        if selection.is_empty() && cursor.column >= current_indent.len\n+        if selection.is_empty() && cursor.column < current_indent.len\n         \n         if inside_leading_indent {\n             self.tab();\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4576,7 +4576,8 @@\n         let mut selection = self.selections.newest_adjusted(cx);\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n-        if selection.is_empty() && cursor.column < current_indent.len\n+        if selection.is_empty() && cursor.column < current_indent.len {\n+        }\n         \n         if inside_leading_indent {\n             self.tab();\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4579,7 +4579,6 @@\n         if selection.is_empty() && cursor.column < current_indent.len {\n         }\n         \n-        if inside_leading_indent {\n             self.tab();\n             return;\n         }\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4577,8 +4577,6 @@\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && cursor.column < current_indent.len {\n-        }\n-        \n             self.tab();\n             return;\n         }\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4577,7 +4577,7 @@\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && cursor.column < current_indent.len {\n-            self.tab();\n+            self.tab(Default::default());\n             return;\n         }\n         \n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4571,16 +4571,16 @@\n         _: &AcceptInlineCompletion,\n         cx: &mut ViewContext<Self>,\n     ) {\n-    let buffer = self.buffer.read(cx);\n-    let snapshot = buffer.snapshot(cx);\n+        let buffer = self.buffer.read(cx);\n+        let snapshot = buffer.snapshot(cx);\n         let mut selection = self.selections.newest_adjusted(cx);\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && cursor.column < current_indent.len {\n-            self.tab(Default::default());\n+            self.tab(&Default::default());\n             return;\n         }\n-        \n+\n         if self.show_inline_completions_in_menu(cx) {\n             self.hide_context_menu(cx);\n         }\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4577,7 +4577,7 @@\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && cursor.column < current_indent.len {\n-            self.tab(&Default::default());\n+            self.tab(&Default::default(), cx);\n             return;\n         }\n \n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -4573,7 +4573,7 @@\n     ) {\n         let buffer = self.buffer.read(cx);\n         let snapshot = buffer.snapshot(cx);\n-        let mut selection = self.selections.newest_adjusted(cx);\n+        let selection = self.selections.newest_adjusted(cx);\n         let cursor = selection.head();\n         let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n         if selection.is_empty() && cursor.column < current_indent.len {\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -122,6 +122,10 @@\n     \"});\n }\n \n+\n+#[gpui::test]\n+async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n+}\n #[gpui::test]\n async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n     init_test(cx, |_| {});\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -126,6 +126,7 @@\n #[gpui::test]\n async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n }\n+\n #[gpui::test]\n async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n     init_test(cx, |_| {});\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -122,7 +122,6 @@\n     \"});\n }\n \n-\n #[gpui::test]\n async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n }\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -123,7 +123,7 @@\n }\n \n #[gpui::test]\n-async fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n+async fn test_inden(cx: &mut gpui::TestAppContext) {\n }\n \n #[gpui::test]\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/editor/src/inline_completion_tests.rs\n<|editable_region_start|>\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line \u02c74\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, cx| editor.update_visible_inline_completion(cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        lin\u02c7e\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_inden<|user_cursor_is_here|>(cx: &mut gpui::TestAppContext) {\n}\n\n#[gpui::test]\nasync fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new_model(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 3+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line \u02c71\n        line 2\n        line 3\n        line 4\n        line\n    \"});\n    let edit_location = Point::new(5, 3);\n\n    propose_edits(\n        &provider,\n        vec![(edit_location..edit_location, \" 5\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, cx| editor.update_visible_inline_completion(cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), edit_location);\n    });\n\n<|editable_region_end|>\n    // If we move *towards* the completion, it stays active\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/editor/src/inline_completion_tests.rs\n<|editable_region_start|>\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line \u02c74\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, cx| editor.update_visible_inline_completion(cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        lin\u02c7e\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_indentation(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n    \n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new_model(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n}\n\n#[gpui::test]\nasync fn test_inline_completion_invalidation_range(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new_model(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 3+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line \u02c71\n        line 2\n        line 3\n        line 4\n        line\n    \"});\n    let edit_location = Point::new(5, 3);\n\n    propose_edits(\n        &provider,\n        vec![(edit_location..edit_location, \" 5\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, cx| editor.update_visible_inline_completion(cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), edit_location);\n    });\n\n<|editable_region_end|>\n    // If we move *towards* the completion, it stays active\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"main.py\":\n```diff\n@@ -59,7 +59,7 @@\n     while not game_over:\n         while game_close:\n             window.fill(BLACK)\n-            game_over_text = font.render(\"Game Over! Press Q-Quit or C-Play Again\", True, WHITE)\n+            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again\", True, WHITE)\n             window.blit(game_over_text, [width // 6, height // 3])\n             display_score(length_of_snake - 1)\n             pygame.display.update()\n\n```\n\nUser edited \"main.py\":\n```diff\n@@ -59,7 +59,7 @@\n     while not game_over:\n         while game_close:\n             window.fill(BLACK)\n-            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again\", True, WHITE)\n+            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again, I\", True, WHITE)\n             window.blit(game_over_text, [width // 6, height // 3])\n             display_score(length_of_snake - 1)\n             pygame.display.update()\n\n```\n\nUser edited \"main.py\":\n```diff\n@@ -59,7 +59,7 @@\n     while not game_over:\n         while game_close:\n             window.fill(BLACK)\n-            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again, I\", True, WHITE)\n+            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again, I-Instructions\", True, WHITE)\n             window.blit(game_over_text, [width // 6, height // 3])\n             display_score(length_of_snake - 1)\n             pygame.display.update()\n\n```\n\nUser edited \"main.py\":\n```diff\n@@ -71,6 +71,8 @@\n                         game_close = False\n                     if event.key == pygame.K_c:\n                         game_loop()\n+                    if event.key == pygame.K_i:\n+                        print(\"Instructions: Use arrow keys to move the snake. Eat the food to grow longer. Avoid hitting the walls or yourself.\")\n \n         for event in pygame.event.get():\n             if event.type == pygame.QUIT:\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```main.py\n    # Starting position of the snake\n<|editable_region_start|>\n    x1 = width // 2\n    y1 = height // 2\n\n    # Change in position\n    x1_change = 0\n    y1_change = 0\n\n    # Snake body\n    snake_list = []\n    length_of_snake = 1\n\n    # Food position\n    food_x = round(random.randrange(0, width - snake_block) / 20.0) * 20.0\n    food_y = round(random.randrange(0, height - snake_block) / 20.0) * 20.0\n\n    clock = pygame.time.Clock()\n\n    while not game_over:\n        while game_close:\n            window.fill(BLACK)\n            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again, I-Instructions\", True, WHITE)\n            window.blit(game_over_text, [width // 6, height // 3])\n            display_score(length_of_snake - 1)\n            pygame.display.update()\n\n            for event in pygame.event.get():\n                if event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_q:\n                        game_over = True\n                        game_close = False\n                    if event.key == pygame.K_c:\n                        game_loop()\n<|user_cursor_is_here|>                    if event.key == pygame.K_i:\n                        print(\"Instructions: Use arrow keys to move the snake. Eat the food to grow longer. Avoid hitting the walls or yourself.\")\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game_over = True\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    x1_change = -snake_block\n                    y1_change = 0\n                elif event.key == pygame.K_RIGHT:\n                    x1_change = snake_block\n                    y1_change = 0\n                elif event.key == pygame.K_UP:\n                    y1_change = -snake_block\n                    x1_change = 0\n                elif event.key == pygame.K_DOWN:\n                    y1_change = snake_block\n                    x1_change = 0\n\n        if x1 >= width or x1 < 0 or y1 >= height or y1 < 0:\n            game_close = True\n\n        x1 += x1_change\n        y1 += y1_change\n        window.fill(BLACK)\n        pygame.draw.rect(window, RED, [food_x, food_y, snake_block, snake_block])\n        snake_head = []\n        snake_head.append(x1)\n        snake_head.append(y1)\n        snake_list.append(snake_head)\n\n        if len(snake_list) > length_of_snake:\n<|editable_region_end|>\n            del snake_list[0]\n```"}, {"role": "assistant", "content": "Suggestion:\n```main.py\n    # Starting position of the snake\n<|editable_region_start|>\n    x1 = width // 2\n    y1 = height // 2\n\n    # Change in position\n    x1_change = 0\n    y1_change = 0\n\n    # Snake body\n    snake_list = []\n    length_of_snake = 1\n\n    # Food position\n    food_x = round(random.randrange(0, width - snake_block) / 20.0) * 20.0\n    food_y = round(random.randrange(0, height - snake_block) / 20.0) * 20.0\n\n    clock = pygame.time.Clock()\n\n    while not game_over:\n        while game_close:\n            window.fill(BLACK)\n            game_over_text = font.render(\"Game Over! Press Q-Quit, C-Play Again, I-Instructions\", True, WHITE)\n            window.blit(game_over_text, [width // 6, height // 3])\n            display_score(length_of_snake - 1)\n            pygame.display.update()\n\n            for event in pygame.event.get():\n                if event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_q:\n                        game_over = True\n                        game_close = False\n                    if event.key == pygame.K_c:\n                        game_loop()\n                    if event.key == pygame.K_i:\n                        print(\"Instructions: Use arrow keys to move the snake. Eat the food to grow longer. Avoid hitting the walls or yourself.\")\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game_over = True\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    x1_change = -snake_block\n                    y1_change = 0\n                elif event.key == pygame.K_RIGHT:\n                    x1_change = snake_block\n                    y1_change = 0\n                elif event.key == pygame.K_UP:\n                    y1_change = -snake_block\n                    x1_change = 0\n                elif event.key == pygame.K_DOWN:\n                    y1_change = snake_block\n                    x1_change = 0\n\n        if x1 >= width or x1 < 0 or y1 >= height or y1 < 0:\n            game_close = True\n\n        x1 += x1_change\n        y1 += y1_change\n        window.fill(BLACK)\n        pygame.draw.rect(window, RED, [food_x, food_y, snake_block, snake_block])\n        snake_head = []\n        snake_head.append(x1)\n        snake_head.append(y1)\n        snake_list.append(snake_head)\n\n        if len(snake_list) > length_of_snake:\n<|editable_region_end|>\n            del snake_list[0]\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3464,8 +3464,8 @@\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n         cursor.seek(&start, Bias::Right, &());\n         \n-        //  3       6       7\n-        // | ITEM1 | ITEM2 | ITEM\n+        //  3         6       7\n+        // | ITEM1 | ITEM2 | ITEM3\n         // \n         // SEEK 3\n         cursor.prev(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3467,7 +3467,8 @@\n         //  3         6       7\n         // | ITEM1 | ITEM2 | ITEM3\n         // \n-        // SEEK 3\n+        // SEEK 3 -> ITEM1\n+        // SEEK 4 -> \n         cursor.prev(&());\n \n         iter::from_fn(move || {\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3468,7 +3468,7 @@\n         // | ITEM1 | ITEM2 | ITEM3\n         // \n         // SEEK 3 -> ITEM1\n-        // SEEK 4 -> \n+        // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n         cursor.prev(&());\n \n         iter::from_fn(move || {\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3469,7 +3469,7 @@\n         // \n         // SEEK 3 -> ITEM1\n         // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n-        cursor.prev(&());\n+        // cursor.prev(&());\n \n         iter::from_fn(move || {\n             cursor.next(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3462,11 +3462,11 @@\n     ) -> impl Iterator<Item = MultiBufferExcerpt> + '_ {\n         dbg!(start, end);\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n-        cursor.seek(&start, Bias::Right, &());\n-        \n+        cursor.seek(&start, Bias::Left, &());\n+\n         //  3         6       7\n         // | ITEM1 | ITEM2 | ITEM3\n-        // \n+        //\n         // SEEK 3 -> ITEM1\n         // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n         // cursor.prev(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3462,11 +3462,11 @@\n     ) -> impl Iterator<Item = MultiBufferExcerpt> + '_ {\n         dbg!(start, end);\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n-        cursor.seek(&start, Bias::Left, &());\n-\n+        cursor.seek(&start, Bias::Right, &());\n+        \n         //  3         6       7\n         // | ITEM1 | ITEM2 | ITEM3\n-        //\n+        // \n         // SEEK 3 -> ITEM1\n         // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n         // cursor.prev(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3463,10 +3463,10 @@\n         dbg!(start, end);\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n         cursor.seek(&start, Bias::Right, &());\n-        \n+\n         //  3         6       7\n         // | ITEM1 | ITEM2 | ITEM3\n-        // \n+        //\n         // SEEK 3 -> ITEM1\n         // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n         // cursor.prev(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3469,7 +3469,7 @@\n         //\n         // SEEK 3 -> ITEM1\n         // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n-        // cursor.prev(&());\n+        cursor.prev(&());\n \n         iter::from_fn(move || {\n             cursor.next(&());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3464,7 +3464,7 @@\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n         cursor.seek(&start, Bias::Right, &());\n \n-        //  3         6       7\n+        //  3         6       7x\n         // | ITEM1 | ITEM2 | ITEM3\n         //\n         // SEEK 3 -> ITEM1\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -3464,11 +3464,6 @@\n         let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n         cursor.seek(&start, Bias::Right, &());\n \n-        //  3         6       7x\n-        // | ITEM1 | ITEM2 | ITEM3\n-        //\n-        // SEEK 3 -> ITEM1\n-        // SEEK 4 -> Bias::Right -> ITEM2, Bias::Left -> ITEM1\n         cursor.prev(&());\n \n         iter::from_fn(move || {\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```crates/multi_buffer/src/multi_buffer.rs\n        self.excerpts_for_range_impl(\n<|editable_region_start|>\n            range.start().to_offset(self),\n            range.end().to_offset(self),\n            |cursor, end| cursor <= end,\n        )\n    }\n\n    pub fn excerpts_for_range_impl(\n        &self,\n        start: usize,\n        end: usize,\n        f: fn(usize, usize) -> bool,\n    ) -> impl Iterator<Item = MultiBufferExcerpt> + '_ {\n        dbg!(start, end);\n        let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n        cursor.seek(&start, Bias::Right, &());\n\n<|user_cursor_is_here|>        cursor.prev(&());\n\n        iter::from_fn(move || {\n            cursor.next(&());\n\n            if f(cursor.start().0, end) {\n                let item = cursor.item();\n                dbg!(item.is_none());\n                item.map(|item| MultiBufferExcerpt::new(item, *cursor.start()))\n            } else {\n                dbg!(\"\");\n                None\n            }\n        })\n    }\n\n    pub fn excerpts_for_range_rev<T: ToOffset>(\n<|editable_region_end|>\n        &self,\n```"}, {"role": "assistant", "content": "Suggestion:\n```crates/multi_buffer/src/multi_buffer.rs\n        self.excerpts_for_range_impl(\n<|editable_region_start|>\n            range.start().to_offset(self),\n            range.end().to_offset(self),\n            |cursor, end| cursor <= end,\n        )\n    }\n\n    pub fn excerpts_for_range_impl(\n        &self,\n        start: usize,\n        end: usize,\n        f: fn(usize, usize) -> bool,\n    ) -> impl Iterator<Item = MultiBufferExcerpt> + '_ {\n        dbg!(start, end);\n        let mut cursor = self.excerpts.cursor::<(usize, Point)>(&());\n        cursor.seek(&start, Bias::Right, &());\n\n        cursor.prev(&());\n\n        iter::from_fn(move || {\n            cursor.next(&());\n\n            if f(cursor.start().0, end) {\n                let item = cursor.item();\n                dbg!(item.is_none());\n                item.map(|item| MultiBufferExcerpt::new(item, *cursor.start()))\n            } else {\n                dbg!(\"\");\n                None\n            }\n        })\n    }\n\n    pub fn excerpts_for_range_rev<T: ToOffset>(\n<|editable_region_end|>\n        &self,\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"crates/git_ui/src/git_panel.rs\":\n```diff\n@@ -241,7 +241,7 @@\n                             _ => {}\n                         };\n                     });\n-                };\n+                }\n             })\n             .detach();\n \n\n```\n\nUser edited \"crates/git_ui/src/git_panel.rs\":\n```diff\n@@ -174,7 +174,7 @@\n                     });\n                     let first_repo_in_project = first_repository_in_project(&project, cx);\n \n-                    let Some(git_state) = git_state else {\n+                    let Some(git_state) = git_state.clone() else {\n                         return;\n                     };\n                     git_state.update(cx, |git_state, _| {\n\n```\n\nUser edited \"crates/git_ui/src/git_panel.rs\":\n```diff\n@@ -149,10 +149,6 @@\n         let project = workspace.project().clone();\n         let weak_workspace = cx.view().downgrade();\n         let git_state = project.read(cx).git_state().cloned();\n-        let language_registry = workspace.app_state().languages.clone();\n-        let current_commit_message = git_state\n-            .as_ref()\n-            .map(|git_state| git_state.read(cx).commit_message.clone());\n \n         let (err_sender, mut err_receiver) = mpsc::channel(1);\n \n\n```\n\nUser edited \"crates/git_ui/src/git_panel.rs\":\n```diff\n@@ -712,7 +712,7 @@\n         let Some(git_state) = self.git_state(cx) else {\n             return;\n         };\n-        if let Err(e) = git_state.update(cx, |git_state, _| {\n+        if let Err(e) = git_state.update(cx, |git_state, cx| {\n             git_state.commit_all(self.err_sender.clone(), cx)\n         }) {\n             self.show_err_toast(\"commit all error\", e, cx);\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -32,6 +32,7 @@\n   - [ ] Don't load single file worktrees (settings.json, etc) for now\n     - test external imports as well (cmd+clicking in)\n   - [ ] If not building overflow/context menu before shipping: remove `...` icon on entries\n+  - [ ] Add UI for the co-authored-by field\n   \n ## Stretch\n   - [ ] Reflect what a collaborator can actually do in the UI\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -46,7 +46,7 @@\n   - [ ] [@cole] Add the diff line numbers to the status information\n   - [ ] panel header buttons -> act on selected entry, modifier swaps to \"all\" variants\n   - [ ] Track when at top or bottom of list (scroll-position wise), add gradient overlay\n-  - [@kirill] Query for collaborators git.email\n+  - [ ] [@kirill] Query for collaborators git.email\n       - check collaborators' .gitconfig for e-mails, user names, etc.\n           `$ git config user.email`\n       -  ? consider collab metadata?\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -65,10 +65,10 @@\n - [ ] Make sure there's a 'suggest a commit message' button somewhere if AI is enabled\n - [ ] Create the unified diff view UI\n     \n-  - [x] [@cole] Add the ability to create commits\n-    - [x] [@Disable commiting when no message\n-    - [x] Disable commiting when there are no changes\n-    - [x] Disable commiting when nothing is staged (not for CommitAllChanges)\n+- [x] [@cole] Add the ability to create commits\n+  - [x] [@Disable commiting when no message\n+  - [x] Disable commiting when there are no changes\n+  - [x] Disable commiting when nothing is staged (not for CommitAllChanges)\n - [x] [@cole] `enter` opens entry\n   - [x] intelligent handling of deleted files\n - [x] [@nate] Finish rewriting git panel to use the new status APIs\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -65,6 +65,7 @@\n - [ ] Make sure there's a 'suggest a commit message' button somewhere if AI is enabled\n - [ ] Create the unified diff view UI\n     \n+## Done\n - [x] [@cole] Add the ability to create commits\n   - [x] [@Disable commiting when no message\n   - [x] Disable commiting when there are no changes\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -54,7 +54,7 @@\n \n ## Later / Idea dump   \n \n-- Add \"CommitAllModified\"\n+- [ ] Add \"CommitAllModified\" (don't commit untracked files)\n - [ ] Overflow menu for git top level actions (`...` menu)\n - [ ] Context menu for selected entry\n - [ ] Overflow menu for selected entry\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -59,7 +59,6 @@\n - [ ] Context menu for selected entry\n - [ ] Overflow menu for selected entry\n - [ ] [@cole] Restore the on-click behavior for specific status lines\n-- [ ] Add commit all (except untracked) button/shortcut\n - [ ] Add a revert all command / button\n - [ ] Show a striped background for non-staged hunks, and a solid background for staged ones\n - [ ] Make sure there's a 'suggest a commit message' button somewhere if AI is enabled\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -9,7 +9,6 @@\n - [ ] Panics when following collaborator into project diff view\n - [ ] Git diffs if file contains \\r\n - [ ] Have people noticed that the initial sync \n-\n   \n # To ship\n \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -9,6 +9,7 @@\n - [ ] Panics when following collaborator into project diff view\n - [ ] Git diffs if file contains \\r\n - [ ] Have people noticed that the initial sync \n+\n   \n # To ship\n \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -9,7 +9,6 @@\n - [ ] Panics when following collaborator into project diff view\n - [ ] Git diffs if file contains \\r\n - [ ] Have people noticed that the initial sync \n-\n   \n # To ship\n \n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```untitled\n<|start_of_file|>\n<|editable_region_start|>\n# Git\n\nOverall goals: Keep people in Zed, do something for everyone, build a git client we are proud of.\n\n## TODO\n\n# Incoming\n- [ ] Was following broken by diffmap stuff?\n- [ ] Panics when following collaborator into project diff view\n- [ ] Git diffs if file contains \\r\n- [ ] Have people noticed that the initial sync \n<|user_cursor_is_here|>  \n# To ship\n\n- [ ] [@conrad @max] DiffMap rewrite\n  - [@jo\u00e3o @conrad @max] Debugging / testing the diff map\n  - [x] Rebuilding the editor interactions\n- [x] [@cole @mikayla] Git status rewrite\n- [*] [@cole @mikayla @nate @kirill] Git Panel\n  - [*] [@nate] Show keybindings on buttons\n  - [*] [@nate] Add a dropdown for switching repositories when more than one\n    - `first repo` -> `selected repo`\n  - [ ] Add debug command\n  - [ ] Testing\n    - For the basic setup, want a (randomized?) test using the\n      FakeGitRepository, that we can make changes to files, stage/unstage/commit\n      them using our new actions, and the resulting state of the (fake) filesystem/git repo is what we expect\n    - Also test that git operations are sequenced correctly.\n    - Then we should extend this to remote editing when that is supported.\n    - Where will the tests live?\n  - [ ] Don't load single file worktrees (settings.json, etc) for now\n    - test external imports as well (cmd+clicking in)\n  - [ ] If not building overflow/context menu before shipping: remove `...` icon on entries\n  - [ ] Add UI for the co-authored-by field\n  \n## Stretch\n  - [ ] Reflect what a collaborator can actually do in the UI\n    - If read only buttons should look disabled for example\n    - add something like `GitPanel::is_read_only`\n  - [ ] Make sure conflicts are sufficiently visible\n    - Mark with a ! at the end of the entry\n  - [ ] Add collaboration/remote development support\n    - [ ] collaborator can see leader's listing in git panel\n    - [ ] remote development: show state of repo on remote machine\n  - [ ] [@cole] Add the diff line numbers to the status information\n  - [ ] panel header buttons -> act on selected entry, modifier swaps to \"all\" variants\n  - [ ] Track when at top or bottom of list (scroll-position wise), add gradient overlay\n  - [ ] [@kirill] Query for collaborators git.email\n      - check collaborators' .gitconfig for e-mails, user names, etc.\n          `$ git config user.email`\n      -  ? consider collab metadata?\n      -  ? ask the user for it?\n\n## Later / Idea dump   \n\n- [ ] Add \"CommitAllModified\" (don't commit untracked files)\n- [ ] Overflow menu for git top level actions (`...` menu)\n- [ ] Context menu for selected entry\n- [ ] Overflow menu for selected entry\n- [ ] [@cole] Restore the on-click behavior for specific status lines\n- [ ] Add a revert all command / button\n- [ ] Show a striped background for non-staged hunks, and a solid background for staged ones\n- [ ] Make sure there's a 'suggest a commit message' button somewhere if AI is enabled\n- [ ] Create the unified diff view UI\n    \n<|editable_region_end|>\n## Done\n```"}, {"role": "assistant", "content": "Suggestion:\n```untitled\n<|start_of_file|>\n<|editable_region_start|>\n# Git\n\nOverall goals: Keep people in Zed, do something for everyone, build a git client we are proud of.\n\n## TODO\n\n# Incoming\n- [ ] Was following broken by diffmap stuff?\n- [ ] Panics when following collaborator into project diff view\n- [ ] Git diffs if file contains \\r\n- [ ] Have people noticed that the initial sync \n  \n# To ship\n\n- [ ] [@conrad @max] DiffMap rewrite\n  - [@jo\u00e3o @conrad @max] Debugging / testing the diff map\n  - [x] Rebuilding the editor interactions\n- [x] [@cole @mikayla] Git status rewrite\n- [*] [@cole @mikayla @nate @kirill] Git Panel\n  - [*] [@nate] Show keybindings on buttons\n  - [*] [@nate] Add a dropdown for switching repositories when more than one\n    - `first repo` -> `selected repo`\n  - [ ] Add debug command\n  - [ ] Testing\n    - For the basic setup, want a (randomized?) test using the\n      FakeGitRepository, that we can make changes to files, stage/unstage/commit\n      them using our new actions, and the resulting state of the (fake) filesystem/git repo is what we expect\n    - Also test that git operations are sequenced correctly.\n    - Then we should extend this to remote editing when that is supported.\n    - Where will the tests live?\n  - [ ] Don't load single file worktrees (settings.json, etc) for now\n    - test external imports as well (cmd+clicking in)\n  - [ ] If not building overflow/context menu before shipping: remove `...` icon on entries\n  - [ ] Add UI for the co-authored-by field\n  \n## Stretch\n  - [ ] Reflect what a collaborator can actually do in the UI\n    - If read only buttons should look disabled for example\n    - add something like `GitPanel::is_read_only`\n  - [ ] Make sure conflicts are sufficiently visible\n    - Mark with a ! at the end of the entry\n  - [ ] Add collaboration/remote development support\n    - [ ] collaborator can see leader's listing in git panel\n    - [ ] remote development: show state of repo on remote machine\n  - [ ] [@cole] Add the diff line numbers to the status information\n  - [ ] panel header buttons -> act on selected entry, modifier swaps to \"all\" variants\n  - [ ] Track when at top or bottom of list (scroll-position wise), add gradient overlay\n  - [ ] [@kirill] Query for collaborators git.email\n      - check collaborators' .gitconfig for e-mails, user names, etc.\n          `$ git config user.email`\n      -  ? consider collab metadata?\n      -  ? ask the user for it?\n\n## Later / Idea dump   \n\n- [ ] Add \"CommitAllModified\" (don't commit untracked files)\n- [ ] Overflow menu for git top level actions (`...` menu)\n- [ ] Context menu for selected entry\n- [ ] Overflow menu for selected entry\n- [ ] [@cole] Restore the on-click behavior for specific status lines\n- [ ] Add a revert all command / button\n- [ ] Show a striped background for non-staged hunks, and a solid background for staged ones\n- [ ] Make sure there's a 'suggest a commit message' button somewhere if AI is enabled\n- [ ] Create the unified diff view UI\n    \n<|editable_region_end|>\n## Done\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/ui/link.tsx\":\n```diff\n@@ -1,6 +1,7 @@\n import NextLink from \"next/link\"\n import clsx from \"clsx\"\n \n+\n export const primaryDecorationStyles = clsx(\n     \"underline decoration-accent-blue/20 hover:decoration-accent-blue/80\",\n     \"dark:decoration-blue-300/20 dark:hover:decoration-blue-400/80\",\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```src/ui/link.tsx\n<|start_of_file|>\n<|editable_region_start|>\nimport NextLink from \"next/link\"\nimport clsx from \"clsx\"\n\n<|user_cursor_is_here|>\nexport const primaryDecorationStyles = clsx(\n    \"underline decoration-accent-blue/20 hover:decoration-accent-blue/80\",\n    \"dark:decoration-blue-300/20 dark:hover:decoration-blue-400/80\",\n)\n\nexport const secondaryDecorationStyles = clsx(\n    \"underline decoration-accent-blue/20 hover:decoration-accent-blue/80\",\n    \"dark:decoration-blue-400/40 dark:hover:decoration-blue-400/80\",\n)\n\nexport function Link({\n    href,\n    children,\n    title,\n    className,\n    notBlueText,\n    ...rest\n}: {\n    href?: string\n    children: React.ReactNode\n    title?: string\n    className?: string\n    notBlueText?: boolean\n}) {\n    return (\n        <NextLink\n            className={clsx(\n                \"fv-style inline\",\n                notBlueText\n                    ? \"text-black dark:text-offgray-100\"\n                    : \"text-accent-blue dark:text-blue-300\",\n                primaryDecorationStyles,\n                className,\n            )}\n            href={href || \"#\"}\n            title={title}\n            {...rest}\n        >\n            {children}\n        </NextLink>\n    )\n}\n\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```src/ui/link.tsx\n<|start_of_file|>\n<|editable_region_start|>\nimport NextLink from \"next/link\"\nimport clsx from \"clsx\"\n\n\nexport const primaryDecorationStyles = clsx(\n    \"underline decoration-accent-blue/20 hover:decoration-accent-blue/80\",\n    \"dark:decoration-blue-300/20 dark:hover:decoration-blue-400/80\",\n)\n\nexport const secondaryDecorationStyles = clsx(\n    \"underline decoration-accent-blue/20 hover:decoration-accent-blue/80\",\n    \"dark:decoration-blue-400/40 dark:hover:decoration-blue-400/80\",\n)\n\nexport function Link({\n    href,\n    children,\n    title,\n    className,\n    notBlueText,\n    ...rest\n}: {\n    href?: string\n    children: React.ReactNode\n    title?: string\n    className?: string\n    notBlueText?: boolean\n}) {\n    return (\n        <NextLink\n            className={clsx(\n                \"fv-style inline\",\n                notBlueText\n                    ? \"text-black dark:text-offgray-100\"\n                    : \"text-accent-blue dark:text-blue-300\",\n                primaryDecorationStyles,\n                className,\n            )}\n            href={href || \"#\"}\n            title={title}\n            {...rest}\n        >\n            {children}\n        </NextLink>\n    )\n}\n\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"lib/src/reusable_node.h\":\n```diff\n@@ -20,6 +20,8 @@\n   self->last_external_token = NULL_SUBTREE;\n }\n \n+\n+\n static inline Subtree reusable_node_tree(ReusableNode *self) {\n   return self->stack.size > 0\n     ? self->stack.contents[self->stack.size - 1].tree\n\n```\n\nUser edited \"lib/src/unicode.h\":\n```diff\n@@ -33,6 +33,8 @@\n   return i;\n }\n \n+\n+\n static inline uint32_t ts_decode_utf16(\n   const uint8_t *string,\n   uint32_t length,\n\n```\n\nUser edited \"lib/src/unicode.h\":\n```diff\n@@ -33,7 +33,7 @@\n   return i;\n }\n \n-\n+st\n \n static inline uint32_t ts_decode_utf16(\n   const uint8_t *string,\n\n```\n\nUser edited \"lib/src/unicode.h\":\n```diff\n@@ -33,7 +33,7 @@\n   return i;\n }\n \n-st\n+static \n \n static inline uint32_t ts_decode_utf16(\n   const uint8_t *string,\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```lib/src/unicode.h\n<|start_of_file|>\n<|editable_region_start|>\n#ifndef TREE_SITTER_UNICODE_H_\n#define TREE_SITTER_UNICODE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdint.h>\n\n#define U_EXPORT\n#define U_EXPORT2\n#include \"unicode/utf8.h\"\n#include \"unicode/utf16.h\"\n\nstatic const int32_t TS_DECODE_ERROR = U_SENTINEL;\n\n// These functions read one unicode code point from the given string,\n// returning the number of bytes consumed.\ntypedef uint32_t (*UnicodeDecodeFunction)(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n);\n\nstatic inline uint32_t ts_decode_utf8(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U8_NEXT(string, i, length, *code_point);\n  return i;\n}\n\nstatic <|user_cursor_is_here|>\n\nstatic inline uint32_t ts_decode_utf16(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_UNICODE_H_\n\n<|editable_region_end|>\n```"}, {"role": "assistant", "content": "Suggestion:\n```lib/src/unicode.h\n<|start_of_file|>\n<|editable_region_start|>\n#ifndef TREE_SITTER_UNICODE_H_\n#define TREE_SITTER_UNICODE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdint.h>\n\n#define U_EXPORT\n#define U_EXPORT2\n#include \"unicode/utf8.h\"\n#include \"unicode/utf16.h\"\n\nstatic const int32_t TS_DECODE_ERROR = U_SENTINEL;\n\n// These functions read one unicode code point from the given string,\n// returning the number of bytes consumed.\ntypedef uint32_t (*UnicodeDecodeFunction)(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n);\n\nstatic inline uint32_t ts_decode_utf8(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U8_NEXT(string, i, length, *code_point);\n  return i;\n}\n\nstatic inline uint32_t ts_decode_utf32(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  if (length >= 4) {\n    *code_point = ((int32_t *)string)[0];\n    return 4;\n  }\n  *code_point = TS_DECODE_ERROR;\n  return 1;\n}\n\nstatic inline uint32_t ts_decode_utf16(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_UNICODE_H_\n\n<|editable_region_end|>\n```"}]}
{"messages": [{"role": "system", "content": "You are a helpful coding assistant that helps users edit their code."}, {"role": "user", "content": "Given the following code edit history:\nUser edited \"src/app/layout.tsx\":\n```diff\n@@ -12,7 +12,7 @@\n const description =\n     \"Zed is a high-performance, multiplayer code editor from the creators of Atom and Tree-sitter.\"\n \n-const images = [`\n+const images = [`/api/\n export const metadata: Metadata = {\n     title: title,\n     description: description,\n\n```\n\nUser edited \"src/app/layout.tsx\":\n```diff\n@@ -12,7 +12,8 @@\n const description =\n     \"Zed is a high-performance, multiplayer code editor from the creators of Atom and Tree-sitter.\"\n \n-const images = [`/api/\n+const images = [`/api/og?title=The editor for%0Awhat's next`]\n+\n export const metadata: Metadata = {\n     title: title,\n     description: description,\n\n```\n\nUser edited \"src/app/layout.tsx\":\n```diff\n@@ -24,7 +24,7 @@\n         siteName: \"Zed\",\n         title: title,\n         description: description,\n-        images: [`/api/og?title=The editor for%0Awhat's next`],\n+        images: images,\n     },\n     twitter: {\n         title: title,\n\n```\n\nUser edited \"src/app/layout.tsx\":\n```diff\n@@ -32,7 +32,7 @@\n         creator: \"@zeddotdev\",\n         site: \"@zeddotdev\",\n         card: \"summary_large_image\",\n-        images: [`/api/og?title=The editor for%0Awhat's next`],\n+        images: images,\n     },\n     metadataBase: new URL(\"https://zed.dev\"),\n }\n\n```\n\nUser edited \"src/ui/companion-video.tsx\":\n```diff\n@@ -6,6 +6,7 @@\n     description: string\n     url: string\n     thumbnail: string\n+    thumbnailAlt\n }\n \n export const CompanionVideo = ({\n\n```\n\nUser edited \"src/ui/companion-video.tsx\":\n```diff\n@@ -6,7 +6,7 @@\n     description: string\n     url: string\n     thumbnail: string\n-    thumbnailAlt\n+    thumbnailAlt: string\n }\n \n export const CompanionVideo = ({\n\n```\n\nUser edited \"src/ui/companion-video.tsx\":\n```diff\n@@ -14,6 +14,7 @@\n     description,\n     url,\n     thumbnail,\n+    thumbnailAlt,\n }: CompanionProps) => {\n     return (\n         <Card\n\n```\n\nUser edited \"src/ui/companion-video.tsx\":\n```diff\n@@ -36,6 +36,7 @@\n                 <Link href={url}>\n                     <img\n                         src={thumbnail}\n+                        alt={thumbnailAlt}\n                         className=\"border-accent-blue/30 rounded-xs border w-full\"\n                         width={230}\n                         height={150}\n\n```\n\nUser edited \"src/ui/companion-video.tsx\":\n```diff\n@@ -14,7 +14,7 @@\n     description,\n     url,\n     thumbnail,\n-    thumbnailAlt,\n+    thumbnailAlt = \"\",\n }: CompanionProps) => {\n     return (\n         <Card\n\n```\n\nUser edited \"src/ui/code.tsx\":\n```diff\n@@ -19,8 +19,8 @@\n     const [copied, setCopied] = React.useState(false)\n \n     const handleCopy = () => {\n-        setCopied(true)\n         if (typeof children === \"string\") {\n+            setCopied(true)\n             copy(children).then(() => {\n                 setTimeout(() => {\n                     setCopied(false)\n\n```\n\nPlease help me complete the code edit.\n\nHere's the current code:\n```script/verify_server.py\n<|start_of_file|>\n<|editable_region_start|>\n<|user_cursor_is_here|>from fastapi import FastAPI, HTTPException, Query\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom fastapi.staticfiles import StaticFiles\nimport uvicorn\nimport os\nimport shutil\nfrom pathlib import Path\nimport glob\nfrom typing import List, Optional\nimport argparse\nimport os.path\n\napp = FastAPI()\n\n# Global variables to store paths\nFEEDBACK_DIR = None\nTRAIN_DIR = None\nTRASH_DIR = None\n\ndef get_next_train_number() -> int:\n    \"\"\"Get the next available number for training examples.\"\"\"\n    files = glob.glob(os.path.join(TRAIN_DIR, \"*.md\"))\n    if not files:\n        return 1\n    numbers = [int(os.path.basename(f).replace(\".md\", \"\")) for f in files]\n    return max(numbers) + 1\n\ndef get_feedback_files() -> List[str]:\n    \"\"\"Get list of feedback files.\"\"\"\n    return sorted(glob.glob(os.path.join(FEEDBACK_DIR, \"*.md\")))\n\n@app.get(\"/api/files\")\nasync def get_files():\n    \"\"\"Get list of feedback files.\"\"\"\n    files = get_feedback_files()\n    return {\"files\": [os.path.basename(f) for f in files]}\n\n@app.get(\"/api/file/{filename}\")\nasync def get_file_content(filename: str):\n    \"\"\"Get content of a specific file.\"\"\"\n    filepath = os.path.join(FEEDBACK_DIR, filename)\n    try:\n        with open(filepath, 'r') as f:\n            content = f.read()\n        return {\"content\": content}\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n@app.post(\"/api/rate/{filename}\")\nasync def rate_file(filename: str, action: str = Query(...)):\n    \"\"\"Handle rating action for a file.\"\"\"\n    filepath = os.path.join(FEEDBACK_DIR, filename)\n    \n    try:\n        if action == \"good\":\n            # Move to train directory with next number\n            next_num = get_next_train_number()\n            new_filename = f\"{next_num:04d}.md\"\n            new_filepath = os.path.join(TRAIN_DIR, new_filename)\n            shutil.move(filepath, new_filepath)\n        elif action == \"bad\":\n            # Move to trash directory\n            trash_filepath = os.path.join(TRASH_DIR, filename)\n            shutil.move(filepath, trash_filepath)\n        else:\n<|editable_region_end|>\n            raise HTTPException(status_code=400, detail=\"Invalid action\")\n```"}, {"role": "assistant", "content": "Suggestion:\n```script/verify_server.py\n<|start_of_file|>\n<|editable_region_start|>\nfrom fastapi import FastAPI, HTTPException, Query\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom fastapi.staticfiles import StaticFiles\nimport uvicorn\nimport os\nimport shutil\nfrom pathlib import Path\nimport glob\nfrom typing import List, Optional\nimport argparse\nimport os.path\n\napp = FastAPI()\n\n# Global variables to store paths\nFEEDBACK_DIR = None\nTRAIN_DIR = None\nTRASH_DIR = None\n\ndef get_next_train_number() -> int:\n    \"\"\"Get the next available number for training examples.\"\"\"\n    files = glob.glob(os.path.join(TRAIN_DIR, \"*.md\"))\n    if not files:\n        return 1\n    numbers = [int(os.path.basename(f).replace(\".md\", \"\")) for f in files]\n    return max(numbers) + 1\n\ndef get_feedback_files() -> List[str]:\n    \"\"\"Get list of feedback files.\"\"\"\n    return sorted(glob.glob(os.path.join(FEEDBACK_DIR, \"*.md\")))\n\n@app.get(\"/api/files\")\nasync def get_files():\n    \"\"\"Get list of feedback files.\"\"\"\n    files = get_feedback_files()\n    return {\"files\": [os.path.basename(f) for f in files]}\n\n@app.get(\"/api/file/{filename}\")\nasync def get_file_content(filename: str):\n    \"\"\"Get content of a specific file.\"\"\"\n    filepath = os.path.join(FEEDBACK_DIR, filename)\n    try:\n        with open(filepath, 'r') as f:\n            content = f.read()\n        return {\"content\": content}\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n\n@app.post(\"/api/rate/{filename}\")\nasync def rate_file(filename: str, action: str = Query(...)):\n    \"\"\"Handle rating action for a file.\"\"\"\n    filepath = os.path.join(FEEDBACK_DIR, filename)\n    \n    try:\n        if action == \"good\":\n            # Move to train directory with next number\n            next_num = get_next_train_number()\n            new_filename = f\"{next_num:04d}.md\"\n            new_filepath = os.path.join(TRAIN_DIR, new_filename)\n            shutil.move(filepath, new_filepath)\n        elif action == \"bad\":\n            # Move to trash directory\n            trash_filepath = os.path.join(TRASH_DIR, filename)\n            shutil.move(filepath, trash_filepath)\n        else:\n<|editable_region_end|>\n            raise HTTPException(status_code=400, detail=\"Invalid action\")\n```"}]}
